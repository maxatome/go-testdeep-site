var relearn_searchindex = [
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "Operator → go type matrix Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator All ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ All Any ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Any Array ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ptr on array ✓ ✗ ✗ Array ArrayEach ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ ArrayEach Bag ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Bag Between ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Between Cap ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ Cap Catch ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Catch Code ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Code Contains ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Contains Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator ContainsKey ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ ContainsKey Delay ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Delay Empty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ Empty ErrorIs ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ error ✗ ✗ ErrorIs First ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ First Grep ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Grep Gt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gt Gte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gte HasPrefix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasPrefix HasSuffix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasSuffix Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Ignore ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Ignore Isa ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Isa JSON ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSON JSONPointer ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSONPointer Keys ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Keys Last ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Last Lax ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Lax Len ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ ✓ ✗ Len Lt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lt Lte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lte Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Map ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ Map MapEach ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ MapEach N ✗ ✗ ✗ ✓ ✓ todo ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ N NaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NaN Nil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Nil None ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ None Not ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Not NotAny ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ NotAny NotEmpty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ NotEmpty NotNaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NotNaN Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator NotNil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ NotNil NotZero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ NotZero PPtr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ PPtr Ptr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ Ptr Re ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Re ReAll ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ ReAll Recv ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ptr on chan ✓ ✓ ✗ Recv Set ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Set Shallow ✓ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Shallow Slice ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ptr on slice ✓ ✗ ✗ Slice Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Smuggle ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Smuggle Sort ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Sort Sorted ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Sorted SStruct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ SStruct String ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ String Struct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ Struct SubBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubBagOf SubJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SubJSONOf SubMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SubMapOf SubSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubSetOf Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator SuperBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperBagOf SuperJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SuperJSONOf SuperMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SuperMapOf SuperSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSetOf SuperSliceOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSliceOf Tag ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Tag TruncTime ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ time.Time todo ✓ ✗ ✗ TruncTime Values ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Values Zero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Zero Legend:\n✗ means using this operator with a value type of this kind will always fail ✓ means using this operator with a value type of this kind can succeed []byte, time.Time, ptr on X, fmt.Stringer, error means using this operator with this go type can succeed todo means should be implemented in future (PRs welcome :) ) ¹ + ✓ means using this operator with the data behind the interface can succeed go type → operator matrix Operators likely to succeed for each go type:\nUntyped nil value All Any Catch Code Delay Ignore JSON JSONPointer Lax Nil None Not NotNil NotZero Shallow Smuggle Tag Zero bool values (or any type based on bool) All Any Catch Code Delay Ignore Isa JSON JSONPointer Lax None Not NotZero Smuggle Tag Zero string values (or any type based on string) All Any Between Catch Code Contains Delay Empty Gt Gte HasPrefix HasSuffix Ignore Isa JSON JSONPointer Lax Lt Lte None Not NotEmpty NotZero Re ReAll Shallow Smuggle String Tag Zero Integer values (uint*, int* or any type based on them) All Any Between Catch Code Delay Gt Gte Ignore Isa JSON JSONPointer Lax Lt Lte N None Not NotZero Smuggle Tag Zero Float values (float32, float64 or any type based on them) All Any Between Catch Code Delay Gt Gte Ignore Isa JSON JSONPointer Lax Lt Lte N NaN None Not NotNaN NotZero Smuggle Tag Zero Complex values (complex64, complex128 or any type based on them) All Any Catch Code Delay Ignore Isa Lax None Not NotZero Smuggle Tag Zero Arrays All Any Array ArrayEach Bag Cap Catch Code Contains Delay Empty First Grep Ignore Isa JSON JSONPointer Last Lax Len None Not NotAny NotEmpty NotZero Set Smuggle Sort Sorted SubBagOf SubSetOf SuperBagOf SuperSetOf SuperSliceOf Tag Zero Slices All Any ArrayEach Bag Cap Catch Code Contains Delay Empty First Grep HasPrefix only []byte HasSuffix only []byte Ignore Isa JSON JSONPointer Last Lax Len Nil None Not NotAny NotEmpty NotNil NotZero Re only []byte ReAll only []byte Set Shallow Slice Smuggle Sort Sorted String only []byte SubBagOf SubSetOf SuperBagOf SuperSetOf SuperSliceOf Tag Zero Maps All Any Catch Code Contains ContainsKey Delay Empty Ignore Isa JSON JSONPointer Keys Lax Len Map MapEach Nil None Not NotEmpty NotNil NotZero Shallow Smuggle SubJSONOf SubMapOf SuperJSONOf SuperMapOf Tag Values Zero Structs All Any Between only time.Time Catch Code Delay Gt only time.Time Gte only time.Time Ignore Isa JSON JSONPointer Lax Lt only time.Time Lte only time.Time None Not NotZero SStruct Smuggle Struct SubJSONOf SuperJSONOf Tag TruncTime only time.Time Zero Interface values As all operators accept interface values, only specific interfaces are listed below:\nContains → fmt.Stringer/error ErrorIs HasPrefix → fmt.Stringer/error HasSuffix → fmt.Stringer/error Re → fmt.Stringer/error ReAll → fmt.Stringer/error String → fmt.Stringer/error Any pointer All Any Array only ptr on array ArrayEach only ptr on array/slice Bag only ptr on array/slice Catch Code Delay Empty only ptr on array/slice/map/string First only ptr on array/slice Grep only ptr on array/slice Ignore Isa JSON JSONPointer Last only ptr on array/slice Lax Map only ptr on map MapEach only ptr on map Nil None Not NotAny only ptr on array/slice NotEmpty only ptr on array/slice/map/string NotNil NotZero PPtr Ptr Recv only ptr on chan SStruct only ptr on struct Set only ptr on array/slice Shallow Slice only ptr on slice Smuggle Sort only ptr on array/slice Sorted only ptr on array/slice Struct only ptr on struct SubBagOf only ptr on array/slice SubJSONOf only ptr on map/struct SubMapOf only ptr on map SubSetOf only ptr on array/slice SuperBagOf only ptr on array/slice SuperJSONOf only ptr on map/struct SuperMapOf only ptr on map SuperSetOf only ptr on array/slice SuperSliceOf only ptr on array/slice Tag Zero Channels All Any Cap Catch Code Delay Empty Ignore Isa Lax Len Nil None Not NotEmpty NotNil NotZero Recv Shallow Smuggle Tag Zero Functions All Any Catch Code Delay Ignore Isa Lax Nil None Not NotNil NotZero Shallow Smuggle Tag Zero",
    "description": "Operator → go type matrix Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator All ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ All Any ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Any Array ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ptr on array ✓ ✗ ✗ Array ArrayEach ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ ArrayEach Bag ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Bag Between ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Between Cap ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ Cap Catch ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Catch Code ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Code Contains ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Contains Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator ContainsKey ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ ContainsKey Delay ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Delay Empty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ Empty ErrorIs ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ error ✗ ✗ ErrorIs First ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ First Grep ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Grep Gt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gt Gte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gte HasPrefix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasPrefix HasSuffix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasSuffix Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Ignore ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Ignore Isa ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Isa JSON ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSON JSONPointer ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSONPointer Keys ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Keys Last ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Last Lax ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Lax Len ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ ✓ ✗ Len Lt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lt Lte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lte Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Map ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ Map MapEach ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ MapEach N ✗ ✗ ✗ ✓ ✓ todo ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ N NaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NaN Nil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Nil None ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ None Not ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Not NotAny ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ NotAny NotEmpty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ NotEmpty NotNaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NotNaN Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator NotNil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ NotNil NotZero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ NotZero PPtr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ PPtr Ptr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ Ptr Re ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Re ReAll ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ ReAll Recv ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ptr on chan ✓ ✓ ✗ Recv Set ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Set Shallow ✓ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Shallow Slice ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ptr on slice ✓ ✗ ✗ Slice Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Smuggle ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Smuggle Sort ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Sort Sorted ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Sorted SStruct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ SStruct String ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ String Struct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ Struct SubBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubBagOf SubJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SubJSONOf SubMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SubMapOf SubSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubSetOf Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator SuperBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperBagOf SuperJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SuperJSONOf SuperMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SuperMapOf SuperSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSetOf SuperSliceOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSliceOf Tag ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Tag TruncTime ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ time.Time todo ✓ ✗ ✗ TruncTime Values ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Values Zero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Zero Legend:",
    "tags": [],
    "title": "Operators matrices",
    "uri": "/operators/matrix/index.html"
  },
  {
    "breadcrumb": "",
    "content": "go-testdeep, via the td package and its helpers, allows golang extremely flexible deep comparison. It is built for testing.\n← use the left menu to navigate. A good starting point is the introduction or the presentation",
    "description": "go-testdeep, via the td package and its helpers, allows golang extremely flexible deep comparison. It is built for testing.\n← use the left menu to navigate. A good starting point is the introduction or the presentation",
    "tags": [],
    "title": "go-testdeep",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "Synopsis Make golang tests easy, from simplest usage:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), \u0026Info{Name: \"Alice\", Age: 42}) } To a bit more complex one, allowing flexible comparisons using TestDeep operators:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), td.Struct( \u0026Info{Name: \"Alice\"}, td.StructFields{ \"Age\": td.Between(40, 45), }, )) } Or anchoring operators directly in literals, as in:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), \u0026Info{ Name: \"Alice\", Age: t.Anchor(td.Between(40, 45)).(int), }) } To most complex one, allowing to easily test HTTP API routes, using flexible operators and the tdhttp helper:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/helpers/tdhttp\" \"github.com/maxatome/go-testdeep/td\" ) type Person struct { ID uint64 `json:\"id\"` Name string `json:\"name\"` Age int `json:\"age\"` CreatedAt time.Time `json:\"created_at\"` } func TestMyApi(t *testing.T) { var id uint64 var createdAt time.Time testAPI := tdhttp.NewTestAPI(t, myAPI) // ← ① testAPI.PostJSON(\"/person\", Person{Name: \"Bob\", Age: 42}). // ← ② Name(\"Create a new Person\"). CmpStatus(http.StatusCreated). // ← ③ CmpJSONBody(td.JSON(` // Note that comments are allowed { \"id\": $id, // set by the API/DB \"name\": \"Alice\", \"age\": Between(40, 45), // ← ④ \"created_at\": \"$createdAt\", // set by the API/DB }`, td.Tag(\"id\", td.Catch(\u0026id, td.NotZero())), // ← ⑤ td.Tag(\"createdAt\", td.All( // ← ⑥ td.HasSuffix(\"Z\"), // ← ⑦ td.Smuggle(func(s string) (time.Time, error) { // ← ⑧ return time.Parse(time.RFC3339Nano, s) }, td.Catch(\u0026createdAt, td.Between(testAPI.SentAt(), time.Now()))), // ← ⑨ )), )) if !testAPI.Failed() { t.Logf(\"The new Person ID is %d and was created at %s\", id, createdAt) } } the API handler ready to be tested; the POST request with automatic JSON marshalling; the expected response HTTP status should be http.StatusCreated and the line just below, the body should match the JSON operator; some operators can be embedded, like [Between] here; for the $id placeholder, Catch its value: put it in id variable and check it is NotZero; for the $createdAt placeholder, use the All operator. It combines several operators like a AND; check that $createdAt date ends with “Z” using HasSuffix. As we expect a RFC3339 date, we require it in UTC time zone; convert $createdAt date into a time.Time using a custom function thanks to the Smuggle operator; then Catch the resulting value: put it in createdAt variable and check it is greater or equal than testAPI.SentAt() (the time just before the request is handled) and lesser or equal than time.Now(). Example of produced error in case of mismatch Description go-testdeep is historically a go rewrite and adaptation of wonderful Test::Deep perl.\nIn golang, comparing data structure is usually done using reflect.DeepEqual or using a package that uses this function behind the scene.\nThis function works very well, but it is not flexible. Both compared structures must match exactly and when a difference is returned, it is up to the caller to display it. Not easy when comparing big data structures.\nThe purpose of go-testdeep, via td package and its helpers, is to do its best to introduce this missing flexibility using “operators”, when the expected value (or one of its component) cannot be matched exactly, mixed with some useful comparison functions.",
    "description": "Synopsis Make golang tests easy, from simplest usage:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), \u0026Info{Name: \"Alice\", Age: 42}) } To a bit more complex one, allowing flexible comparisons using TestDeep operators:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), td.Struct( \u0026Info{Name: \"Alice\"}, td.StructFields{ \"Age\": td.Between(40, 45), }, )) } Or anchoring operators directly in literals, as in:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), \u0026Info{ Name: \"Alice\", Age: t.Anchor(td.Between(40, 45)).(int), }) } To most complex one, allowing to easily test HTTP API routes, using flexible operators and the tdhttp helper:",
    "tags": [],
    "title": "Introduction",
    "uri": "/introduction/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func All(expectedValues ...any) TestDeep All operator compares data against several expected values. During a match, all of them have to match to succeed. Consider it as a “AND” logical operator.\ntd.Cmp(t, \"foobar\", td.All( td.Len(6), td.HasPrefix(\"fo\"), td.HasSuffix(\"ar\"), )) // succeeds Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nstringOps := td.Flatten([]td.TestDeep{td.HasPrefix(\"fo\"), td.HasSuffix(\"ar\")}) td.Cmp(t, \"foobar\", td.All( td.Len(6), stringOps, )) // succeeds One can do the same with All operator itself:\nstringOps := td.All(td.HasPrefix(\"fo\"), td.HasSuffix(\"ar\")) td.Cmp(t, \"foobar\", td.All( td.Len(6), stringOps, )) // succeeds but if an error occurs in the nested All, the report is a bit more complex to read due to the nested level. Flatten does not create a new level, its slice is just flattened in the All parameters.\nTypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa) and they are equal.\nSee also Any and None.\nSee also All godoc.\nExample Base example t := \u0026testing.T{} got := \"foo/bar\" // Checks got string against: // \"o/b\" regexp *AND* \"bar\" suffix *AND* exact \"foo/bar\" string ok := td.Cmp(t, got, td.All(td.Re(\"o/b\"), td.HasSuffix(\"bar\"), \"foo/bar\"), \"checks value %s\", got) fmt.Println(ok) // Checks got string against: // \"o/b\" regexp *AND* \"bar\" suffix *AND* exact \"fooX/Ybar\" string ok = td.Cmp(t, got, td.All(td.Re(\"o/b\"), td.HasSuffix(\"bar\"), \"fooX/Ybar\"), \"checks value %s\", got) fmt.Println(ok) // When some operators or values have to be reused and mixed between // several calls, Flatten can be used to avoid boring and // inefficient []any copies: regOps := td.Flatten([]td.TestDeep{td.Re(\"o/b\"), td.Re(`^fo`), td.Re(`ar$`)}) ok = td.Cmp(t, got, td.All(td.HasPrefix(\"foo\"), regOps, td.HasSuffix(\"bar\")), \"checks all operators against value %s\", got) fmt.Println(ok) // Output: // true // false // true CmpAll shortcut func CmpAll(t TestingT, got any, expectedValues []any, args ...any) bool CmpAll is a shortcut for:\ntd.Cmp(t, got, td.All(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpAll godoc.\nExample Base example t := \u0026testing.T{} got := \"foo/bar\" // Checks got string against: // \"o/b\" regexp *AND* \"bar\" suffix *AND* exact \"foo/bar\" string ok := td.CmpAll(t, got, []any{td.Re(\"o/b\"), td.HasSuffix(\"bar\"), \"foo/bar\"}, \"checks value %s\", got) fmt.Println(ok) // Checks got string against: // \"o/b\" regexp *AND* \"bar\" suffix *AND* exact \"fooX/Ybar\" string ok = td.CmpAll(t, got, []any{td.Re(\"o/b\"), td.HasSuffix(\"bar\"), \"fooX/Ybar\"}, \"checks value %s\", got) fmt.Println(ok) // When some operators or values have to be reused and mixed between // several calls, Flatten can be used to avoid boring and // inefficient []any copies: regOps := td.Flatten([]td.TestDeep{td.Re(\"o/b\"), td.Re(`^fo`), td.Re(`ar$`)}) ok = td.CmpAll(t, got, []any{td.HasPrefix(\"foo\"), regOps, td.HasSuffix(\"bar\")}, \"checks all operators against value %s\", got) fmt.Println(ok) // Output: // true // false // true T.All shortcut func (t *T) All(got any, expectedValues []any, args ...any) bool All is a shortcut for:\nt.Cmp(got, td.All(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.All godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := \"foo/bar\" // Checks got string against: // \"o/b\" regexp *AND* \"bar\" suffix *AND* exact \"foo/bar\" string ok := t.All(got, []any{td.Re(\"o/b\"), td.HasSuffix(\"bar\"), \"foo/bar\"}, \"checks value %s\", got) fmt.Println(ok) // Checks got string against: // \"o/b\" regexp *AND* \"bar\" suffix *AND* exact \"fooX/Ybar\" string ok = t.All(got, []any{td.Re(\"o/b\"), td.HasSuffix(\"bar\"), \"fooX/Ybar\"}, \"checks value %s\", got) fmt.Println(ok) // When some operators or values have to be reused and mixed between // several calls, Flatten can be used to avoid boring and // inefficient []any copies: regOps := td.Flatten([]td.TestDeep{td.Re(\"o/b\"), td.Re(`^fo`), td.Re(`ar$`)}) ok = t.All(got, []any{td.HasPrefix(\"foo\"), regOps, td.HasSuffix(\"bar\")}, \"checks all operators against value %s\", got) fmt.Println(ok) // Output: // true // false // true",
    "description": "func All(expectedValues ...any) TestDeep All operator compares data against several expected values. During a match, all of them have to match to succeed. Consider it as a “AND” logical operator.\ntd.Cmp(t, \"foobar\", td.All( td.Len(6), td.HasPrefix(\"fo\"), td.HasSuffix(\"ar\"), )) // succeeds Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nstringOps := td.Flatten([]td.TestDeep{td.HasPrefix(\"fo\"), td.HasSuffix(\"ar\")}) td.Cmp(t, \"foobar\", td.All( td.Len(6), stringOps, )) // succeeds One can do the same with All operator itself:",
    "tags": [],
    "title": "All",
    "uri": "/operators/all/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Any(expectedValues ...any) TestDeep Any operator compares data against several expected values. During a match, at least one of them has to match to succeed. Consider it as a “OR” logical operator.\ntd.Cmp(t, \"foo\", td.Any(\"bar\", \"foo\", \"zip\")) // succeeds td.Cmp(t, \"foo\", td.Any( td.Len(4), td.HasPrefix(\"f\"), td.HasSuffix(\"z\"), )) // succeeds coz \"f\" prefix Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nstringOps := td.Flatten([]td.TestDeep{td.HasPrefix(\"f\"), td.HasSuffix(\"z\")}) td.Cmp(t, \"foobar\", td.All( td.Len(4), stringOps, )) // succeeds coz \"f\" prefix TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\nSee also All and None.\nSee also Any godoc.\nExample Base example t := \u0026testing.T{} got := \"foo/bar\" // Checks got string against: // \"zip\" regexp *OR* \"bar\" suffix ok := td.Cmp(t, got, td.Any(td.Re(\"zip\"), td.HasSuffix(\"bar\")), \"checks value %s\", got) fmt.Println(ok) // Checks got string against: // \"zip\" regexp *OR* \"foo\" suffix ok = td.Cmp(t, got, td.Any(td.Re(\"zip\"), td.HasSuffix(\"foo\")), \"checks value %s\", got) fmt.Println(ok) // When some operators or values have to be reused and mixed between // several calls, Flatten can be used to avoid boring and // inefficient []any copies: regOps := td.Flatten([]td.TestDeep{td.Re(\"a/c\"), td.Re(`^xx`), td.Re(`ar$`)}) ok = td.Cmp(t, got, td.Any(td.HasPrefix(\"xxx\"), regOps, td.HasSuffix(\"zip\")), \"check at least one operator matches value %s\", got) fmt.Println(ok) // Output: // true // false // true CmpAny shortcut func CmpAny(t TestingT, got any, expectedValues []any, args ...any) bool CmpAny is a shortcut for:\ntd.Cmp(t, got, td.Any(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpAny godoc.\nExample Base example t := \u0026testing.T{} got := \"foo/bar\" // Checks got string against: // \"zip\" regexp *OR* \"bar\" suffix ok := td.CmpAny(t, got, []any{td.Re(\"zip\"), td.HasSuffix(\"bar\")}, \"checks value %s\", got) fmt.Println(ok) // Checks got string against: // \"zip\" regexp *OR* \"foo\" suffix ok = td.CmpAny(t, got, []any{td.Re(\"zip\"), td.HasSuffix(\"foo\")}, \"checks value %s\", got) fmt.Println(ok) // When some operators or values have to be reused and mixed between // several calls, Flatten can be used to avoid boring and // inefficient []any copies: regOps := td.Flatten([]td.TestDeep{td.Re(\"a/c\"), td.Re(`^xx`), td.Re(`ar$`)}) ok = td.CmpAny(t, got, []any{td.HasPrefix(\"xxx\"), regOps, td.HasSuffix(\"zip\")}, \"check at least one operator matches value %s\", got) fmt.Println(ok) // Output: // true // false // true T.Any shortcut func (t *T) Any(got any, expectedValues []any, args ...any) bool Any is a shortcut for:\nt.Cmp(got, td.Any(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Any godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := \"foo/bar\" // Checks got string against: // \"zip\" regexp *OR* \"bar\" suffix ok := t.Any(got, []any{td.Re(\"zip\"), td.HasSuffix(\"bar\")}, \"checks value %s\", got) fmt.Println(ok) // Checks got string against: // \"zip\" regexp *OR* \"foo\" suffix ok = t.Any(got, []any{td.Re(\"zip\"), td.HasSuffix(\"foo\")}, \"checks value %s\", got) fmt.Println(ok) // When some operators or values have to be reused and mixed between // several calls, Flatten can be used to avoid boring and // inefficient []any copies: regOps := td.Flatten([]td.TestDeep{td.Re(\"a/c\"), td.Re(`^xx`), td.Re(`ar$`)}) ok = t.Any(got, []any{td.HasPrefix(\"xxx\"), regOps, td.HasSuffix(\"zip\")}, \"check at least one operator matches value %s\", got) fmt.Println(ok) // Output: // true // false // true",
    "description": "func Any(expectedValues ...any) TestDeep Any operator compares data against several expected values. During a match, at least one of them has to match to succeed. Consider it as a “OR” logical operator.\ntd.Cmp(t, \"foo\", td.Any(\"bar\", \"foo\", \"zip\")) // succeeds td.Cmp(t, \"foo\", td.Any( td.Len(4), td.HasPrefix(\"f\"), td.HasSuffix(\"z\"), )) // succeeds coz \"f\" prefix Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nstringOps := td.Flatten([]td.TestDeep{td.HasPrefix(\"f\"), td.HasSuffix(\"z\")}) td.Cmp(t, \"foobar\", td.All( td.Len(4), stringOps, )) // succeeds coz \"f\" prefix TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.",
    "tags": [],
    "title": "Any",
    "uri": "/operators/any/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Array(model any, expectedEntries ArrayEntries) TestDeep Array operator compares the contents of an array or a pointer on an array against the values of model and the values of expectedEntries. Entries with zero values of model are ignored if the same entry is present in expectedEntries, otherwise they are taken into account. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, all entries are checked. To check only some entries of an array, see SuperSliceOf operator.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\ngot := [3]int{12, 14, 17} td.Cmp(t, got, td.Array([3]int{0, 14}, td.ArrayEntries{0: 12, 2: 17})) // succeeds td.Cmp(t, \u0026got, td.Array(\u0026[3]int{0, 14}, td.ArrayEntries{0: td.Gt(10), 2: td.Gt(15)})) // succeeds TypeBehind method returns the reflect.Type of model.\nSee also Slice and SuperSliceOf.\nSee also Array godoc.\nExamples Array example t := \u0026testing.T{} got := [3]int{42, 58, 26} ok := td.Cmp(t, got, td.Array([3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks array %v\", got) fmt.Println(\"Simple array:\", ok) ok = td.Cmp(t, \u0026got, td.Array(\u0026[3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks array %v\", got) fmt.Println(\"Array pointer:\", ok) ok = td.Cmp(t, \u0026got, td.Array((*[3]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks array %v\", got) fmt.Println(\"Array pointer, nil model:\", ok) // Output: // Simple array: true // Array pointer: true // Array pointer, nil model: true TypedArray example t := \u0026testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.Cmp(t, got, td.Array(MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks typed array %v\", got) fmt.Println(\"Typed array:\", ok) ok = td.Cmp(t, \u0026got, td.Array(\u0026MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array:\", ok) ok = td.Cmp(t, \u0026got, td.Array(\u0026MyArray{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array, empty model:\", ok) ok = td.Cmp(t, \u0026got, td.Array((*MyArray)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array, nil model:\", ok) // Output: // Typed array: true // Pointer on a typed array: true // Pointer on a typed array, empty model: true // Pointer on a typed array, nil model: true CmpArray shortcut func CmpArray(t TestingT, got, model any, expectedEntries ArrayEntries, args ...any) bool CmpArray is a shortcut for:\ntd.Cmp(t, got, td.Array(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpArray godoc.\nExamples Array example t := \u0026testing.T{} got := [3]int{42, 58, 26} ok := td.CmpArray(t, got, [3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks array %v\", got) fmt.Println(\"Simple array:\", ok) ok = td.CmpArray(t, \u0026got, \u0026[3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks array %v\", got) fmt.Println(\"Array pointer:\", ok) ok = td.CmpArray(t, \u0026got, (*[3]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks array %v\", got) fmt.Println(\"Array pointer, nil model:\", ok) // Output: // Simple array: true // Array pointer: true // Array pointer, nil model: true TypedArray example t := \u0026testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.CmpArray(t, got, MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks typed array %v\", got) fmt.Println(\"Typed array:\", ok) ok = td.CmpArray(t, \u0026got, \u0026MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array:\", ok) ok = td.CmpArray(t, \u0026got, \u0026MyArray{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array, empty model:\", ok) ok = td.CmpArray(t, \u0026got, (*MyArray)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array, nil model:\", ok) // Output: // Typed array: true // Pointer on a typed array: true // Pointer on a typed array, empty model: true // Pointer on a typed array, nil model: true T.Array shortcut func (t *T) Array(got, model any, expectedEntries ArrayEntries, args ...any) bool Array is a shortcut for:\nt.Cmp(got, td.Array(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Array godoc.\nExamples Array example t := td.NewT(\u0026testing.T{}) got := [3]int{42, 58, 26} ok := t.Array(got, [3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks array %v\", got) fmt.Println(\"Simple array:\", ok) ok = t.Array(\u0026got, \u0026[3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks array %v\", got) fmt.Println(\"Array pointer:\", ok) ok = t.Array(\u0026got, (*[3]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks array %v\", got) fmt.Println(\"Array pointer, nil model:\", ok) // Output: // Simple array: true // Array pointer: true // Array pointer, nil model: true TypedArray example t := td.NewT(\u0026testing.T{}) type MyArray [3]int got := MyArray{42, 58, 26} ok := t.Array(got, MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks typed array %v\", got) fmt.Println(\"Typed array:\", ok) ok = t.Array(\u0026got, \u0026MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array:\", ok) ok = t.Array(\u0026got, \u0026MyArray{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array, empty model:\", ok) ok = t.Array(\u0026got, (*MyArray)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed array %v\", got) fmt.Println(\"Pointer on a typed array, nil model:\", ok) // Output: // Typed array: true // Pointer on a typed array: true // Pointer on a typed array, empty model: true // Pointer on a typed array, nil model: true",
    "description": "func Array(model any, expectedEntries ArrayEntries) TestDeep Array operator compares the contents of an array or a pointer on an array against the values of model and the values of expectedEntries. Entries with zero values of model are ignored if the same entry is present in expectedEntries, otherwise they are taken into account. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, all entries are checked. To check only some entries of an array, see SuperSliceOf operator.",
    "tags": [],
    "title": "Array",
    "uri": "/operators/array/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func ArrayEach(expectedValue any) TestDeep ArrayEach operator has to be applied on arrays or slices or on pointers on array/slice. It compares each item of data array/slice against expectedValue. During a match, all items have to match to succeed.\ngot := [3]string{\"foo\", \"bar\", \"biz\"} td.Cmp(t, got, td.ArrayEach(td.Len(3))) // succeeds td.Cmp(t, got, td.ArrayEach(td.HasPrefix(\"b\"))) // fails coz \"foo\" Works on slices as well:\ngot := []Person{ {Name: \"Bob\", Age: 42}, {Name: \"Alice\", Age: 24}, } td.Cmp(t, got, td.ArrayEach( td.Struct(Person{}, td.StructFields{ Age: td.Between(20, 45), })), ) // succeeds, each Person has Age field between 20 and 45 See also ArrayEach godoc.\nExamples Array example t := \u0026testing.T{} got := [3]int{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \"checks each item of array %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true TypedArray example t := \u0026testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \"checks each item of typed array %v is in [25 .. 60]\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.ArrayEach(td.Between(25, 60)), \"checks each item of typed array pointer %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true // true Slice example t := \u0026testing.T{} got := []int{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \"checks each item of slice %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true TypedSlice example t := \u0026testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \"checks each item of typed slice %v is in [25 .. 60]\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.ArrayEach(td.Between(25, 60)), \"checks each item of typed slice pointer %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true // true CmpArrayEach shortcut func CmpArrayEach(t TestingT, got, expectedValue any, args ...any) bool CmpArrayEach is a shortcut for:\ntd.Cmp(t, got, td.ArrayEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpArrayEach godoc.\nExamples Array example t := \u0026testing.T{} got := [3]int{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \"checks each item of array %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true TypedArray example t := \u0026testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \"checks each item of typed array %v is in [25 .. 60]\", got) fmt.Println(ok) ok = td.CmpArrayEach(t, \u0026got, td.Between(25, 60), \"checks each item of typed array pointer %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true // true Slice example t := \u0026testing.T{} got := []int{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \"checks each item of slice %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true TypedSlice example t := \u0026testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \"checks each item of typed slice %v is in [25 .. 60]\", got) fmt.Println(ok) ok = td.CmpArrayEach(t, \u0026got, td.Between(25, 60), \"checks each item of typed slice pointer %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true // true T.ArrayEach shortcut func (t *T) ArrayEach(got, expectedValue any, args ...any) bool ArrayEach is a shortcut for:\nt.Cmp(got, td.ArrayEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.ArrayEach godoc.\nExamples Array example t := td.NewT(\u0026testing.T{}) got := [3]int{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \"checks each item of array %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true TypedArray example t := td.NewT(\u0026testing.T{}) type MyArray [3]int got := MyArray{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \"checks each item of typed array %v is in [25 .. 60]\", got) fmt.Println(ok) ok = t.ArrayEach(\u0026got, td.Between(25, 60), \"checks each item of typed array pointer %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true // true Slice example t := td.NewT(\u0026testing.T{}) got := []int{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \"checks each item of slice %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true TypedSlice example t := td.NewT(\u0026testing.T{}) type MySlice []int got := MySlice{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \"checks each item of typed slice %v is in [25 .. 60]\", got) fmt.Println(ok) ok = t.ArrayEach(\u0026got, td.Between(25, 60), \"checks each item of typed slice pointer %v is in [25 .. 60]\", got) fmt.Println(ok) // Output: // true // true",
    "description": "func ArrayEach(expectedValue any) TestDeep ArrayEach operator has to be applied on arrays or slices or on pointers on array/slice. It compares each item of data array/slice against expectedValue. During a match, all items have to match to succeed.\ngot := [3]string{\"foo\", \"bar\", \"biz\"} td.Cmp(t, got, td.ArrayEach(td.Len(3))) // succeeds td.Cmp(t, got, td.ArrayEach(td.HasPrefix(\"b\"))) // fails coz \"foo\" Works on slices as well:\ngot := []Person{ {Name: \"Bob\", Age: 42}, {Name: \"Alice\", Age: 24}, } td.Cmp(t, got, td.ArrayEach( td.Struct(Person{}, td.StructFields{ Age: td.Between(20, 45), })), ) // succeeds, each Person has Age field between 20 and 45 See also ArrayEach godoc.",
    "tags": [],
    "title": "ArrayEach",
    "uri": "/operators/arrayeach/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Bag(expectedItems ...any) TestDeep Bag operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\ntd.Cmp(t, []int{1, 1, 2}, td.Bag(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(2, 1, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2)) // fails, one 1 is missing td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.Bag( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{1, 2, 1} td.Cmp(t, []int{1, 1, 2}, td.Bag(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1)) exp1 := []int{5, 1, 1} exp2 := []int{8, 42, 3} td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.Bag(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.Bag(5, 1, 1, 3, 8, 42, 3)) TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\nSee also SubBagOf, SuperBagOf, Set and Sort.\nSee also Bag godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present ok := td.Cmp(t, got, td.Bag(1, 1, 2, 3, 5, 8, 8), \"checks all items are present, in any order\") fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these // duplicates are not expected ok = td.Cmp(t, got, td.Bag(1, 2, 3, 5, 8), \"checks all items are present, in any order\") fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got ok = td.Cmp(t, got, td.Bag(1, 1, 2, 3, 5, 8, 8), \"checks all items are present, in any order\") fmt.Println(ok) // Matches as all items are present ok = td.Cmp(t, got, td.Bag(1, 2, 3, 5, td.Gt(7)), \"checks all items are present, in any order\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5} ok = td.Cmp(t, got, td.Bag(td.Flatten(expected), td.Gt(7)), \"checks all expected items are present, in any order\") fmt.Println(ok) // Output: // true // false // false // true // true CmpBag shortcut func CmpBag(t TestingT, got any, expectedItems []any, args ...any) bool CmpBag is a shortcut for:\ntd.Cmp(t, got, td.Bag(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpBag godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present ok := td.CmpBag(t, got, []any{1, 1, 2, 3, 5, 8, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these // duplicates are not expected ok = td.CmpBag(t, got, []any{1, 2, 3, 5, 8}, \"checks all items are present, in any order\") fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got ok = td.CmpBag(t, got, []any{1, 1, 2, 3, 5, 8, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Matches as all items are present ok = td.CmpBag(t, got, []any{1, 2, 3, 5, td.Gt(7)}, \"checks all items are present, in any order\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5} ok = td.CmpBag(t, got, []any{td.Flatten(expected), td.Gt(7)}, \"checks all expected items are present, in any order\") fmt.Println(ok) // Output: // true // false // false // true // true T.Bag shortcut func (t *T) Bag(got any, expectedItems []any, args ...any) bool Bag is a shortcut for:\nt.Cmp(got, td.Bag(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Bag godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present ok := t.Bag(got, []any{1, 1, 2, 3, 5, 8, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these // duplicates are not expected ok = t.Bag(got, []any{1, 2, 3, 5, 8}, \"checks all items are present, in any order\") fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got ok = t.Bag(got, []any{1, 1, 2, 3, 5, 8, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Matches as all items are present ok = t.Bag(got, []any{1, 2, 3, 5, td.Gt(7)}, \"checks all items are present, in any order\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5} ok = t.Bag(got, []any{td.Flatten(expected), td.Gt(7)}, \"checks all expected items are present, in any order\") fmt.Println(ok) // Output: // true // false // false // true // true",
    "description": "func Bag(expectedItems ...any) TestDeep Bag operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\ntd.Cmp(t, []int{1, 1, 2}, td.Bag(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(2, 1, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2)) // fails, one 1 is missing td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.Bag( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:",
    "tags": [],
    "title": "Bag",
    "uri": "/operators/bag/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Between(from, to any, bounds ...BoundsKind) TestDeep Between operator checks that data is between from and to. from and to can be any numeric, string, time.Time (or assignable) value or implement at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b from and to must be the same type as the compared value, except if BeLax config flag is true. time.Duration type is accepted as to when from is time.Time or convertible. bounds allows to specify whether bounds are included or not:\nBoundsInIn (default): between from and to both included BoundsInOut: between from included and to excluded BoundsOutIn: between from excluded and to included BoundsOutOut: between from and to both excluded If bounds is missing, it defaults to BoundsInIn.\ntc.Cmp(t, 17, td.Between(17, 20)) // succeeds, BoundsInIn by default tc.Cmp(t, 17, td.Between(10, 17, BoundsInOut)) // fails tc.Cmp(t, 17, td.Between(10, 17, BoundsOutIn)) // succeeds tc.Cmp(t, 17, td.Between(17, 20, BoundsOutOut)) // fails tc.Cmp(t, // succeeds netip.MustParse(\"127.0.0.1\"), td.Between(netip.MustParse(\"127.0.0.0\"), netip.MustParse(\"127.255.255.255\"))) TypeBehind method returns the reflect.Type of from.\nSee also Between godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.Cmp(t, got, td.Between(154, 156), \"checks %v is in [154 .. 156]\", got) fmt.Println(ok) // BoundsInIn is implicit ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsInIn), \"checks %v is in [154 .. 156]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsInOut), \"checks %v is in [154 .. 156[\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsOutIn), \"checks %v is in ]154 .. 156]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsOutOut), \"checks %v is in ]154 .. 156[\", got) fmt.Println(ok) // Output: // true // true // false // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.Cmp(t, got, td.Between(\"aaa\", \"abc\"), `checks \"%v\" is in [\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) // BoundsInIn is implicit ok = td.Cmp(t, got, td.Between(\"aaa\", \"abc\", td.BoundsInIn), `checks \"%v\" is in [\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(\"aaa\", \"abc\", td.BoundsInOut), `checks \"%v\" is in [\"aaa\" .. \"abc\"[`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(\"aaa\", \"abc\", td.BoundsOutIn), `checks \"%v\" is in ]\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(\"aaa\", \"abc\", td.BoundsOutOut), `checks \"%v\" is in ]\"aaa\" .. \"abc\"[`, got) fmt.Println(ok) // Output: // true // true // false // true // false Time example t := \u0026testing.T{} before := time.Now() occurredAt := time.Now() after := time.Now() ok := td.Cmp(t, occurredAt, td.Between(before, after)) fmt.Println(\"It occurred between before and after:\", ok) type MyTime time.Time ok = td.Cmp(t, MyTime(occurredAt), td.Between(MyTime(before), MyTime(after))) fmt.Println(\"Same for convertible MyTime type:\", ok) ok = td.Cmp(t, MyTime(occurredAt), td.Between(before, after)) fmt.Println(\"MyTime vs time.Time:\", ok) ok = td.Cmp(t, occurredAt, td.Between(before, 10*time.Second)) fmt.Println(\"Using a time.Duration as TO:\", ok) ok = td.Cmp(t, MyTime(occurredAt), td.Between(MyTime(before), 10*time.Second)) fmt.Println(\"Using MyTime as FROM and time.Duration as TO:\", ok) // Output: // It occurred between before and after: true // Same for convertible MyTime type: true // MyTime vs time.Time: false // Using a time.Duration as TO: true // Using MyTime as FROM and time.Duration as TO: true CmpBetween shortcut func CmpBetween(t TestingT, got, from , to any, bounds BoundsKind, args ...any) bool CmpBetween is a shortcut for:\ntd.Cmp(t, got, td.Between(from, to, bounds), args...) See above for details.\nBetween optional parameter bounds is here mandatory. BoundsInIn value should be passed to mimic its absence in original Between call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpBetween godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.CmpBetween(t, got, 154, 156, td.BoundsInIn, \"checks %v is in [154 .. 156]\", got) fmt.Println(ok) // BoundsInIn is implicit ok = td.CmpBetween(t, got, 154, 156, td.BoundsInIn, \"checks %v is in [154 .. 156]\", got) fmt.Println(ok) ok = td.CmpBetween(t, got, 154, 156, td.BoundsInOut, \"checks %v is in [154 .. 156[\", got) fmt.Println(ok) ok = td.CmpBetween(t, got, 154, 156, td.BoundsOutIn, \"checks %v is in ]154 .. 156]\", got) fmt.Println(ok) ok = td.CmpBetween(t, got, 154, 156, td.BoundsOutOut, \"checks %v is in ]154 .. 156[\", got) fmt.Println(ok) // Output: // true // true // false // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.CmpBetween(t, got, \"aaa\", \"abc\", td.BoundsInIn, `checks \"%v\" is in [\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) // BoundsInIn is implicit ok = td.CmpBetween(t, got, \"aaa\", \"abc\", td.BoundsInIn, `checks \"%v\" is in [\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) ok = td.CmpBetween(t, got, \"aaa\", \"abc\", td.BoundsInOut, `checks \"%v\" is in [\"aaa\" .. \"abc\"[`, got) fmt.Println(ok) ok = td.CmpBetween(t, got, \"aaa\", \"abc\", td.BoundsOutIn, `checks \"%v\" is in ]\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) ok = td.CmpBetween(t, got, \"aaa\", \"abc\", td.BoundsOutOut, `checks \"%v\" is in ]\"aaa\" .. \"abc\"[`, got) fmt.Println(ok) // Output: // true // true // false // true // false Time example t := \u0026testing.T{} before := time.Now() occurredAt := time.Now() after := time.Now() ok := td.CmpBetween(t, occurredAt, before, after, td.BoundsInIn) fmt.Println(\"It occurred between before and after:\", ok) type MyTime time.Time ok = td.CmpBetween(t, MyTime(occurredAt), MyTime(before), MyTime(after), td.BoundsInIn) fmt.Println(\"Same for convertible MyTime type:\", ok) ok = td.CmpBetween(t, MyTime(occurredAt), before, after, td.BoundsInIn) fmt.Println(\"MyTime vs time.Time:\", ok) ok = td.CmpBetween(t, occurredAt, before, 10*time.Second, td.BoundsInIn) fmt.Println(\"Using a time.Duration as TO:\", ok) ok = td.CmpBetween(t, MyTime(occurredAt), MyTime(before), 10*time.Second, td.BoundsInIn) fmt.Println(\"Using MyTime as FROM and time.Duration as TO:\", ok) // Output: // It occurred between before and after: true // Same for convertible MyTime type: true // MyTime vs time.Time: false // Using a time.Duration as TO: true // Using MyTime as FROM and time.Duration as TO: true T.Between shortcut func (t *T) Between(got, from , to any, bounds BoundsKind, args ...any) bool Between is a shortcut for:\nt.Cmp(got, td.Between(from, to, bounds), args...) See above for details.\nBetween optional parameter bounds is here mandatory. BoundsInIn value should be passed to mimic its absence in original Between call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Between godoc.\nExamples Int example t := td.NewT(\u0026testing.T{}) got := 156 ok := t.Between(got, 154, 156, td.BoundsInIn, \"checks %v is in [154 .. 156]\", got) fmt.Println(ok) // BoundsInIn is implicit ok = t.Between(got, 154, 156, td.BoundsInIn, \"checks %v is in [154 .. 156]\", got) fmt.Println(ok) ok = t.Between(got, 154, 156, td.BoundsInOut, \"checks %v is in [154 .. 156[\", got) fmt.Println(ok) ok = t.Between(got, 154, 156, td.BoundsOutIn, \"checks %v is in ]154 .. 156]\", got) fmt.Println(ok) ok = t.Between(got, 154, 156, td.BoundsOutOut, \"checks %v is in ]154 .. 156[\", got) fmt.Println(ok) // Output: // true // true // false // true // false String example t := td.NewT(\u0026testing.T{}) got := \"abc\" ok := t.Between(got, \"aaa\", \"abc\", td.BoundsInIn, `checks \"%v\" is in [\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) // BoundsInIn is implicit ok = t.Between(got, \"aaa\", \"abc\", td.BoundsInIn, `checks \"%v\" is in [\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) ok = t.Between(got, \"aaa\", \"abc\", td.BoundsInOut, `checks \"%v\" is in [\"aaa\" .. \"abc\"[`, got) fmt.Println(ok) ok = t.Between(got, \"aaa\", \"abc\", td.BoundsOutIn, `checks \"%v\" is in ]\"aaa\" .. \"abc\"]`, got) fmt.Println(ok) ok = t.Between(got, \"aaa\", \"abc\", td.BoundsOutOut, `checks \"%v\" is in ]\"aaa\" .. \"abc\"[`, got) fmt.Println(ok) // Output: // true // true // false // true // false Time example t := td.NewT(\u0026testing.T{}) before := time.Now() occurredAt := time.Now() after := time.Now() ok := t.Between(occurredAt, before, after, td.BoundsInIn) fmt.Println(\"It occurred between before and after:\", ok) type MyTime time.Time ok = t.Between(MyTime(occurredAt), MyTime(before), MyTime(after), td.BoundsInIn) fmt.Println(\"Same for convertible MyTime type:\", ok) ok = t.Between(MyTime(occurredAt), before, after, td.BoundsInIn) fmt.Println(\"MyTime vs time.Time:\", ok) ok = t.Between(occurredAt, before, 10*time.Second, td.BoundsInIn) fmt.Println(\"Using a time.Duration as TO:\", ok) ok = t.Between(MyTime(occurredAt), MyTime(before), 10*time.Second, td.BoundsInIn) fmt.Println(\"Using MyTime as FROM and time.Duration as TO:\", ok) // Output: // It occurred between before and after: true // Same for convertible MyTime type: true // MyTime vs time.Time: false // Using a time.Duration as TO: true // Using MyTime as FROM and time.Duration as TO: true",
    "description": "func Between(from, to any, bounds ...BoundsKind) TestDeep Between operator checks that data is between from and to. from and to can be any numeric, string, time.Time (or assignable) value or implement at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b from and to must be the same type as the compared value, except if BeLax config flag is true. time.Duration type is accepted as to when from is time.Time or convertible. bounds allows to specify whether bounds are included or not:",
    "tags": [],
    "title": "Between",
    "uri": "/operators/between/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Cap(expectedCap any) TestDeep Cap is a smuggler operator. It takes data, applies cap() function on it and compares its result to expectedCap. Of course, the compared value must be an array, a channel or a slice.\nexpectedCap can be an int value:\ntd.Cmp(t, gotSlice, td.Cap(12)) as well as an other operator:\ntd.Cmp(t, gotSlice, td.Cap(td.Between(3, 4))) See also Len.\nSee also Cap godoc.\nExamples Base example t := \u0026testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(12), \"checks %v capacity is 12\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(0), \"checks %v capacity is 0\", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Cap(0), \"checks %v capacity is 0\", got) fmt.Println(ok) // Output: // true // false // true Operator example t := \u0026testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(td.Between(10, 12)), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(td.Gt(10)), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) // Output: // true // true CmpCap shortcut func CmpCap(t TestingT, got, expectedCap any, args ...any) bool CmpCap is a shortcut for:\ntd.Cmp(t, got, td.Cap(expectedCap), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpCap godoc.\nExamples Base example t := \u0026testing.T{} got := make([]int, 0, 12) ok := td.CmpCap(t, got, 12, \"checks %v capacity is 12\", got) fmt.Println(ok) ok = td.CmpCap(t, got, 0, \"checks %v capacity is 0\", got) fmt.Println(ok) got = nil ok = td.CmpCap(t, got, 0, \"checks %v capacity is 0\", got) fmt.Println(ok) // Output: // true // false // true Operator example t := \u0026testing.T{} got := make([]int, 0, 12) ok := td.CmpCap(t, got, td.Between(10, 12), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) ok = td.CmpCap(t, got, td.Gt(10), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) // Output: // true // true T.Cap shortcut func (t *T) Cap(got, expectedCap any, args ...any) bool Cap is a shortcut for:\nt.Cmp(got, td.Cap(expectedCap), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Cap godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) got := make([]int, 0, 12) ok := t.Cap(got, 12, \"checks %v capacity is 12\", got) fmt.Println(ok) ok = t.Cap(got, 0, \"checks %v capacity is 0\", got) fmt.Println(ok) got = nil ok = t.Cap(got, 0, \"checks %v capacity is 0\", got) fmt.Println(ok) // Output: // true // false // true Operator example t := td.NewT(\u0026testing.T{}) got := make([]int, 0, 12) ok := t.Cap(got, td.Between(10, 12), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) ok = t.Cap(got, td.Gt(10), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) // Output: // true // true",
    "description": "func Cap(expectedCap any) TestDeep Cap is a smuggler operator. It takes data, applies cap() function on it and compares its result to expectedCap. Of course, the compared value must be an array, a channel or a slice.\nexpectedCap can be an int value:\ntd.Cmp(t, gotSlice, td.Cap(12)) as well as an other operator:\ntd.Cmp(t, gotSlice, td.Cap(td.Between(3, 4))) See also Len.\nSee also Cap godoc.\nExamples Base example t := \u0026testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(12), \"checks %v capacity is 12\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(0), \"checks %v capacity is 0\", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Cap(0), \"checks %v capacity is 0\", got) fmt.Println(ok) // Output: // true // false // true Operator example t := \u0026testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(td.Between(10, 12)), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(td.Gt(10)), \"checks %v capacity is in [10 .. 12]\", got) fmt.Println(ok) // Output: // true // true",
    "tags": [],
    "title": "Cap",
    "uri": "/operators/cap/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Catch(target, expectedValue any) TestDeep Catch is a smuggler operator. It allows to copy data in target on the fly before comparing it as usual against expectedValue.\ntarget must be a non-nil pointer and data should be assignable to its pointed type. If BeLax config flag is true or called under Lax (and so JSON) operator, data should be convertible to its pointer type.\nvar id int64 if td.Cmp(t, CreateRecord(\"test\"), td.JSON(`{\"id\": $1, \"name\": \"test\"}`, td.Catch(\u0026id, td.NotZero()))) { t.Logf(\"Created record ID is %d\", id) } It is really useful when used with JSON operator and/or tdhttp helper.\nvar id int64 ta := tdhttp.NewTestAPI(t, api.Handler). PostJSON(\"/item\", `{\"name\":\"foo\"}`). CmpStatus(http.StatusCreated). CmpJSONBody(td.JSON(`{\"id\": $1, \"name\": \"foo\"}`, td.Catch(\u0026id, td.Gt(0)))) if !ta.Failed() { t.Logf(\"Created record ID is %d\", id) } If you need to only catch data without comparing it, use Ignore operator as expectedValue as in:\nvar id int64 if td.Cmp(t, CreateRecord(\"test\"), td.JSON(`{\"id\": $1, \"name\": \"test\"}`, td.Catch(\u0026id, td.Ignore()))) { t.Logf(\"Created record ID is %d\", id) } TypeBehind method returns the reflect.Type of expectedValue, except if expectedValue is a TestDeep operator. In this case, it delegates TypeBehind() to the operator, but if nil is returned by this call, the dereferenced reflect.Type of target is returned.\nSee also Catch godoc.\nExample Base example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } var age int ok := td.Cmp(t, got, td.JSON(`{\"age\":$1,\"fullname\":\"Bob\"}`, td.Catch(\u0026age, td.Between(40, 45)))) fmt.Println(\"check got age+fullname:\", ok) fmt.Println(\"caught age:\", age) // Output: // check got age+fullname: true // caught age: 42",
    "description": "func Catch(target, expectedValue any) TestDeep Catch is a smuggler operator. It allows to copy data in target on the fly before comparing it as usual against expectedValue.\ntarget must be a non-nil pointer and data should be assignable to its pointed type. If BeLax config flag is true or called under Lax (and so JSON) operator, data should be convertible to its pointer type.\nvar id int64 if td.Cmp(t, CreateRecord(\"test\"), td.JSON(`{\"id\": $1, \"name\": \"test\"}`, td.Catch(\u0026id, td.NotZero()))) { t.Logf(\"Created record ID is %d\", id) } It is really useful when used with JSON operator and/or tdhttp helper.",
    "tags": [],
    "title": "Catch",
    "uri": "/operators/catch/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Code(fn any) TestDeep Code operator allows to check data using a custom function. So fn is a function that must take one parameter whose type must be the same as the type of the compared value.\nfn can return a single bool kind value, telling that yes or no the custom test is successful:\ntd.Cmp(t, gotTime, td.Code(func(date time.Time) bool { return date.Year() == 2018 })) or two values (bool, string) kinds. The bool value has the same meaning as above, and the string value is used to describe the test when it fails:\ntd.Cmp(t, gotTime, td.Code(func(date time.Time) (bool, string) { if date.Year() == 2018 { return true, \"\" } return false, \"year must be 2018\" })) or a single error value. If the returned error is nil, the test succeeded, else the error contains the reason of failure:\ntd.Cmp(t, gotJsonRawMesg, td.Code(func(b json.RawMessage) error { var c map[string]int err := json.Unmarshal(b, \u0026c) if err != nil { return err } if c[\"test\"] != 42 { return fmt.Errorf(`key \"test\" does not match 42`) } return nil })) This operator allows to handle any specific comparison not handled by standard operators.\nIt is not recommended to call Cmp (or any other Cmp* functions or *T methods) inside the body of fn, because of confusion produced by output in case of failure. When the data needs to be transformed before being compared again, Smuggle operator should be used instead.\nBut in some cases it can be better to handle yourself the comparison than to chain TestDeep operators. In this case, fn can be a function receiving one or two *T as first parameters and returning no values.\nWhen fn expects one *T parameter, it is directly derived from the testing.TB instance passed originally to Cmp (or its derivatives) using NewT:\ntd.Cmp(t, httpRequest, td.Code(func(t *td.T, r *http.Request) { token, err := DecodeToken(r.Header.Get(\"X-Token-1\")) if t.CmpNoError(err) { t.True(token.OK()) } })) When fn expects two *T parameters, they are directly derived from the testing.TB instance passed originally to Cmp (or its derivatives) using AssertRequire:\ntd.Cmp(t, httpRequest, td.Code(func(assert, require *td.T, r *http.Request) { token, err := DecodeToken(r.Header.Get(\"X-Token-1\")) require.CmpNoError(err) assert.True(token.OK()) })) Note that these forms do not work when there is no initial testing.TB instance, like when using EqDeeplyError or EqDeeply functions, or when the Code operator is called behind the following operators, as they just check if a match occurs without raising an error: Any, Bag, Contains, ContainsKey, None, Not, NotAny, Set, SubBagOf, SubSetOf, SuperBagOf and SuperSetOf.\nRootName is inherited but not the current path, but it can be recovered if needed:\ngot := map[string]int{\"foo\": 123} td.NewT(t). RootName(\"PIPO\"). Cmp(got, td.Map(map[string]int{}, td.MapEntries{ \"foo\": td.Code(func(t *td.T, n int) { t.Cmp(n, 124) // inherit only RootName t.RootName(t.Config.OriginalPath()).Cmp(n, 125) // recover current path t.RootName(\"\").Cmp(n, 126) // undo RootName inheritance }), })) produces the following errors:\n--- FAIL: TestCodeCustom (0.00s) td_code_test.go:339: Failed test PIPO: values differ ← inherit only RootName got: 123 expected: 124 td_code_test.go:338: Failed test PIPO[\"foo\"]: values differ ← recover current path got: 123 expected: 125 td_code_test.go:342: Failed test DATA: values differ ← undo RootName inheritance got: 123 expected: 126 TypeBehind method returns the reflect.Type of last parameter of fn.\nSee also Code godoc.\nExamples Base example t := \u0026testing.T{} got := \"12\" ok := td.Cmp(t, got, td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 }), \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Same with failure reason ok = td.Cmp(t, got, td.Code(func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \"not a number\" } if n \u003e 10 \u0026\u0026 n \u003c 100 { return true, \"\" } return false, \"not in ]10 .. 100[\" }), \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Same with failure reason thanks to error ok = td.Cmp(t, got, td.Code(func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u003e 10 \u0026\u0026 n \u003c 100 { return nil } return fmt.Errorf(\"%d not in ]10 .. 100[\", n) }), \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Output: // true // true // true Custom example t := \u0026testing.T{} got := 123 ok := td.Cmp(t, got, td.Code(func(t *td.T, num int) { t.Cmp(num, 123) })) fmt.Println(\"with one *td.T:\", ok) ok = td.Cmp(t, got, td.Code(func(assert, require *td.T, num int) { assert.Cmp(num, 123) require.Cmp(num, 123) })) fmt.Println(\"with assert \u0026 require *td.T:\", ok) // Output: // with one *td.T: true // with assert \u0026 require *td.T: true CmpCode shortcut func CmpCode(t TestingT, got, fn any, args ...any) bool CmpCode is a shortcut for:\ntd.Cmp(t, got, td.Code(fn), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpCode godoc.\nExamples Base example t := \u0026testing.T{} got := \"12\" ok := td.CmpCode(t, got, func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 }, \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Same with failure reason ok = td.CmpCode(t, got, func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \"not a number\" } if n \u003e 10 \u0026\u0026 n \u003c 100 { return true, \"\" } return false, \"not in ]10 .. 100[\" }, \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Same with failure reason thanks to error ok = td.CmpCode(t, got, func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u003e 10 \u0026\u0026 n \u003c 100 { return nil } return fmt.Errorf(\"%d not in ]10 .. 100[\", n) }, \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Output: // true // true // true Custom example t := \u0026testing.T{} got := 123 ok := td.CmpCode(t, got, func(t *td.T, num int) { t.Cmp(num, 123) }) fmt.Println(\"with one *td.T:\", ok) ok = td.CmpCode(t, got, func(assert, require *td.T, num int) { assert.Cmp(num, 123) require.Cmp(num, 123) }) fmt.Println(\"with assert \u0026 require *td.T:\", ok) // Output: // with one *td.T: true // with assert \u0026 require *td.T: true T.Code shortcut func (t *T) Code(got, fn any, args ...any) bool Code is a shortcut for:\nt.Cmp(got, td.Code(fn), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Code godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) got := \"12\" ok := t.Code(got, func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 }, \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Same with failure reason ok = t.Code(got, func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \"not a number\" } if n \u003e 10 \u0026\u0026 n \u003c 100 { return true, \"\" } return false, \"not in ]10 .. 100[\" }, \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Same with failure reason thanks to error ok = t.Code(got, func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u003e 10 \u0026\u0026 n \u003c 100 { return nil } return fmt.Errorf(\"%d not in ]10 .. 100[\", n) }, \"checks string `%s` contains a number and this number is in ]10 .. 100[\", got) fmt.Println(ok) // Output: // true // true // true Custom example t := td.NewT(\u0026testing.T{}) got := 123 ok := t.Code(got, func(t *td.T, num int) { t.Cmp(num, 123) }) fmt.Println(\"with one *td.T:\", ok) ok = t.Code(got, func(assert, require *td.T, num int) { assert.Cmp(num, 123) require.Cmp(num, 123) }) fmt.Println(\"with assert \u0026 require *td.T:\", ok) // Output: // with one *td.T: true // with assert \u0026 require *td.T: true",
    "description": "func Code(fn any) TestDeep Code operator allows to check data using a custom function. So fn is a function that must take one parameter whose type must be the same as the type of the compared value.\nfn can return a single bool kind value, telling that yes or no the custom test is successful:\ntd.Cmp(t, gotTime, td.Code(func(date time.Time) bool { return date.Year() == 2018 })) or two values (bool, string) kinds. The bool value has the same meaning as above, and the string value is used to describe the test when it fails:",
    "tags": [],
    "title": "Code",
    "uri": "/operators/code/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Contains(expectedValue any) TestDeep Contains is a smuggler operator to check if something is contained in another thing. Contains has to be applied on arrays, slices, maps or strings. It tries to be as smarter as possible.\nIf expectedValue is a TestDeep operator, each item of data array/slice/map/string (rune for strings) is compared to it. The use of a TestDeep operator as expectedValue works only in this way: item per item.\nIf data is a slice, and expectedValue has the same type, then expectedValue is searched as a sub-slice, otherwise expectedValue is compared to each slice value.\nlist := []int{12, 34, 28} td.Cmp(t, list, td.Contains(34)) // succeeds td.Cmp(t, list, td.Contains(td.Between(30, 35))) // succeeds too td.Cmp(t, list, td.Contains(35)) // fails td.Cmp(t, list, td.Contains([]int{34, 28})) // succeeds If data is an array or a map, each value is compared to expectedValue. Map keys are not checked: see ContainsKey to check map keys existence.\nhash := map[string]int{\"foo\": 12, \"bar\": 34, \"zip\": 28} td.Cmp(t, hash, td.Contains(34)) // succeeds td.Cmp(t, hash, td.Contains(td.Between(30, 35))) // succeeds too td.Cmp(t, hash, td.Contains(35)) // fails array := [...]int{12, 34, 28} td.Cmp(t, array, td.Contains(34)) // succeeds td.Cmp(t, array, td.Contains(td.Between(30, 35))) // succeeds too td.Cmp(t, array, td.Contains(35)) // fails If data is a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer), expectedValue can be a string, a []byte, a rune or a byte. In this case, it tests if the got string contains this expected string, []byte, rune or byte.\ngot := \"foo bar\" td.Cmp(t, got, td.Contains('o')) // succeeds td.Cmp(t, got, td.Contains(rune('o'))) // succeeds td.Cmp(t, got, td.Contains(td.Between('n', 'p'))) // succeeds td.Cmp(t, got, td.Contains(\"bar\")) // succeeds td.Cmp(t, got, td.Contains([]byte(\"bar\"))) // succeeds td.Cmp(t, []byte(\"foobar\"), td.Contains(\"ooba\")) // succeeds type Foobar string td.Cmp(t, Foobar(\"foobar\"), td.Contains(\"ooba\")) // succeeds err := errors.New(\"error!\") td.Cmp(t, err, td.Contains(\"ror\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.Contains(\"String\")) // succeeds Pitfall: if you want to check if 2 words are contained in got, don’t do:\ntd.Cmp(t, \"foobar\", td.Contains(td.All(\"foo\", \"bar\"))) // Bad! as TestDeep operator All in Contains operates on each rune, so it does not work as expected, but do::\ntd.Cmp(t, \"foobar\", td.All(td.Contains(\"foo\"), td.Contains(\"bar\"))) When Contains(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the array/slice/map item type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):\nnum := 123 list := []*int{\u0026num, nil} td.Cmp(t, list, td.Contains(nil)) // succeeds → (*int)(nil) td.Cmp(t, list, td.Contains((*int)(nil))) // succeeds td.Cmp(t, list, td.Contains(td.Nil())) // succeeds // But... td.Cmp(t, list, td.Contains((*byte)(nil))) // fails: (*byte)(nil) ≠ (*int)(nil) As well as these ones:\nhash := map[string]*int{\"foo\": nil, \"bar\": \u0026num} td.Cmp(t, hash, td.Contains(nil)) // succeeds → (*int)(nil) td.Cmp(t, hash, td.Contains((*int)(nil))) // succeeds td.Cmp(t, hash, td.Contains(td.Nil())) // succeeds See also ContainsKey.\nSee also Contains godoc.\nExamples ArraySlice example t := \u0026testing.T{} ok := td.Cmp(t, [...]int{11, 22, 33, 44}, td.Contains(22)) fmt.Println(\"array contains 22:\", ok) ok = td.Cmp(t, [...]int{11, 22, 33, 44}, td.Contains(td.Between(20, 25))) fmt.Println(\"array contains at least one item in [20 .. 25]:\", ok) ok = td.Cmp(t, []int{11, 22, 33, 44}, td.Contains(22)) fmt.Println(\"slice contains 22:\", ok) ok = td.Cmp(t, []int{11, 22, 33, 44}, td.Contains(td.Between(20, 25))) fmt.Println(\"slice contains at least one item in [20 .. 25]:\", ok) ok = td.Cmp(t, []int{11, 22, 33, 44}, td.Contains([]int{22, 33})) fmt.Println(\"slice contains the sub-slice [22, 33]:\", ok) // Output: // array contains 22: true // array contains at least one item in [20 .. 25]: true // slice contains 22: true // slice contains at least one item in [20 .. 25]: true // slice contains the sub-slice [22, 33]: true Nil example t := \u0026testing.T{} num := 123 got := [...]*int{\u0026num, nil} ok := td.Cmp(t, got, td.Contains(nil)) fmt.Println(\"array contains untyped nil:\", ok) ok = td.Cmp(t, got, td.Contains((*int)(nil))) fmt.Println(\"array contains *int nil:\", ok) ok = td.Cmp(t, got, td.Contains(td.Nil())) fmt.Println(\"array contains Nil():\", ok) ok = td.Cmp(t, got, td.Contains((*byte)(nil))) fmt.Println(\"array contains *byte nil:\", ok) // types differ: *byte ≠ *int // Output: // array contains untyped nil: true // array contains *int nil: true // array contains Nil(): true // array contains *byte nil: false Map example t := \u0026testing.T{} ok := td.Cmp(t, map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, td.Contains(22)) fmt.Println(\"map contains value 22:\", ok) ok = td.Cmp(t, map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, td.Contains(td.Between(20, 25))) fmt.Println(\"map contains at least one value in [20 .. 25]:\", ok) // Output: // map contains value 22: true // map contains at least one value in [20 .. 25]: true String example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.Contains(\"oob\"), \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = td.Cmp(t, got, td.Contains([]byte(\"oob\")), \"checks %s\", got) fmt.Println(\"contains `oob` []byte:\", ok) ok = td.Cmp(t, got, td.Contains('b'), \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = td.Cmp(t, got, td.Contains(byte('a')), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = td.Cmp(t, got, td.Contains(td.Between('n', 'p')), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains `oob` []byte: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.Contains(\"oob\"), \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = td.Cmp(t, got, td.Contains('b'), \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = td.Cmp(t, got, td.Contains(byte('a')), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = td.Cmp(t, got, td.Contains(td.Between('n', 'p')), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.Contains(\"oob\"), \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = td.Cmp(t, got, td.Contains('b'), \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = td.Cmp(t, got, td.Contains(byte('a')), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = td.Cmp(t, got, td.Contains(td.Between('n', 'p')), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true CmpContains shortcut func CmpContains(t TestingT, got, expectedValue any, args ...any) bool CmpContains is a shortcut for:\ntd.Cmp(t, got, td.Contains(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpContains godoc.\nExamples ArraySlice example t := \u0026testing.T{} ok := td.CmpContains(t, [...]int{11, 22, 33, 44}, 22) fmt.Println(\"array contains 22:\", ok) ok = td.CmpContains(t, [...]int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\"array contains at least one item in [20 .. 25]:\", ok) ok = td.CmpContains(t, []int{11, 22, 33, 44}, 22) fmt.Println(\"slice contains 22:\", ok) ok = td.CmpContains(t, []int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\"slice contains at least one item in [20 .. 25]:\", ok) ok = td.CmpContains(t, []int{11, 22, 33, 44}, []int{22, 33}) fmt.Println(\"slice contains the sub-slice [22, 33]:\", ok) // Output: // array contains 22: true // array contains at least one item in [20 .. 25]: true // slice contains 22: true // slice contains at least one item in [20 .. 25]: true // slice contains the sub-slice [22, 33]: true Nil example t := \u0026testing.T{} num := 123 got := [...]*int{\u0026num, nil} ok := td.CmpContains(t, got, nil) fmt.Println(\"array contains untyped nil:\", ok) ok = td.CmpContains(t, got, (*int)(nil)) fmt.Println(\"array contains *int nil:\", ok) ok = td.CmpContains(t, got, td.Nil()) fmt.Println(\"array contains Nil():\", ok) ok = td.CmpContains(t, got, (*byte)(nil)) fmt.Println(\"array contains *byte nil:\", ok) // types differ: *byte ≠ *int // Output: // array contains untyped nil: true // array contains *int nil: true // array contains Nil(): true // array contains *byte nil: false Map example t := \u0026testing.T{} ok := td.CmpContains(t, map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, 22) fmt.Println(\"map contains value 22:\", ok) ok = td.CmpContains(t, map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, td.Between(20, 25)) fmt.Println(\"map contains at least one value in [20 .. 25]:\", ok) // Output: // map contains value 22: true // map contains at least one value in [20 .. 25]: true String example t := \u0026testing.T{} got := \"foobar\" ok := td.CmpContains(t, got, \"oob\", \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = td.CmpContains(t, got, []byte(\"oob\"), \"checks %s\", got) fmt.Println(\"contains `oob` []byte:\", ok) ok = td.CmpContains(t, got, 'b', \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = td.CmpContains(t, got, byte('a'), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = td.CmpContains(t, got, td.Between('n', 'p'), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains `oob` []byte: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.CmpContains(t, got, \"oob\", \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = td.CmpContains(t, got, 'b', \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = td.CmpContains(t, got, byte('a'), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = td.CmpContains(t, got, td.Between('n', 'p'), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.CmpContains(t, got, \"oob\", \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = td.CmpContains(t, got, 'b', \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = td.CmpContains(t, got, byte('a'), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = td.CmpContains(t, got, td.Between('n', 'p'), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true T.Contains shortcut func (t *T) Contains(got, expectedValue any, args ...any) bool Contains is a shortcut for:\nt.Cmp(got, td.Contains(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Contains godoc.\nExamples ArraySlice example t := td.NewT(\u0026testing.T{}) ok := t.Contains([...]int{11, 22, 33, 44}, 22) fmt.Println(\"array contains 22:\", ok) ok = t.Contains([...]int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\"array contains at least one item in [20 .. 25]:\", ok) ok = t.Contains([]int{11, 22, 33, 44}, 22) fmt.Println(\"slice contains 22:\", ok) ok = t.Contains([]int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\"slice contains at least one item in [20 .. 25]:\", ok) ok = t.Contains([]int{11, 22, 33, 44}, []int{22, 33}) fmt.Println(\"slice contains the sub-slice [22, 33]:\", ok) // Output: // array contains 22: true // array contains at least one item in [20 .. 25]: true // slice contains 22: true // slice contains at least one item in [20 .. 25]: true // slice contains the sub-slice [22, 33]: true Nil example t := td.NewT(\u0026testing.T{}) num := 123 got := [...]*int{\u0026num, nil} ok := t.Contains(got, nil) fmt.Println(\"array contains untyped nil:\", ok) ok = t.Contains(got, (*int)(nil)) fmt.Println(\"array contains *int nil:\", ok) ok = t.Contains(got, td.Nil()) fmt.Println(\"array contains Nil():\", ok) ok = t.Contains(got, (*byte)(nil)) fmt.Println(\"array contains *byte nil:\", ok) // types differ: *byte ≠ *int // Output: // array contains untyped nil: true // array contains *int nil: true // array contains Nil(): true // array contains *byte nil: false Map example t := td.NewT(\u0026testing.T{}) ok := t.Contains(map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, 22) fmt.Println(\"map contains value 22:\", ok) ok = t.Contains(map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, td.Between(20, 25)) fmt.Println(\"map contains at least one value in [20 .. 25]:\", ok) // Output: // map contains value 22: true // map contains at least one value in [20 .. 25]: true String example t := td.NewT(\u0026testing.T{}) got := \"foobar\" ok := t.Contains(got, \"oob\", \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = t.Contains(got, []byte(\"oob\"), \"checks %s\", got) fmt.Println(\"contains `oob` []byte:\", ok) ok = t.Contains(got, 'b', \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = t.Contains(got, byte('a'), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = t.Contains(got, td.Between('n', 'p'), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains `oob` []byte: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true Stringer example t := td.NewT(\u0026testing.T{}) // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := t.Contains(got, \"oob\", \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = t.Contains(got, 'b', \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = t.Contains(got, byte('a'), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = t.Contains(got, td.Between('n', 'p'), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true Error example t := td.NewT(\u0026testing.T{}) got := errors.New(\"foobar\") ok := t.Contains(got, \"oob\", \"checks %s\", got) fmt.Println(\"contains `oob` string:\", ok) ok = t.Contains(got, 'b', \"checks %s\", got) fmt.Println(\"contains 'b' rune:\", ok) ok = t.Contains(got, byte('a'), \"checks %s\", got) fmt.Println(\"contains 'a' byte:\", ok) ok = t.Contains(got, td.Between('n', 'p'), \"checks %s\", got) fmt.Println(\"contains at least one character ['n' .. 'p']:\", ok) // Output: // contains `oob` string: true // contains 'b' rune: true // contains 'a' byte: true // contains at least one character ['n' .. 'p']: true",
    "description": "func Contains(expectedValue any) TestDeep Contains is a smuggler operator to check if something is contained in another thing. Contains has to be applied on arrays, slices, maps or strings. It tries to be as smarter as possible.\nIf expectedValue is a TestDeep operator, each item of data array/slice/map/string (rune for strings) is compared to it. The use of a TestDeep operator as expectedValue works only in this way: item per item.\nIf data is a slice, and expectedValue has the same type, then expectedValue is searched as a sub-slice, otherwise expectedValue is compared to each slice value.",
    "tags": [],
    "title": "Contains",
    "uri": "/operators/contains/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func ContainsKey(expectedValue any) TestDeep ContainsKey is a smuggler operator and works on maps only. It compares each key of map against expectedValue.\nhash := map[string]int{\"foo\": 12, \"bar\": 34, \"zip\": 28} td.Cmp(t, hash, td.ContainsKey(\"foo\")) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix(\"z\"))) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix(\"x\"))) // fails hnum := map[int]string{1: \"foo\", 42: \"bar\"} td.Cmp(t, hash, td.ContainsKey(42)) // succeeds td.Cmp(t, hash, td.ContainsKey(td.Between(40, 45))) // succeeds When ContainsKey(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the map key type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):\nnum := 123 hnum := map[*int]bool{\u0026num: true, nil: true} td.Cmp(t, hnum, td.ContainsKey(nil)) // succeeds → (*int)(nil) td.Cmp(t, hnum, td.ContainsKey((*int)(nil))) // succeeds td.Cmp(t, hnum, td.ContainsKey(td.Nil())) // succeeds // But... td.Cmp(t, hnum, td.ContainsKey((*byte)(nil))) // fails: (*byte)(nil) ≠ (*int)(nil) See also Contains.\nSee also ContainsKey godoc.\nExamples Base example t := \u0026testing.T{} ok := td.Cmp(t, map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, td.ContainsKey(\"foo\")) fmt.Println(`map contains key \"foo\":`, ok) ok = td.Cmp(t, map[int]bool{12: true, 24: false, 42: true, 51: false}, td.ContainsKey(td.Between(40, 50))) fmt.Println(\"map contains at least a key in [40 .. 50]:\", ok) ok = td.Cmp(t, map[string]int{\"FOO\": 11, \"bar\": 22, \"zip\": 33}, td.ContainsKey(td.Smuggle(strings.ToLower, \"foo\"))) fmt.Println(`map contains key \"foo\" without taking case into account:`, ok) // Output: // map contains key \"foo\": true // map contains at least a key in [40 .. 50]: true // map contains key \"foo\" without taking case into account: true Nil example t := \u0026testing.T{} num := 1234 got := map[*int]bool{\u0026num: false, nil: true} ok := td.Cmp(t, got, td.ContainsKey(nil)) fmt.Println(\"map contains untyped nil key:\", ok) ok = td.Cmp(t, got, td.ContainsKey((*int)(nil))) fmt.Println(\"map contains *int nil key:\", ok) ok = td.Cmp(t, got, td.ContainsKey(td.Nil())) fmt.Println(\"map contains Nil() key:\", ok) ok = td.Cmp(t, got, td.ContainsKey((*byte)(nil))) fmt.Println(\"map contains *byte nil key:\", ok) // types differ: *byte ≠ *int // Output: // map contains untyped nil key: true // map contains *int nil key: true // map contains Nil() key: true // map contains *byte nil key: false CmpContainsKey shortcut func CmpContainsKey(t TestingT, got, expectedValue any, args ...any) bool CmpContainsKey is a shortcut for:\ntd.Cmp(t, got, td.ContainsKey(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpContainsKey godoc.\nExamples Base example t := \u0026testing.T{} ok := td.CmpContainsKey(t, map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, \"foo\") fmt.Println(`map contains key \"foo\":`, ok) ok = td.CmpContainsKey(t, map[int]bool{12: true, 24: false, 42: true, 51: false}, td.Between(40, 50)) fmt.Println(\"map contains at least a key in [40 .. 50]:\", ok) ok = td.CmpContainsKey(t, map[string]int{\"FOO\": 11, \"bar\": 22, \"zip\": 33}, td.Smuggle(strings.ToLower, \"foo\")) fmt.Println(`map contains key \"foo\" without taking case into account:`, ok) // Output: // map contains key \"foo\": true // map contains at least a key in [40 .. 50]: true // map contains key \"foo\" without taking case into account: true Nil example t := \u0026testing.T{} num := 1234 got := map[*int]bool{\u0026num: false, nil: true} ok := td.CmpContainsKey(t, got, nil) fmt.Println(\"map contains untyped nil key:\", ok) ok = td.CmpContainsKey(t, got, (*int)(nil)) fmt.Println(\"map contains *int nil key:\", ok) ok = td.CmpContainsKey(t, got, td.Nil()) fmt.Println(\"map contains Nil() key:\", ok) ok = td.CmpContainsKey(t, got, (*byte)(nil)) fmt.Println(\"map contains *byte nil key:\", ok) // types differ: *byte ≠ *int // Output: // map contains untyped nil key: true // map contains *int nil key: true // map contains Nil() key: true // map contains *byte nil key: false T.ContainsKey shortcut func (t *T) ContainsKey(got, expectedValue any, args ...any) bool ContainsKey is a shortcut for:\nt.Cmp(got, td.ContainsKey(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.ContainsKey godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) ok := t.ContainsKey(map[string]int{\"foo\": 11, \"bar\": 22, \"zip\": 33}, \"foo\") fmt.Println(`map contains key \"foo\":`, ok) ok = t.ContainsKey(map[int]bool{12: true, 24: false, 42: true, 51: false}, td.Between(40, 50)) fmt.Println(\"map contains at least a key in [40 .. 50]:\", ok) ok = t.ContainsKey(map[string]int{\"FOO\": 11, \"bar\": 22, \"zip\": 33}, td.Smuggle(strings.ToLower, \"foo\")) fmt.Println(`map contains key \"foo\" without taking case into account:`, ok) // Output: // map contains key \"foo\": true // map contains at least a key in [40 .. 50]: true // map contains key \"foo\" without taking case into account: true Nil example t := td.NewT(\u0026testing.T{}) num := 1234 got := map[*int]bool{\u0026num: false, nil: true} ok := t.ContainsKey(got, nil) fmt.Println(\"map contains untyped nil key:\", ok) ok = t.ContainsKey(got, (*int)(nil)) fmt.Println(\"map contains *int nil key:\", ok) ok = t.ContainsKey(got, td.Nil()) fmt.Println(\"map contains Nil() key:\", ok) ok = t.ContainsKey(got, (*byte)(nil)) fmt.Println(\"map contains *byte nil key:\", ok) // types differ: *byte ≠ *int // Output: // map contains untyped nil key: true // map contains *int nil key: true // map contains Nil() key: true // map contains *byte nil key: false",
    "description": "func ContainsKey(expectedValue any) TestDeep ContainsKey is a smuggler operator and works on maps only. It compares each key of map against expectedValue.\nhash := map[string]int{\"foo\": 12, \"bar\": 34, \"zip\": 28} td.Cmp(t, hash, td.ContainsKey(\"foo\")) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix(\"z\"))) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix(\"x\"))) // fails hnum := map[int]string{1: \"foo\", 42: \"bar\"} td.Cmp(t, hash, td.ContainsKey(42)) // succeeds td.Cmp(t, hash, td.ContainsKey(td.Between(40, 45))) // succeeds When ContainsKey(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the map key type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):",
    "tags": [],
    "title": "ContainsKey",
    "uri": "/operators/containskey/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Delay(delayed func() TestDeep) TestDeep Delay operator allows to delay the construction of an operator to the time it is used for the first time. Most of the time, it is used with helpers. See the example for a very simple use case.\nSee also Delay godoc.\nExample Base example t := \u0026testing.T{} cmpNow := func(expected td.TestDeep) bool { time.Sleep(time.Microsecond) // imagine a DB insert returning a CreatedAt return td.Cmp(t, time.Now(), expected) } before := time.Now() ok := cmpNow(td.Between(before, time.Now())) fmt.Println(\"Between called before compare:\", ok) ok = cmpNow(td.Delay(func() td.TestDeep { return td.Between(before, time.Now()) })) fmt.Println(\"Between delayed until compare:\", ok) // Output: // Between called before compare: false // Between delayed until compare: true",
    "description": "func Delay(delayed func() TestDeep) TestDeep Delay operator allows to delay the construction of an operator to the time it is used for the first time. Most of the time, it is used with helpers. See the example for a very simple use case.\nSee also Delay godoc.\nExample Base example t := \u0026testing.T{} cmpNow := func(expected td.TestDeep) bool { time.Sleep(time.Microsecond) // imagine a DB insert returning a CreatedAt return td.Cmp(t, time.Now(), expected) } before := time.Now() ok := cmpNow(td.Between(before, time.Now())) fmt.Println(\"Between called before compare:\", ok) ok = cmpNow(td.Delay(func() td.TestDeep { return td.Between(before, time.Now()) })) fmt.Println(\"Between delayed until compare:\", ok) // Output: // Between called before compare: false // Between delayed until compare: true",
    "tags": [],
    "title": "Delay",
    "uri": "/operators/delay/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Empty() TestDeep Empty operator checks that an array, a channel, a map, a slice or a string is empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\ntd.Cmp(t, \"\", td.Empty()) // succeeds td.Cmp(t, map[string]bool{}, td.Empty()) // succeeds td.Cmp(t, []string{\"foo\"}, td.Empty()) // fails See also Empty godoc.\nExamples Base example t := \u0026testing.T{} ok := td.Cmp(t, nil, td.Empty()) // special case: nil is considered empty fmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or // pointers on array, channel, map slice and strings) ok = td.Cmp(t, (*int)(nil), td.Empty()) fmt.Println(ok) ok = td.Cmp(t, \"\", td.Empty()) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead ok = td.Cmp(t, 0, td.Empty()) fmt.Println(ok) ok = td.Cmp(t, (map[string]int)(nil), td.Empty()) fmt.Println(ok) ok = td.Cmp(t, map[string]int{}, td.Empty()) fmt.Println(ok) ok = td.Cmp(t, ([]int)(nil), td.Empty()) fmt.Println(ok) ok = td.Cmp(t, []int{}, td.Empty()) fmt.Println(ok) ok = td.Cmp(t, []int{3}, td.Empty()) // fails, as not empty fmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.Empty()) // fails, Empty() is not Zero()! fmt.Println(ok) // Output: // true // false // true // false // true // true // true // true // false // false Pointers example t := \u0026testing.T{} type MySlice []int ok := td.Cmp(t, MySlice{}, td.Empty()) // Ptr() not needed fmt.Println(ok) ok = td.Cmp(t, \u0026MySlice{}, td.Empty()) fmt.Println(ok) l1 := \u0026MySlice{} l2 := \u0026l1 l3 := \u0026l2 ok = td.Cmp(t, \u0026l3, td.Empty()) fmt.Println(ok) // Works the same for array, map, channel and string // But not for others types as: type MyStruct struct { Value int } ok = td.Cmp(t, \u0026MyStruct{}, td.Empty()) // fails, use Zero() instead fmt.Println(ok) // Output: // true // true // true // false CmpEmpty shortcut func CmpEmpty(t TestingT, got any, args ...any) bool CmpEmpty is a shortcut for:\ntd.Cmp(t, got, td.Empty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpEmpty godoc.\nExamples Base example t := \u0026testing.T{} ok := td.CmpEmpty(t, nil) // special case: nil is considered empty fmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or // pointers on array, channel, map slice and strings) ok = td.CmpEmpty(t, (*int)(nil)) fmt.Println(ok) ok = td.CmpEmpty(t, \"\") fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead ok = td.CmpEmpty(t, 0) fmt.Println(ok) ok = td.CmpEmpty(t, (map[string]int)(nil)) fmt.Println(ok) ok = td.CmpEmpty(t, map[string]int{}) fmt.Println(ok) ok = td.CmpEmpty(t, ([]int)(nil)) fmt.Println(ok) ok = td.CmpEmpty(t, []int{}) fmt.Println(ok) ok = td.CmpEmpty(t, []int{3}) // fails, as not empty fmt.Println(ok) ok = td.CmpEmpty(t, [3]int{}) // fails, Empty() is not Zero()! fmt.Println(ok) // Output: // true // false // true // false // true // true // true // true // false // false Pointers example t := \u0026testing.T{} type MySlice []int ok := td.CmpEmpty(t, MySlice{}) // Ptr() not needed fmt.Println(ok) ok = td.CmpEmpty(t, \u0026MySlice{}) fmt.Println(ok) l1 := \u0026MySlice{} l2 := \u0026l1 l3 := \u0026l2 ok = td.CmpEmpty(t, \u0026l3) fmt.Println(ok) // Works the same for array, map, channel and string // But not for others types as: type MyStruct struct { Value int } ok = td.CmpEmpty(t, \u0026MyStruct{}) // fails, use Zero() instead fmt.Println(ok) // Output: // true // true // true // false T.Empty shortcut func (t *T) Empty(got any, args ...any) bool Empty is a shortcut for:\nt.Cmp(got, td.Empty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Empty godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) ok := t.Empty(nil) // special case: nil is considered empty fmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or // pointers on array, channel, map slice and strings) ok = t.Empty((*int)(nil)) fmt.Println(ok) ok = t.Empty(\"\") fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead ok = t.Empty(0) fmt.Println(ok) ok = t.Empty((map[string]int)(nil)) fmt.Println(ok) ok = t.Empty(map[string]int{}) fmt.Println(ok) ok = t.Empty(([]int)(nil)) fmt.Println(ok) ok = t.Empty([]int{}) fmt.Println(ok) ok = t.Empty([]int{3}) // fails, as not empty fmt.Println(ok) ok = t.Empty([3]int{}) // fails, Empty() is not Zero()! fmt.Println(ok) // Output: // true // false // true // false // true // true // true // true // false // false Pointers example t := td.NewT(\u0026testing.T{}) type MySlice []int ok := t.Empty(MySlice{}) // Ptr() not needed fmt.Println(ok) ok = t.Empty(\u0026MySlice{}) fmt.Println(ok) l1 := \u0026MySlice{} l2 := \u0026l1 l3 := \u0026l2 ok = t.Empty(\u0026l3) fmt.Println(ok) // Works the same for array, map, channel and string // But not for others types as: type MyStruct struct { Value int } ok = t.Empty(\u0026MyStruct{}) // fails, use Zero() instead fmt.Println(ok) // Output: // true // true // true // false",
    "description": "func Empty() TestDeep Empty operator checks that an array, a channel, a map, a slice or a string is empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\ntd.Cmp(t, \"\", td.Empty()) // succeeds td.Cmp(t, map[string]bool{}, td.Empty()) // succeeds td.Cmp(t, []string{\"foo\"}, td.Empty()) // fails See also Empty godoc.",
    "tags": [],
    "title": "Empty",
    "uri": "/operators/empty/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func ErrorIs(expectedError any) TestDeep ErrorIs is a smuggler operator. It reports whether any error in an error’s chain matches expectedError.\n_, err := os.Open(\"/unknown/file\") td.Cmp(t, err, os.ErrNotExist) // fails td.Cmp(t, err, td.ErrorIs(os.ErrNotExist)) // succeeds err1 := fmt.Errorf(\"failure1\") err2 := fmt.Errorf(\"failure2: %w\", err1) err3 := fmt.Errorf(\"failure3: %w\", err2) err := fmt.Errorf(\"failure4: %w\", err3) td.Cmp(t, err, td.ErrorIs(err)) // succeeds td.Cmp(t, err, td.ErrorIs(err1)) // succeeds td.Cmp(t, err1, td.ErrorIs(err)) // fails var cerr myError td.Cmp(t, err, td.ErrorIs(td.Catch(\u0026cerr, td.String(\"my error...\")))) td.Cmp(t, err, td.ErrorIs(td.All( td.Isa(myError{}), td.String(\"my error...\"), ))) Behind the scene it uses errors.Is function if expectedError is an error and errors.As function if expectedError is a TestDeep operator.\nNote that like errors.Is, expectedError can be nil: in this case the comparison succeeds only when got is nil too.\nSee also CmpError and CmpNoError.\nSee also ErrorIs godoc.\nExample Base example t := \u0026testing.T{} err1 := fmt.Errorf(\"failure1\") err2 := fmt.Errorf(\"failure2: %w\", err1) err3 := fmt.Errorf(\"failure3: %w\", err2) err := fmt.Errorf(\"failure4: %w\", err3) ok := td.Cmp(t, err, td.ErrorIs(err)) fmt.Println(\"error is itself:\", ok) ok = td.Cmp(t, err, td.ErrorIs(err1)) fmt.Println(\"error is also err1:\", ok) ok = td.Cmp(t, err1, td.ErrorIs(err)) fmt.Println(\"err1 is err:\", ok) // Output: // error is itself: true // error is also err1: true // err1 is err: false CmpErrorIs shortcut func CmpErrorIs(t TestingT, got, expectedError any, args ...any) bool CmpErrorIs is a shortcut for:\ntd.Cmp(t, got, td.ErrorIs(expectedError), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpErrorIs godoc.\nExample Base example t := \u0026testing.T{} err1 := fmt.Errorf(\"failure1\") err2 := fmt.Errorf(\"failure2: %w\", err1) err3 := fmt.Errorf(\"failure3: %w\", err2) err := fmt.Errorf(\"failure4: %w\", err3) ok := td.CmpErrorIs(t, err, err) fmt.Println(\"error is itself:\", ok) ok = td.CmpErrorIs(t, err, err1) fmt.Println(\"error is also err1:\", ok) ok = td.CmpErrorIs(t, err1, err) fmt.Println(\"err1 is err:\", ok) // Output: // error is itself: true // error is also err1: true // err1 is err: false T.CmpErrorIs shortcut func (t *T) CmpErrorIs(got, expectedError any, args ...any) bool CmpErrorIs is a shortcut for:\nt.Cmp(got, td.ErrorIs(expectedError), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.CmpErrorIs godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) err1 := fmt.Errorf(\"failure1\") err2 := fmt.Errorf(\"failure2: %w\", err1) err3 := fmt.Errorf(\"failure3: %w\", err2) err := fmt.Errorf(\"failure4: %w\", err3) ok := t.CmpErrorIs(err, err) fmt.Println(\"error is itself:\", ok) ok = t.CmpErrorIs(err, err1) fmt.Println(\"error is also err1:\", ok) ok = t.CmpErrorIs(err1, err) fmt.Println(\"err1 is err:\", ok) // Output: // error is itself: true // error is also err1: true // err1 is err: false",
    "description": "func ErrorIs(expectedError any) TestDeep ErrorIs is a smuggler operator. It reports whether any error in an error’s chain matches expectedError.\n_, err := os.Open(\"/unknown/file\") td.Cmp(t, err, os.ErrNotExist) // fails td.Cmp(t, err, td.ErrorIs(os.ErrNotExist)) // succeeds err1 := fmt.Errorf(\"failure1\") err2 := fmt.Errorf(\"failure2: %w\", err1) err3 := fmt.Errorf(\"failure3: %w\", err2) err := fmt.Errorf(\"failure4: %w\", err3) td.Cmp(t, err, td.ErrorIs(err)) // succeeds td.Cmp(t, err, td.ErrorIs(err1)) // succeeds td.Cmp(t, err1, td.ErrorIs(err)) // fails var cerr myError td.Cmp(t, err, td.ErrorIs(td.Catch(\u0026cerr, td.String(\"my error...\")))) td.Cmp(t, err, td.ErrorIs(td.All( td.Isa(myError{}), td.String(\"my error...\"), ))) Behind the scene it uses errors.Is function if expectedError is an error and errors.As function if expectedError is a TestDeep operator.\nNote that like errors.Is, expectedError can be nil: in this case the comparison succeeds only when got is nil too.",
    "tags": [],
    "title": "ErrorIs",
    "uri": "/operators/erroris/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func First(filter, expectedValue any) TestDeep First is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool. It takes the first item for which the filter matched and compares it to expectedValue. The filter matches when it is a:\nTestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can of course be a TestDeep operator.\ngot := []int{-3, -2, -1, 0, 1, 2, 3} td.Cmp(t, got, td.First(td.Gt(0), 1)) // succeeds td.Cmp(t, got, td.First(func(x int) bool { return x%2 == 0 }, -2)) // succeeds td.Cmp(t, got, td.First(func(x int) bool { return x%2 == 0 }, td.Lt(0))) // succeeds If the input is empty (and/or nil for a slice), an “item not found” error is raised before comparing to expectedValue.\nvar got []int td.Cmp(t, got, td.First(td.Gt(0), td.Gt(0))) // fails td.Cmp(t, []int{}, td.First(td.Gt(0), td.Gt(0))) // fails td.Cmp(t, [0]int{}, td.First(td.Gt(0), td.Gt(0))) // fails See also Last and Grep.\nSee also First godoc.\nExamples Classic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.Cmp(t, got, td.First(td.Gt(0), 1)) fmt.Println(\"first positive number is 1:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = td.Cmp(t, got, td.First(isEven, -2)) fmt.Println(\"first even number is -2:\", ok) ok = td.Cmp(t, got, td.First(isEven, td.Lt(0))) fmt.Println(\"first even number is \u003c 0:\", ok) ok = td.Cmp(t, got, td.First(isEven, td.Code(isEven))) fmt.Println(\"first even number is well even:\", ok) // Output: // first positive number is 1: true // first even number is -2: true // first even number is \u003c 0: true // first even number is well even: true Empty example t := \u0026testing.T{} ok := td.Cmp(t, ([]int)(nil), td.First(td.Gt(0), td.Gt(0))) fmt.Println(\"first in nil slice:\", ok) ok = td.Cmp(t, []int{}, td.First(td.Gt(0), td.Gt(0))) fmt.Println(\"first in empty slice:\", ok) ok = td.Cmp(t, \u0026[]int{}, td.First(td.Gt(0), td.Gt(0))) fmt.Println(\"first in empty pointed slice:\", ok) ok = td.Cmp(t, [0]int{}, td.First(td.Gt(0), td.Gt(0))) fmt.Println(\"first in empty array:\", ok) // Output: // first in nil slice: false // first in empty slice: false // first in empty pointed slice: false // first in empty array: false Struct example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 37, }, } ok := td.Cmp(t, got, td.First( td.Smuggle(\"Age\", td.Gt(30)), td.Smuggle(\"Fullname\", \"Bob Foobar\"))) fmt.Println(\"first person.Age \u003e 30 → Bob:\", ok) ok = td.Cmp(t, got, td.First( td.JSONPointer(\"/age\", td.Gt(30)), td.SuperJSONOf(`{\"fullname\":\"Bob Foobar\"}`))) fmt.Println(\"first person.Age \u003e 30 → Bob, using JSON:\", ok) ok = td.Cmp(t, got, td.First( td.JSONPointer(\"/age\", td.Gt(30)), td.JSONPointer(\"/fullname\", td.HasPrefix(\"Bob\")))) fmt.Println(\"first person.Age \u003e 30 → Bob, using JSONPointer:\", ok) // Output: // first person.Age \u003e 30 → Bob: true // first person.Age \u003e 30 → Bob, using JSON: true // first person.Age \u003e 30 → Bob, using JSONPointer: true Json example t := \u0026testing.T{} got := map[string]any{ \"values\": []int{1, 2, 3, 4}, } ok := td.Cmp(t, got, td.JSON(`{\"values\": First(Gt(2), 3)}`)) fmt.Println(\"first number \u003e 2:\", ok) got = map[string]any{ \"persons\": []map[string]any{ {\"id\": 1, \"name\": \"Joe\"}, {\"id\": 2, \"name\": \"Bob\"}, {\"id\": 3, \"name\": \"Alice\"}, {\"id\": 4, \"name\": \"Brian\"}, {\"id\": 5, \"name\": \"Britt\"}, }, } ok = td.Cmp(t, got, td.JSON(` { \"persons\": First(JSONPointer(\"/name\", \"Brian\"), {\"id\": 4, \"name\": \"Brian\"}) }`)) fmt.Println(`is \"Brian\" content OK:`, ok) ok = td.Cmp(t, got, td.JSON(` { \"persons\": First(JSONPointer(\"/name\", \"Brian\"), JSONPointer(\"/id\", 4)) }`)) fmt.Println(`ID of \"Brian\" is 4:`, ok) // Output: // first number \u003e 2: true // is \"Brian\" content OK: true // ID of \"Brian\" is 4: true CmpFirst shortcut func CmpFirst(t TestingT, got, filter , expectedValue any, args ...any) bool CmpFirst is a shortcut for:\ntd.Cmp(t, got, td.First(filter, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpFirst godoc.\nExamples Classic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.CmpFirst(t, got, td.Gt(0), 1) fmt.Println(\"first positive number is 1:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = td.CmpFirst(t, got, isEven, -2) fmt.Println(\"first even number is -2:\", ok) ok = td.CmpFirst(t, got, isEven, td.Lt(0)) fmt.Println(\"first even number is \u003c 0:\", ok) ok = td.CmpFirst(t, got, isEven, td.Code(isEven)) fmt.Println(\"first even number is well even:\", ok) // Output: // first positive number is 1: true // first even number is -2: true // first even number is \u003c 0: true // first even number is well even: true Empty example t := \u0026testing.T{} ok := td.CmpFirst(t, ([]int)(nil), td.Gt(0), td.Gt(0)) fmt.Println(\"first in nil slice:\", ok) ok = td.CmpFirst(t, []int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"first in empty slice:\", ok) ok = td.CmpFirst(t, \u0026[]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"first in empty pointed slice:\", ok) ok = td.CmpFirst(t, [0]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"first in empty array:\", ok) // Output: // first in nil slice: false // first in empty slice: false // first in empty pointed slice: false // first in empty array: false Struct example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 37, }, } ok := td.CmpFirst(t, got, td.Smuggle(\"Age\", td.Gt(30)), td.Smuggle(\"Fullname\", \"Bob Foobar\")) fmt.Println(\"first person.Age \u003e 30 → Bob:\", ok) ok = td.CmpFirst(t, got, td.JSONPointer(\"/age\", td.Gt(30)), td.SuperJSONOf(`{\"fullname\":\"Bob Foobar\"}`)) fmt.Println(\"first person.Age \u003e 30 → Bob, using JSON:\", ok) ok = td.CmpFirst(t, got, td.JSONPointer(\"/age\", td.Gt(30)), td.JSONPointer(\"/fullname\", td.HasPrefix(\"Bob\"))) fmt.Println(\"first person.Age \u003e 30 → Bob, using JSONPointer:\", ok) // Output: // first person.Age \u003e 30 → Bob: true // first person.Age \u003e 30 → Bob, using JSON: true // first person.Age \u003e 30 → Bob, using JSONPointer: true T.First shortcut func (t *T) First(got, filter , expectedValue any, args ...any) bool First is a shortcut for:\nt.Cmp(got, td.First(filter, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.First godoc.\nExamples Classic example t := td.NewT(\u0026testing.T{}) got := []int{-3, -2, -1, 0, 1, 2, 3} ok := t.First(got, td.Gt(0), 1) fmt.Println(\"first positive number is 1:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = t.First(got, isEven, -2) fmt.Println(\"first even number is -2:\", ok) ok = t.First(got, isEven, td.Lt(0)) fmt.Println(\"first even number is \u003c 0:\", ok) ok = t.First(got, isEven, td.Code(isEven)) fmt.Println(\"first even number is well even:\", ok) // Output: // first positive number is 1: true // first even number is -2: true // first even number is \u003c 0: true // first even number is well even: true Empty example t := td.NewT(\u0026testing.T{}) ok := t.First(([]int)(nil), td.Gt(0), td.Gt(0)) fmt.Println(\"first in nil slice:\", ok) ok = t.First([]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"first in empty slice:\", ok) ok = t.First(\u0026[]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"first in empty pointed slice:\", ok) ok = t.First([0]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"first in empty array:\", ok) // Output: // first in nil slice: false // first in empty slice: false // first in empty pointed slice: false // first in empty array: false Struct example t := td.NewT(\u0026testing.T{}) type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 37, }, } ok := t.First(got, td.Smuggle(\"Age\", td.Gt(30)), td.Smuggle(\"Fullname\", \"Bob Foobar\")) fmt.Println(\"first person.Age \u003e 30 → Bob:\", ok) ok = t.First(got, td.JSONPointer(\"/age\", td.Gt(30)), td.SuperJSONOf(`{\"fullname\":\"Bob Foobar\"}`)) fmt.Println(\"first person.Age \u003e 30 → Bob, using JSON:\", ok) ok = t.First(got, td.JSONPointer(\"/age\", td.Gt(30)), td.JSONPointer(\"/fullname\", td.HasPrefix(\"Bob\"))) fmt.Println(\"first person.Age \u003e 30 → Bob, using JSONPointer:\", ok) // Output: // first person.Age \u003e 30 → Bob: true // first person.Age \u003e 30 → Bob, using JSON: true // first person.Age \u003e 30 → Bob, using JSONPointer: true",
    "description": "func First(filter, expectedValue any) TestDeep First is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool. It takes the first item for which the filter matched and compares it to expectedValue. The filter matches when it is a:\nTestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can of course be a TestDeep operator.",
    "tags": [],
    "title": "First",
    "uri": "/operators/first/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Grep(filter, expectedValue any) TestDeep Grep is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool, and produces a slice consisting of those items for which the filter matched and compares it to expectedValue. The filter matches when it is a:\nTestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can be a TestDeep operator or a slice (but never an array nor a pointer on a slice/array nor any other kind).\ngot := []int{-3, -2, -1, 0, 1, 2, 3} td.Cmp(t, got, td.Grep(td.Gt(0), []int{1, 2, 3})) // succeeds td.Cmp(t, got, td.Grep( func(x int) bool { return x%2 == 0 }, []int{-2, 0, 2})) // succeeds td.Cmp(t, got, td.Grep( func(x int) bool { return x%2 == 0 }, td.Set(0, 2, -2))) // succeeds If Grep receives a nil slice or a pointer on a nil slice, it always returns a nil slice:\nvar got []int td.Cmp(t, got, td.Grep(td.Gt(0), ([]int)(nil))) // succeeds td.Cmp(t, got, td.Grep(td.Gt(0), td.Nil())) // succeeds td.Cmp(t, got, td.Grep(td.Gt(0), []int{})) // fails See also First, Last and Flatten.\nSee also Grep godoc.\nExamples Classic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.Cmp(t, got, td.Grep(td.Gt(0), []int{1, 2, 3})) fmt.Println(\"check positive numbers:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = td.Cmp(t, got, td.Grep(isEven, []int{-2, 0, 2})) fmt.Println(\"even numbers are -2, 0 and 2:\", ok) ok = td.Cmp(t, got, td.Grep(isEven, td.Set(0, 2, -2))) fmt.Println(\"even numbers are also 0, 2 and -2:\", ok) ok = td.Cmp(t, got, td.Grep(isEven, td.ArrayEach(td.Code(isEven)))) fmt.Println(\"even numbers are each even:\", ok) // Output: // check positive numbers: true // even numbers are -2, 0 and 2: true // even numbers are also 0, 2 and -2: true // even numbers are each even: true Nil example t := \u0026testing.T{} var got []int ok := td.Cmp(t, got, td.Grep(td.Gt(0), ([]int)(nil))) fmt.Println(\"typed []int nil:\", ok) ok = td.Cmp(t, got, td.Grep(td.Gt(0), ([]string)(nil))) fmt.Println(\"typed []string nil:\", ok) ok = td.Cmp(t, got, td.Grep(td.Gt(0), td.Nil())) fmt.Println(\"td.Nil:\", ok) ok = td.Cmp(t, got, td.Grep(td.Gt(0), []int{})) fmt.Println(\"empty non-nil slice:\", ok) // Output: // typed []int nil: true // typed []string nil: false // td.Nil: true // empty non-nil slice: false Struct example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 27, }, } ok := td.Cmp(t, got, td.Grep( td.Smuggle(\"Age\", td.Gt(30)), td.All( td.Len(1), td.ArrayEach(td.Smuggle(\"Fullname\", \"Bob Foobar\")), ))) fmt.Println(\"person.Age \u003e 30 → only Bob:\", ok) ok = td.Cmp(t, got, td.Grep( td.JSONPointer(\"/age\", td.Gt(30)), td.JSON(`[ SuperMapOf({\"fullname\":\"Bob Foobar\"}) ]`))) fmt.Println(\"person.Age \u003e 30 → only Bob, using JSON:\", ok) // Output: // person.Age \u003e 30 → only Bob: true // person.Age \u003e 30 → only Bob, using JSON: true Json example t := \u0026testing.T{} got := map[string]any{ \"values\": []int{1, 2, 3, 4}, } ok := td.Cmp(t, got, td.JSON(`{\"values\": Grep(Gt(2), [3, 4])}`)) fmt.Println(\"grep a number \u003e 2:\", ok) got = map[string]any{ \"persons\": []map[string]any{ {\"id\": 1, \"name\": \"Joe\"}, {\"id\": 2, \"name\": \"Bob\"}, {\"id\": 3, \"name\": \"Alice\"}, {\"id\": 4, \"name\": \"Brian\"}, {\"id\": 5, \"name\": \"Britt\"}, }, } ok = td.Cmp(t, got, td.JSON(` { \"persons\": Grep(JSONPointer(\"/name\", HasPrefix(\"Br\")), [ {\"id\": 4, \"name\": \"Brian\"}, {\"id\": 5, \"name\": \"Britt\"}, ]) }`)) fmt.Println(`grep \"Br\" prefix:`, ok) // Output: // grep a number \u003e 2: true // grep \"Br\" prefix: true CmpGrep shortcut func CmpGrep(t TestingT, got, filter , expectedValue any, args ...any) bool CmpGrep is a shortcut for:\ntd.Cmp(t, got, td.Grep(filter, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpGrep godoc.\nExamples Classic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.CmpGrep(t, got, td.Gt(0), []int{1, 2, 3}) fmt.Println(\"check positive numbers:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = td.CmpGrep(t, got, isEven, []int{-2, 0, 2}) fmt.Println(\"even numbers are -2, 0 and 2:\", ok) ok = td.CmpGrep(t, got, isEven, td.Set(0, 2, -2)) fmt.Println(\"even numbers are also 0, 2 and -2:\", ok) ok = td.CmpGrep(t, got, isEven, td.ArrayEach(td.Code(isEven))) fmt.Println(\"even numbers are each even:\", ok) // Output: // check positive numbers: true // even numbers are -2, 0 and 2: true // even numbers are also 0, 2 and -2: true // even numbers are each even: true Nil example t := \u0026testing.T{} var got []int ok := td.CmpGrep(t, got, td.Gt(0), ([]int)(nil)) fmt.Println(\"typed []int nil:\", ok) ok = td.CmpGrep(t, got, td.Gt(0), ([]string)(nil)) fmt.Println(\"typed []string nil:\", ok) ok = td.CmpGrep(t, got, td.Gt(0), td.Nil()) fmt.Println(\"td.Nil:\", ok) ok = td.CmpGrep(t, got, td.Gt(0), []int{}) fmt.Println(\"empty non-nil slice:\", ok) // Output: // typed []int nil: true // typed []string nil: false // td.Nil: true // empty non-nil slice: false Struct example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 27, }, } ok := td.CmpGrep(t, got, td.Smuggle(\"Age\", td.Gt(30)), td.All( td.Len(1), td.ArrayEach(td.Smuggle(\"Fullname\", \"Bob Foobar\")), )) fmt.Println(\"person.Age \u003e 30 → only Bob:\", ok) ok = td.CmpGrep(t, got, td.JSONPointer(\"/age\", td.Gt(30)), td.JSON(`[ SuperMapOf({\"fullname\":\"Bob Foobar\"}) ]`)) fmt.Println(\"person.Age \u003e 30 → only Bob, using JSON:\", ok) // Output: // person.Age \u003e 30 → only Bob: true // person.Age \u003e 30 → only Bob, using JSON: true T.Grep shortcut func (t *T) Grep(got, filter , expectedValue any, args ...any) bool Grep is a shortcut for:\nt.Cmp(got, td.Grep(filter, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Grep godoc.\nExamples Classic example t := td.NewT(\u0026testing.T{}) got := []int{-3, -2, -1, 0, 1, 2, 3} ok := t.Grep(got, td.Gt(0), []int{1, 2, 3}) fmt.Println(\"check positive numbers:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = t.Grep(got, isEven, []int{-2, 0, 2}) fmt.Println(\"even numbers are -2, 0 and 2:\", ok) ok = t.Grep(got, isEven, td.Set(0, 2, -2)) fmt.Println(\"even numbers are also 0, 2 and -2:\", ok) ok = t.Grep(got, isEven, td.ArrayEach(td.Code(isEven))) fmt.Println(\"even numbers are each even:\", ok) // Output: // check positive numbers: true // even numbers are -2, 0 and 2: true // even numbers are also 0, 2 and -2: true // even numbers are each even: true Nil example t := td.NewT(\u0026testing.T{}) var got []int ok := t.Grep(got, td.Gt(0), ([]int)(nil)) fmt.Println(\"typed []int nil:\", ok) ok = t.Grep(got, td.Gt(0), ([]string)(nil)) fmt.Println(\"typed []string nil:\", ok) ok = t.Grep(got, td.Gt(0), td.Nil()) fmt.Println(\"td.Nil:\", ok) ok = t.Grep(got, td.Gt(0), []int{}) fmt.Println(\"empty non-nil slice:\", ok) // Output: // typed []int nil: true // typed []string nil: false // td.Nil: true // empty non-nil slice: false Struct example t := td.NewT(\u0026testing.T{}) type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 27, }, } ok := t.Grep(got, td.Smuggle(\"Age\", td.Gt(30)), td.All( td.Len(1), td.ArrayEach(td.Smuggle(\"Fullname\", \"Bob Foobar\")), )) fmt.Println(\"person.Age \u003e 30 → only Bob:\", ok) ok = t.Grep(got, td.JSONPointer(\"/age\", td.Gt(30)), td.JSON(`[ SuperMapOf({\"fullname\":\"Bob Foobar\"}) ]`)) fmt.Println(\"person.Age \u003e 30 → only Bob, using JSON:\", ok) // Output: // person.Age \u003e 30 → only Bob: true // person.Age \u003e 30 → only Bob, using JSON: true",
    "description": "func Grep(filter, expectedValue any) TestDeep Grep is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool, and produces a slice consisting of those items for which the filter matched and compares it to expectedValue. The filter matches when it is a:\nTestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can be a TestDeep operator or a slice (but never an array nor a pointer on a slice/array nor any other kind).",
    "tags": [],
    "title": "Grep",
    "uri": "/operators/grep/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Gt(minExpectedValue any) TestDeep Gt operator checks that data is greater than minExpectedValue. minExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b minExpectedValue must be the same type as the compared value, except if BeLax config flag is true.\ntd.Cmp(t, 17, td.Gt(15)) before := time.Now() td.Cmp(t, time.Now(), td.Gt(before)) TypeBehind method returns the reflect.Type of minExpectedValue.\nSee also Gt godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.Cmp(t, got, td.Gt(155), \"checks %v is \u003e 155\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gt(156), \"checks %v is \u003e 156\", got) fmt.Println(ok) // Output: // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.Cmp(t, got, td.Gt(\"abb\"), `checks \"%v\" is \u003e \"abb\"`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gt(\"abc\"), `checks \"%v\" is \u003e \"abc\"`, got) fmt.Println(ok) // Output: // true // false CmpGt shortcut func CmpGt(t TestingT, got, minExpectedValue any, args ...any) bool CmpGt is a shortcut for:\ntd.Cmp(t, got, td.Gt(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpGt godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.CmpGt(t, got, 155, \"checks %v is \u003e 155\", got) fmt.Println(ok) ok = td.CmpGt(t, got, 156, \"checks %v is \u003e 156\", got) fmt.Println(ok) // Output: // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.CmpGt(t, got, \"abb\", `checks \"%v\" is \u003e \"abb\"`, got) fmt.Println(ok) ok = td.CmpGt(t, got, \"abc\", `checks \"%v\" is \u003e \"abc\"`, got) fmt.Println(ok) // Output: // true // false T.Gt shortcut func (t *T) Gt(got, minExpectedValue any, args ...any) bool Gt is a shortcut for:\nt.Cmp(got, td.Gt(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Gt godoc.\nExamples Int example t := td.NewT(\u0026testing.T{}) got := 156 ok := t.Gt(got, 155, \"checks %v is \u003e 155\", got) fmt.Println(ok) ok = t.Gt(got, 156, \"checks %v is \u003e 156\", got) fmt.Println(ok) // Output: // true // false String example t := td.NewT(\u0026testing.T{}) got := \"abc\" ok := t.Gt(got, \"abb\", `checks \"%v\" is \u003e \"abb\"`, got) fmt.Println(ok) ok = t.Gt(got, \"abc\", `checks \"%v\" is \u003e \"abc\"`, got) fmt.Println(ok) // Output: // true // false",
    "description": "func Gt(minExpectedValue any) TestDeep Gt operator checks that data is greater than minExpectedValue. minExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b minExpectedValue must be the same type as the compared value, except if BeLax config flag is true.",
    "tags": [],
    "title": "Gt",
    "uri": "/operators/gt/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Gte(minExpectedValue any) TestDeep Gte operator checks that data is greater or equal than minExpectedValue. minExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b minExpectedValue must be the same type as the compared value, except if BeLax config flag is true.\ntd.Cmp(t, 17, td.Gte(17)) before := time.Now() td.Cmp(t, time.Now(), td.Gte(before)) TypeBehind method returns the reflect.Type of minExpectedValue.\nSee also Gte godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.Cmp(t, got, td.Gte(156), \"checks %v is ≥ 156\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(155), \"checks %v is ≥ 155\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(157), \"checks %v is ≥ 157\", got) fmt.Println(ok) // Output: // true // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.Cmp(t, got, td.Gte(\"abc\"), `checks \"%v\" is ≥ \"abc\"`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(\"abb\"), `checks \"%v\" is ≥ \"abb\"`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(\"abd\"), `checks \"%v\" is ≥ \"abd\"`, got) fmt.Println(ok) // Output: // true // true // false CmpGte shortcut func CmpGte(t TestingT, got, minExpectedValue any, args ...any) bool CmpGte is a shortcut for:\ntd.Cmp(t, got, td.Gte(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpGte godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.CmpGte(t, got, 156, \"checks %v is ≥ 156\", got) fmt.Println(ok) ok = td.CmpGte(t, got, 155, \"checks %v is ≥ 155\", got) fmt.Println(ok) ok = td.CmpGte(t, got, 157, \"checks %v is ≥ 157\", got) fmt.Println(ok) // Output: // true // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.CmpGte(t, got, \"abc\", `checks \"%v\" is ≥ \"abc\"`, got) fmt.Println(ok) ok = td.CmpGte(t, got, \"abb\", `checks \"%v\" is ≥ \"abb\"`, got) fmt.Println(ok) ok = td.CmpGte(t, got, \"abd\", `checks \"%v\" is ≥ \"abd\"`, got) fmt.Println(ok) // Output: // true // true // false T.Gte shortcut func (t *T) Gte(got, minExpectedValue any, args ...any) bool Gte is a shortcut for:\nt.Cmp(got, td.Gte(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Gte godoc.\nExamples Int example t := td.NewT(\u0026testing.T{}) got := 156 ok := t.Gte(got, 156, \"checks %v is ≥ 156\", got) fmt.Println(ok) ok = t.Gte(got, 155, \"checks %v is ≥ 155\", got) fmt.Println(ok) ok = t.Gte(got, 157, \"checks %v is ≥ 157\", got) fmt.Println(ok) // Output: // true // true // false String example t := td.NewT(\u0026testing.T{}) got := \"abc\" ok := t.Gte(got, \"abc\", `checks \"%v\" is ≥ \"abc\"`, got) fmt.Println(ok) ok = t.Gte(got, \"abb\", `checks \"%v\" is ≥ \"abb\"`, got) fmt.Println(ok) ok = t.Gte(got, \"abd\", `checks \"%v\" is ≥ \"abd\"`, got) fmt.Println(ok) // Output: // true // true // false",
    "description": "func Gte(minExpectedValue any) TestDeep Gte operator checks that data is greater or equal than minExpectedValue. minExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b minExpectedValue must be the same type as the compared value, except if BeLax config flag is true.",
    "tags": [],
    "title": "Gte",
    "uri": "/operators/gte/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func HasPrefix(expected string) TestDeep HasPrefix operator allows to compare the prefix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\ntd.Cmp(t, []byte(\"foobar\"), td.HasPrefix(\"foo\")) // succeeds type Foobar string td.Cmp(t, Foobar(\"foobar\"), td.HasPrefix(\"foo\")) // succeeds err := errors.New(\"error!\") td.Cmp(t, err, td.HasPrefix(\"err\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.HasPrefix(\"fmt\")) // succeeds See also Contains, HasSuffix, Re, ReAll and String.\nSee also HasPrefix godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(ok) // Output: // true CmpHasPrefix shortcut func CmpHasPrefix(t TestingT, got any, expected string, args ...any) bool CmpHasPrefix is a shortcut for:\ntd.Cmp(t, got, td.HasPrefix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpHasPrefix godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.CmpHasPrefix(t, got, \"foo\", \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.CmpHasPrefix(t, got, \"foo\", \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.CmpHasPrefix(t, got, \"foo\", \"checks %s\", got) fmt.Println(ok) // Output: // true T.HasPrefix shortcut func (t *T) HasPrefix(got any, expected string, args ...any) bool HasPrefix is a shortcut for:\nt.Cmp(got, td.HasPrefix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.HasPrefix godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) got := \"foobar\" ok := t.HasPrefix(got, \"foo\", \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = t.Cmp([]byte(got), td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := td.NewT(\u0026testing.T{}) // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := t.HasPrefix(got, \"foo\", \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := td.NewT(\u0026testing.T{}) got := errors.New(\"foobar\") ok := t.HasPrefix(got, \"foo\", \"checks %s\", got) fmt.Println(ok) // Output: // true",
    "description": "func HasPrefix(expected string) TestDeep HasPrefix operator allows to compare the prefix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\ntd.Cmp(t, []byte(\"foobar\"), td.HasPrefix(\"foo\")) // succeeds type Foobar string td.Cmp(t, Foobar(\"foobar\"), td.HasPrefix(\"foo\")) // succeeds err := errors.New(\"error!\") td.Cmp(t, err, td.HasPrefix(\"err\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.HasPrefix(\"fmt\")) // succeeds See also Contains, HasSuffix, Re, ReAll and String.\nSee also HasPrefix godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.HasPrefix(\"foo\"), \"checks %s\", got) fmt.Println(ok) // Output: // true",
    "tags": [],
    "title": "HasPrefix",
    "uri": "/operators/hasprefix/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func HasSuffix(expected string) TestDeep HasSuffix operator allows to compare the suffix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\ntd.Cmp(t, []byte(\"foobar\"), td.HasSuffix(\"bar\")) // succeeds type Foobar string td.Cmp(t, Foobar(\"foobar\"), td.HasSuffix(\"bar\")) // succeeds err := errors.New(\"error!\") td.Cmp(t, err, td.HasSuffix(\"!\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.HasSuffix(\"!\")) // succeeds See also Contains, HasPrefix, Re, ReAll and String.\nSee also HasSuffix godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true CmpHasSuffix shortcut func CmpHasSuffix(t TestingT, got any, expected string, args ...any) bool CmpHasSuffix is a shortcut for:\ntd.Cmp(t, got, td.HasSuffix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpHasSuffix godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.CmpHasSuffix(t, got, \"bar\", \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.CmpHasSuffix(t, got, \"bar\", \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.CmpHasSuffix(t, got, \"bar\", \"checks %s\", got) fmt.Println(ok) // Output: // true T.HasSuffix shortcut func (t *T) HasSuffix(got any, expected string, args ...any) bool HasSuffix is a shortcut for:\nt.Cmp(got, td.HasSuffix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.HasSuffix godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) got := \"foobar\" ok := t.HasSuffix(got, \"bar\", \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = t.Cmp([]byte(got), td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := td.NewT(\u0026testing.T{}) // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := t.HasSuffix(got, \"bar\", \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := td.NewT(\u0026testing.T{}) got := errors.New(\"foobar\") ok := t.HasSuffix(got, \"bar\", \"checks %s\", got) fmt.Println(ok) // Output: // true",
    "description": "func HasSuffix(expected string) TestDeep HasSuffix operator allows to compare the suffix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\ntd.Cmp(t, []byte(\"foobar\"), td.HasSuffix(\"bar\")) // succeeds type Foobar string td.Cmp(t, Foobar(\"foobar\"), td.HasSuffix(\"bar\")) // succeeds err := errors.New(\"error!\") td.Cmp(t, err, td.HasSuffix(\"!\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.HasSuffix(\"!\")) // succeeds See also Contains, HasPrefix, Re, ReAll and String.\nSee also HasSuffix godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.HasSuffix(\"bar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true",
    "tags": [],
    "title": "HasSuffix",
    "uri": "/operators/hassuffix/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Ignore() TestDeep Ignore operator is always true, whatever data is. It is useful when comparing a slice with Slice and wanting to ignore some indexes, for example (if you don’t want to use SuperSliceOf). Or comparing a struct with SStruct and wanting to ignore some fields:\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", }, td.StructFields{ Age: td.Between(40, 45), Children: td.Ignore(), }), ) See also Ignore godoc.\nExample Base example t := \u0026testing.T{} ok := td.Cmp(t, []int{1, 2, 3}, td.Slice([]int{}, td.ArrayEntries{ 0: 1, 1: td.Ignore(), // do not care about this entry 2: 3, })) fmt.Println(ok) // Output: // true",
    "description": "func Ignore() TestDeep Ignore operator is always true, whatever data is. It is useful when comparing a slice with Slice and wanting to ignore some indexes, for example (if you don’t want to use SuperSliceOf). Or comparing a struct with SStruct and wanting to ignore some fields:\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", }, td.StructFields{ Age: td.Between(40, 45), Children: td.Ignore(), }), ) See also Ignore godoc.\nExample Base example t := \u0026testing.T{} ok := td.Cmp(t, []int{1, 2, 3}, td.Slice([]int{}, td.ArrayEntries{ 0: 1, 1: td.Ignore(), // do not care about this entry 2: 3, })) fmt.Println(ok) // Output: // true",
    "tags": [],
    "title": "Ignore",
    "uri": "/operators/ignore/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Isa(model any) TestDeep Isa operator checks the data type or whether data implements an interface or not.\nTypical type checks:\ntd.Cmp(t, time.Now(), td.Isa(time.Time{})) // succeeds td.Cmp(t, time.Now(), td.Isa(\u0026time.Time{})) // fails, as not a *time.Time td.Cmp(t, got, td.Isa(map[string]time.Time{})) For interfaces, it is a bit more complicated, as:\nfmt.Stringer(nil) is not an interface, but just nil… To bypass this golang limitation, Isa accepts pointers on interfaces. So checking that data implements fmt.Stringer interface should be written as:\ntd.Cmp(t, bytes.Buffer{}, td.Isa((*fmt.Stringer)(nil))) // succeeds Of course, in the latter case, if checked data type is *fmt.Stringer, Isa will match too (in fact before checking whether it implements fmt.Stringer or not).\nTypeBehind method returns the reflect.Type of model.\nSee also Isa godoc.\nExamples Base example t := \u0026testing.T{} type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := td.Cmp(t, got, td.Isa(TstStruct{}), \"checks got is a TstStruct\") fmt.Println(ok) ok = td.Cmp(t, got, td.Isa(\u0026TstStruct{}), \"checks got is a pointer on a TstStruct\") fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Isa(\u0026TstStruct{}), \"checks \u0026got is a pointer on a TstStruct\") fmt.Println(ok) // Output: // true // false // true Interface example t := \u0026testing.T{} got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.Isa((*fmt.Stringer)(nil)), \"checks got implements fmt.Stringer interface\") fmt.Println(ok) errGot := fmt.Errorf(\"An error #%d occurred\", 123) ok = td.Cmp(t, errGot, td.Isa((*error)(nil)), \"checks errGot is a *error or implements error interface\") fmt.Println(ok) // As nil, is passed below, it is not an interface but nil… So it // does not match errGot = nil ok = td.Cmp(t, errGot, td.Isa((*error)(nil)), \"checks errGot is a *error or implements error interface\") fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match ok = td.Cmp(t, \u0026errGot, td.Isa((*error)(nil)), \"checks \u0026errGot is a *error or implements error interface\") fmt.Println(ok) // Output: // true // true // false // true CmpIsa shortcut func CmpIsa(t TestingT, got, model any, args ...any) bool CmpIsa is a shortcut for:\ntd.Cmp(t, got, td.Isa(model), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpIsa godoc.\nExamples Base example t := \u0026testing.T{} type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := td.CmpIsa(t, got, TstStruct{}, \"checks got is a TstStruct\") fmt.Println(ok) ok = td.CmpIsa(t, got, \u0026TstStruct{}, \"checks got is a pointer on a TstStruct\") fmt.Println(ok) ok = td.CmpIsa(t, \u0026got, \u0026TstStruct{}, \"checks \u0026got is a pointer on a TstStruct\") fmt.Println(ok) // Output: // true // false // true Interface example t := \u0026testing.T{} got := bytes.NewBufferString(\"foobar\") ok := td.CmpIsa(t, got, (*fmt.Stringer)(nil), \"checks got implements fmt.Stringer interface\") fmt.Println(ok) errGot := fmt.Errorf(\"An error #%d occurred\", 123) ok = td.CmpIsa(t, errGot, (*error)(nil), \"checks errGot is a *error or implements error interface\") fmt.Println(ok) // As nil, is passed below, it is not an interface but nil… So it // does not match errGot = nil ok = td.CmpIsa(t, errGot, (*error)(nil), \"checks errGot is a *error or implements error interface\") fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match ok = td.CmpIsa(t, \u0026errGot, (*error)(nil), \"checks \u0026errGot is a *error or implements error interface\") fmt.Println(ok) // Output: // true // true // false // true T.Isa shortcut func (t *T) Isa(got, model any, args ...any) bool Isa is a shortcut for:\nt.Cmp(got, td.Isa(model), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Isa godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := t.Isa(got, TstStruct{}, \"checks got is a TstStruct\") fmt.Println(ok) ok = t.Isa(got, \u0026TstStruct{}, \"checks got is a pointer on a TstStruct\") fmt.Println(ok) ok = t.Isa(\u0026got, \u0026TstStruct{}, \"checks \u0026got is a pointer on a TstStruct\") fmt.Println(ok) // Output: // true // false // true Interface example t := td.NewT(\u0026testing.T{}) got := bytes.NewBufferString(\"foobar\") ok := t.Isa(got, (*fmt.Stringer)(nil), \"checks got implements fmt.Stringer interface\") fmt.Println(ok) errGot := fmt.Errorf(\"An error #%d occurred\", 123) ok = t.Isa(errGot, (*error)(nil), \"checks errGot is a *error or implements error interface\") fmt.Println(ok) // As nil, is passed below, it is not an interface but nil… So it // does not match errGot = nil ok = t.Isa(errGot, (*error)(nil), \"checks errGot is a *error or implements error interface\") fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match ok = t.Isa(\u0026errGot, (*error)(nil), \"checks \u0026errGot is a *error or implements error interface\") fmt.Println(ok) // Output: // true // true // false // true",
    "description": "func Isa(model any) TestDeep Isa operator checks the data type or whether data implements an interface or not.\nTypical type checks:\ntd.Cmp(t, time.Now(), td.Isa(time.Time{})) // succeeds td.Cmp(t, time.Now(), td.Isa(\u0026time.Time{})) // fails, as not a *time.Time td.Cmp(t, got, td.Isa(map[string]time.Time{})) For interfaces, it is a bit more complicated, as:\nfmt.Stringer(nil) is not an interface, but just nil… To bypass this golang limitation, Isa accepts pointers on interfaces. So checking that data implements fmt.Stringer interface should be written as:\ntd.Cmp(t, bytes.Buffer{}, td.Isa((*fmt.Stringer)(nil))) // succeeds Of course, in the latter case, if checked data type is *fmt.Stringer, Isa will match too (in fact before checking whether it implements fmt.Stringer or not).",
    "tags": [],
    "title": "Isa",
    "uri": "/operators/isa/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func JSON(expectedJSON any, params ...any) TestDeep JSON operator allows to compare the JSON representation of data against expectedJSON. expectedJSON can be a:\nstring containing JSON data like {\"fullname\":\"Bob\",\"age\":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n’th “operators” item (starting at 1). Named placeholders are used with Tag operator as follows:\ntd.Cmp(t, gotValue, td.JSON(`{\"fullname\": $name, \"age\": $2, \"gender\": $3}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43), // matches only $2 \"male\")) // matches only $3 Note that placeholders can be double-quoted as in:\ntd.Cmp(t, gotValue, td.JSON(`{\"fullname\": \"$name\", \"age\": \"$2\", \"gender\": \"$3\"}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43), // matches only $2 \"male\")) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a “.json” file.\nJSON does its best to convert back the JSON corresponding to a placeholder to the type of the placeholder or, if the placeholder is an operator, to the type behind the operator. Allowing to do things like:\ntd.Cmp(t, gotValue, td.JSON(`{\"foo\":$1}`, []int{1, 2, 3, 4})) td.Cmp(t, gotValue, td.JSON(`{\"foo\":$1}`, []any{1, 2, td.Between(2, 4), 4})) td.Cmp(t, gotValue, td.JSON(`{\"foo\":$1}`, td.Between(27, 32))) Of course, it does this conversion only if the expected type can be guessed. In the case the conversion cannot occur, data is compared as is, in its freshly unmarshaled JSON form (so as bool, float64, string, []any, map[string]any or simply nil).\nNote expectedJSON can be a []byte, an encoding/json.RawMessage, a JSON filename or a io.Reader:\ntd.Cmp(t, gotValue, td.JSON(\"file.json\", td.Between(12, 34))) td.Cmp(t, gotValue, td.JSON([]byte(`[1, $1, 3]`), td.Between(12, 34))) td.Cmp(t, gotValue, td.JSON(osFile, td.Between(12, 34))) A JSON filename ends with “.json”.\nTo avoid a legit “$” string prefix causes a bad placeholder error, just double it to escape it. Note it is only needed when the “$” is the first character of a string:\ntd.Cmp(t, gotValue, td.JSON(`{\"fullname\": \"$name\", \"details\": \"$$info\", \"age\": $2}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43))) // matches only $2 For the “details” key, the raw value “$info” is expected, no placeholders are involved here.\nNote that Lax mode is automatically enabled by JSON operator to simplify numeric tests.\nComments can be embedded in JSON data:\ntd.Cmp(t, gotValue, td.JSON(` { // A guy properties: \"fullname\": \"$name\", // The full name of the guy \"details\": \"$$info\", // Literally \"$info\", thanks to \"$\" escape \"age\": $2 /* The age of the guy: - placeholder unquoted, but could be without any change - to demonstrate a multi-lines comment */ }`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43))) // matches only $2 Comments, like in go, have 2 forms. To quote the Go language specification:\nline comments start with the character sequence // and stop at the end of the line. multi-lines comments start with the character sequence /* and stop with the first subsequent character sequence */. Other JSON divergences:\n‘,’ can precede a ‘}’ or a ‘]’ (as in go); strings can contain non-escaped \\n, \\r and \\t; raw strings are accepted (r{raw}, r!raw!, …), see below; int_lit \u0026 float_lit numbers as defined in go spec are accepted; numbers can be prefixed by ‘+’. Most operators can be directly embedded in JSON without requiring any placeholder. If an operators does not take any parameter, the parenthesis can be omitted.\ntd.Cmp(t, gotValue, td.JSON(` { \"fullname\": HasPrefix(\"Foo\"), \"age\": Between(41, 43), \"details\": SuperMapOf({ \"address\": NotEmpty, // () are optional when no parameters \"car\": Any(\"Peugeot\", \"Tesla\", \"Jeep\") // any of these }) }`)) Placeholders can be used anywhere, even in operators parameters as in:\ntd.Cmp(t, gotValue, td.JSON(`{\"fullname\": HasPrefix($1)}`, \"Zip\")) A few notes about operators embedding:\nSubMapOf and SuperMapOf take only one parameter, a JSON object; the optional 3rd parameter of Between has to be specified as a string and can be: “[]” or “BoundsInIn” (default), “[[” or “BoundsInOut”, “]]” or “BoundsOutIn”, “][” or “BoundsOutOut”; not all operators are embeddable only the following are: All, Any, ArrayEach, Bag, Between, Contains, ContainsKey, Empty, First, Grep, Gt, Gte, HasPrefix, HasSuffix, Ignore, JSONPointer, Keys, Last, Len, Lt, Lte, MapEach, N, NaN, Nil, None, Not, NotAny, NotEmpty, NotNaN, NotNil, NotZero, Re, ReAll, Set, Sort, Sorted, SubBagOf, SubMapOf, SubSetOf, SuperBagOf, SuperMapOf, SuperSetOf, Values and Zero. It is also possible to embed operators in JSON strings. This way, the JSON specification can be fulfilled. To avoid collision with possible strings, just prefix the first operator name with “$^”. The previous example becomes:\ntd.Cmp(t, gotValue, td.JSON(` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ \\\"address\\\": NotEmpty, // () are optional when no parameters \\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\") // any of these })\" }`)) As you can see, in this case, strings in strings have to be escaped. Fortunately, newlines are accepted, but unfortunately they are forbidden by JSON specification. To avoid too much escaping, raw strings are accepted. A raw string is a “r” followed by a delimiter, the corresponding delimiter closes the string. The following raw strings are all the same as “foo\\bar(\"zip\")!”:\nr’foo\\bar\"zip\"!’ r,foo\\bar\"zip\"!, r%foo\\bar\"zip\"!% r(foo\\bar(“zip”)!) r{foo\\bar(“zip”)!} r[foo\\bar(“zip”)!] r\u003cfoo\\bar(“zip”)!\u003e So non-bracketing delimiters use the same character before and after, but the 4 sorts of ASCII brackets (round, angle, square, curly) all nest: r[x[y]z] equals “x[y]z”. The end delimiter cannot be escaped.\nWith raw strings, the previous example becomes:\ntd.Cmp(t, gotValue, td.JSON(` { \"fullname\": \"$^HasPrefix(r\u003cFoo\u003e)\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ r\u003caddress\u003e: NotEmpty, // () are optional when no parameters r\u003ccar\u003e: Any(r\u003cPeugeot\u003e, r\u003cTesla\u003e, r\u003cJeep\u003e) // any of these })\" }`)) Note that raw strings are accepted anywhere, not only in original JSON strings.\nTo be complete, $^ can prefix an operator even outside a string. This is accepted for compatibility purpose as the first operator embedding feature used this way to embed some operators.\nSo the following calls are all equivalent:\ntd.Cmp(t, gotValue, td.JSON(`{\"id\": $1}`, td.NotZero())) td.Cmp(t, gotValue, td.JSON(`{\"id\": NotZero}`)) td.Cmp(t, gotValue, td.JSON(`{\"id\": NotZero()}`)) td.Cmp(t, gotValue, td.JSON(`{\"id\": $^NotZero}`)) td.Cmp(t, gotValue, td.JSON(`{\"id\": $^NotZero()}`)) td.Cmp(t, gotValue, td.JSON(`{\"id\": \"$^NotZero\"}`)) td.Cmp(t, gotValue, td.JSON(`{\"id\": \"$^NotZero()\"}`)) As for placeholders, there is no differences between $^NotZero and “$^NotZero”.\nTip: when an io.Reader is expected to contain JSON data, it cannot be tested directly, but using the Smuggle operator simply solves the problem:\nvar body io.Reader // … td.Cmp(t, body, td.Smuggle(json.RawMessage{}, td.JSON(`{\"foo\":1}`))) // or equally td.Cmp(t, body, td.Smuggle(json.RawMessage(nil), td.JSON(`{\"foo\":1}`))) Smuggle reads from body into an encoding/json.RawMessage then this buffer is unmarshaled by JSON operator before the comparison.\nTypeBehind method returns the reflect.Type of the expectedJSON once JSON unmarshaled. So it can be bool, string, float64, []any, map[string]any or any in case expectedJSON is “null”.\nSee also JSONPointer, SubJSONOf and SuperJSONOf.\nSee also JSON godoc.\nExamples Basic example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } ok := td.Cmp(t, got, td.JSON(`{\"age\":42,\"fullname\":\"Bob\"}`)) fmt.Println(\"check got with age then fullname:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"fullname\":\"Bob\",\"age\":42}`)) fmt.Println(\"check got with fullname then age:\", ok) ok = td.Cmp(t, got, td.JSON(` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42 /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ }`)) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`)) fmt.Println(\"check got with gender field:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"fullname\":\"Bob\"}`)) fmt.Println(\"check got with fullname only:\", ok) ok = td.Cmp(t, true, td.JSON(`true`)) fmt.Println(\"check boolean got is true:\", ok) ok = td.Cmp(t, 42, td.JSON(`42`)) fmt.Println(\"check numeric got is 42:\", ok) got = nil ok = td.Cmp(t, got, td.JSON(`null`)) fmt.Println(\"check nil got is null:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got with gender field: false // check got with fullname only: false // check boolean got is true: true // check numeric got is 42: true // check nil got is null: true Placeholders example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Children []*Person `json:\"children,omitempty\"` } got := \u0026Person{ Fullname: \"Bob Foobar\", Age: 42, } ok := td.Cmp(t, got, td.JSON(`{\"age\": $1, \"fullname\": $2}`, 42, \"Bob Foobar\")) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"age\": $1, \"fullname\": $2}`, td.Between(40, 45), td.HasSuffix(\"Foobar\"))) fmt.Println(\"check got with numeric placeholders:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"age\": \"$1\", \"fullname\": \"$2\"}`, td.Between(40, 45), td.HasSuffix(\"Foobar\"))) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"age\": $age, \"fullname\": $name}`, td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")))) fmt.Println(\"check got with named placeholders:\", ok) got.Children = []*Person{ {Fullname: \"Alice\", Age: 28}, {Fullname: \"Brian\", Age: 22}, } ok = td.Cmp(t, got, td.JSON(`{\"age\": $age, \"fullname\": $name, \"children\": $children}`, td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"children\", td.Bag( \u0026Person{Fullname: \"Brian\", Age: 22}, \u0026Person{Fullname: \"Alice\", Age: 28}, )))) fmt.Println(\"check got w/named placeholders, and children w/go structs:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"age\": Between($1, $2), \"fullname\": HasSuffix($suffix), \"children\": Len(2)}`, 40, 45, td.Tag(\"suffix\", \"Foobar\"))) fmt.Println(\"check got w/num \u0026 named placeholders:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got w/named placeholders, and children w/go structs: true // check got w/num \u0026 named placeholders: true Embedding example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob Foobar\", Age: 42, } ok := td.Cmp(t, got, td.JSON(`{\"age\": NotZero(), \"fullname\": NotEmpty()}`)) fmt.Println(\"check got with simple operators:\", ok) ok = td.Cmp(t, got, td.JSON(`{\"age\": $^NotZero, \"fullname\": $^NotEmpty}`)) fmt.Println(\"check got with operator shortcuts:\", ok) ok = td.Cmp(t, got, td.JSON(` { \"age\": Between(40, 42, \"]]\"), // in ]40; 42] \"fullname\": All( HasPrefix(\"Bob\"), HasSuffix(\"bar\") // ← comma is optional here ) }`)) fmt.Println(\"check got with complex operators:\", ok) ok = td.Cmp(t, got, td.JSON(` { \"age\": Between(40, 42, \"][\"), // in ]40; 42[ → 42 excluded \"fullname\": All( HasPrefix(\"Bob\"), HasSuffix(\"bar\"), ) }`)) fmt.Println(\"check got with complex operators:\", ok) ok = td.Cmp(t, got, td.JSON(` { \"age\": Between($1, $2, $3), // in ]40; 42] \"fullname\": All( HasPrefix($4), HasSuffix(\"bar\") // ← comma is optional here ) }`, 40, 42, td.BoundsOutIn, \"Bob\")) fmt.Println(\"check got with complex operators, w/placeholder args:\", ok) // Output: // check got with simple operators: true // check got with operator shortcuts: true // check got with complex operators: true // check got with complex operators: false // check got with complex operators, w/placeholder args: true RawStrings example t := \u0026testing.T{} type details struct { Address string `json:\"address\"` Car string `json:\"car\"` } got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Details details `json:\"details\"` }{ Fullname: \"Foo Bar\", Age: 42, Details: details{ Address: \"something\", Car: \"Peugeot\", }, } ok := td.Cmp(t, got, td.JSON(` { \"fullname\": HasPrefix(\"Foo\"), \"age\": Between(41, 43), \"details\": SuperMapOf({ \"address\": NotEmpty, // () are optional when no parameters \"car\": Any(\"Peugeot\", \"Tesla\", \"Jeep\") // any of these }) }`)) fmt.Println(\"Original:\", ok) ok = td.Cmp(t, got, td.JSON(` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({\\n\\\"address\\\": NotEmpty,\\n\\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\")\\n})\" }`)) fmt.Println(\"JSON compliant:\", ok) ok = td.Cmp(t, got, td.JSON(` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ \\\"address\\\": NotEmpty, // () are optional when no parameters \\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\") // any of these })\" }`)) fmt.Println(\"JSON multilines strings:\", ok) ok = td.Cmp(t, got, td.JSON(` { \"fullname\": \"$^HasPrefix(r\u003cFoo\u003e)\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ r\u003caddress\u003e: NotEmpty, // () are optional when no parameters r\u003ccar\u003e: Any(r\u003cPeugeot\u003e, r\u003cTesla\u003e, r\u003cJeep\u003e) // any of these })\" }`)) fmt.Println(\"Raw strings:\", ok) // Output: // Original: true // JSON compliant: true // JSON multilines strings: true // Raw strings: true File example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\" }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := td.Cmp(t, got, td.JSON(filename, td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`)))) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.Cmp(t, got, td.JSON(file, td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`)))) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true CmpJSON shortcut func CmpJSON(t TestingT, got, expectedJSON any, params []any, args ...any) bool CmpJSON is a shortcut for:\ntd.Cmp(t, got, td.JSON(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpJSON godoc.\nExamples Basic example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } ok := td.CmpJSON(t, got, `{\"age\":42,\"fullname\":\"Bob\"}`, nil) fmt.Println(\"check got with age then fullname:\", ok) ok = td.CmpJSON(t, got, `{\"fullname\":\"Bob\",\"age\":42}`, nil) fmt.Println(\"check got with fullname then age:\", ok) ok = td.CmpJSON(t, got, ` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42 /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ }`, nil) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = td.CmpJSON(t, got, `{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`, nil) fmt.Println(\"check got with gender field:\", ok) ok = td.CmpJSON(t, got, `{\"fullname\":\"Bob\"}`, nil) fmt.Println(\"check got with fullname only:\", ok) ok = td.CmpJSON(t, true, `true`, nil) fmt.Println(\"check boolean got is true:\", ok) ok = td.CmpJSON(t, 42, `42`, nil) fmt.Println(\"check numeric got is 42:\", ok) got = nil ok = td.CmpJSON(t, got, `null`, nil) fmt.Println(\"check nil got is null:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got with gender field: false // check got with fullname only: false // check boolean got is true: true // check numeric got is 42: true // check nil got is null: true Placeholders example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Children []*Person `json:\"children,omitempty\"` } got := \u0026Person{ Fullname: \"Bob Foobar\", Age: 42, } ok := td.CmpJSON(t, got, `{\"age\": $1, \"fullname\": $2}`, []any{42, \"Bob Foobar\"}) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = td.CmpJSON(t, got, `{\"age\": $1, \"fullname\": $2}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\")}) fmt.Println(\"check got with numeric placeholders:\", ok) ok = td.CmpJSON(t, got, `{\"age\": \"$1\", \"fullname\": \"$2\"}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\")}) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = td.CmpJSON(t, got, `{\"age\": $age, \"fullname\": $name}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\"))}) fmt.Println(\"check got with named placeholders:\", ok) got.Children = []*Person{ {Fullname: \"Alice\", Age: 28}, {Fullname: \"Brian\", Age: 22}, } ok = td.CmpJSON(t, got, `{\"age\": $age, \"fullname\": $name, \"children\": $children}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"children\", td.Bag( \u0026Person{Fullname: \"Brian\", Age: 22}, \u0026Person{Fullname: \"Alice\", Age: 28}, ))}) fmt.Println(\"check got w/named placeholders, and children w/go structs:\", ok) ok = td.CmpJSON(t, got, `{\"age\": Between($1, $2), \"fullname\": HasSuffix($suffix), \"children\": Len(2)}`, []any{40, 45, td.Tag(\"suffix\", \"Foobar\")}) fmt.Println(\"check got w/num \u0026 named placeholders:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got w/named placeholders, and children w/go structs: true // check got w/num \u0026 named placeholders: true Embedding example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob Foobar\", Age: 42, } ok := td.CmpJSON(t, got, `{\"age\": NotZero(), \"fullname\": NotEmpty()}`, nil) fmt.Println(\"check got with simple operators:\", ok) ok = td.CmpJSON(t, got, `{\"age\": $^NotZero, \"fullname\": $^NotEmpty}`, nil) fmt.Println(\"check got with operator shortcuts:\", ok) ok = td.CmpJSON(t, got, ` { \"age\": Between(40, 42, \"]]\"), // in ]40; 42] \"fullname\": All( HasPrefix(\"Bob\"), HasSuffix(\"bar\") // ← comma is optional here ) }`, nil) fmt.Println(\"check got with complex operators:\", ok) ok = td.CmpJSON(t, got, ` { \"age\": Between(40, 42, \"][\"), // in ]40; 42[ → 42 excluded \"fullname\": All( HasPrefix(\"Bob\"), HasSuffix(\"bar\"), ) }`, nil) fmt.Println(\"check got with complex operators:\", ok) ok = td.CmpJSON(t, got, ` { \"age\": Between($1, $2, $3), // in ]40; 42] \"fullname\": All( HasPrefix($4), HasSuffix(\"bar\") // ← comma is optional here ) }`, []any{40, 42, td.BoundsOutIn, \"Bob\"}) fmt.Println(\"check got with complex operators, w/placeholder args:\", ok) // Output: // check got with simple operators: true // check got with operator shortcuts: true // check got with complex operators: true // check got with complex operators: false // check got with complex operators, w/placeholder args: true RawStrings example t := \u0026testing.T{} type details struct { Address string `json:\"address\"` Car string `json:\"car\"` } got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Details details `json:\"details\"` }{ Fullname: \"Foo Bar\", Age: 42, Details: details{ Address: \"something\", Car: \"Peugeot\", }, } ok := td.CmpJSON(t, got, ` { \"fullname\": HasPrefix(\"Foo\"), \"age\": Between(41, 43), \"details\": SuperMapOf({ \"address\": NotEmpty, // () are optional when no parameters \"car\": Any(\"Peugeot\", \"Tesla\", \"Jeep\") // any of these }) }`, nil) fmt.Println(\"Original:\", ok) ok = td.CmpJSON(t, got, ` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({\\n\\\"address\\\": NotEmpty,\\n\\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\")\\n})\" }`, nil) fmt.Println(\"JSON compliant:\", ok) ok = td.CmpJSON(t, got, ` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ \\\"address\\\": NotEmpty, // () are optional when no parameters \\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\") // any of these })\" }`, nil) fmt.Println(\"JSON multilines strings:\", ok) ok = td.CmpJSON(t, got, ` { \"fullname\": \"$^HasPrefix(r\u003cFoo\u003e)\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ r\u003caddress\u003e: NotEmpty, // () are optional when no parameters r\u003ccar\u003e: Any(r\u003cPeugeot\u003e, r\u003cTesla\u003e, r\u003cJeep\u003e) // any of these })\" }`, nil) fmt.Println(\"Raw strings:\", ok) // Output: // Original: true // JSON compliant: true // JSON multilines strings: true // Raw strings: true File example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\" }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := td.CmpJSON(t, got, filename, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.CmpJSON(t, got, file, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true T.JSON shortcut func (t *T) JSON(got, expectedJSON any, params []any, args ...any) bool JSON is a shortcut for:\nt.Cmp(got, td.JSON(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.JSON godoc.\nExamples Basic example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } ok := t.JSON(got, `{\"age\":42,\"fullname\":\"Bob\"}`, nil) fmt.Println(\"check got with age then fullname:\", ok) ok = t.JSON(got, `{\"fullname\":\"Bob\",\"age\":42}`, nil) fmt.Println(\"check got with fullname then age:\", ok) ok = t.JSON(got, ` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42 /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ }`, nil) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = t.JSON(got, `{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`, nil) fmt.Println(\"check got with gender field:\", ok) ok = t.JSON(got, `{\"fullname\":\"Bob\"}`, nil) fmt.Println(\"check got with fullname only:\", ok) ok = t.JSON(true, `true`, nil) fmt.Println(\"check boolean got is true:\", ok) ok = t.JSON(42, `42`, nil) fmt.Println(\"check numeric got is 42:\", ok) got = nil ok = t.JSON(got, `null`, nil) fmt.Println(\"check nil got is null:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got with gender field: false // check got with fullname only: false // check boolean got is true: true // check numeric got is 42: true // check nil got is null: true Placeholders example t := td.NewT(\u0026testing.T{}) type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Children []*Person `json:\"children,omitempty\"` } got := \u0026Person{ Fullname: \"Bob Foobar\", Age: 42, } ok := t.JSON(got, `{\"age\": $1, \"fullname\": $2}`, []any{42, \"Bob Foobar\"}) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = t.JSON(got, `{\"age\": $1, \"fullname\": $2}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\")}) fmt.Println(\"check got with numeric placeholders:\", ok) ok = t.JSON(got, `{\"age\": \"$1\", \"fullname\": \"$2\"}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\")}) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = t.JSON(got, `{\"age\": $age, \"fullname\": $name}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\"))}) fmt.Println(\"check got with named placeholders:\", ok) got.Children = []*Person{ {Fullname: \"Alice\", Age: 28}, {Fullname: \"Brian\", Age: 22}, } ok = t.JSON(got, `{\"age\": $age, \"fullname\": $name, \"children\": $children}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"children\", td.Bag( \u0026Person{Fullname: \"Brian\", Age: 22}, \u0026Person{Fullname: \"Alice\", Age: 28}, ))}) fmt.Println(\"check got w/named placeholders, and children w/go structs:\", ok) ok = t.JSON(got, `{\"age\": Between($1, $2), \"fullname\": HasSuffix($suffix), \"children\": Len(2)}`, []any{40, 45, td.Tag(\"suffix\", \"Foobar\")}) fmt.Println(\"check got w/num \u0026 named placeholders:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got w/named placeholders, and children w/go structs: true // check got w/num \u0026 named placeholders: true Embedding example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob Foobar\", Age: 42, } ok := t.JSON(got, `{\"age\": NotZero(), \"fullname\": NotEmpty()}`, nil) fmt.Println(\"check got with simple operators:\", ok) ok = t.JSON(got, `{\"age\": $^NotZero, \"fullname\": $^NotEmpty}`, nil) fmt.Println(\"check got with operator shortcuts:\", ok) ok = t.JSON(got, ` { \"age\": Between(40, 42, \"]]\"), // in ]40; 42] \"fullname\": All( HasPrefix(\"Bob\"), HasSuffix(\"bar\") // ← comma is optional here ) }`, nil) fmt.Println(\"check got with complex operators:\", ok) ok = t.JSON(got, ` { \"age\": Between(40, 42, \"][\"), // in ]40; 42[ → 42 excluded \"fullname\": All( HasPrefix(\"Bob\"), HasSuffix(\"bar\"), ) }`, nil) fmt.Println(\"check got with complex operators:\", ok) ok = t.JSON(got, ` { \"age\": Between($1, $2, $3), // in ]40; 42] \"fullname\": All( HasPrefix($4), HasSuffix(\"bar\") // ← comma is optional here ) }`, []any{40, 42, td.BoundsOutIn, \"Bob\"}) fmt.Println(\"check got with complex operators, w/placeholder args:\", ok) // Output: // check got with simple operators: true // check got with operator shortcuts: true // check got with complex operators: true // check got with complex operators: false // check got with complex operators, w/placeholder args: true RawStrings example t := td.NewT(\u0026testing.T{}) type details struct { Address string `json:\"address\"` Car string `json:\"car\"` } got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Details details `json:\"details\"` }{ Fullname: \"Foo Bar\", Age: 42, Details: details{ Address: \"something\", Car: \"Peugeot\", }, } ok := t.JSON(got, ` { \"fullname\": HasPrefix(\"Foo\"), \"age\": Between(41, 43), \"details\": SuperMapOf({ \"address\": NotEmpty, // () are optional when no parameters \"car\": Any(\"Peugeot\", \"Tesla\", \"Jeep\") // any of these }) }`, nil) fmt.Println(\"Original:\", ok) ok = t.JSON(got, ` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({\\n\\\"address\\\": NotEmpty,\\n\\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\")\\n})\" }`, nil) fmt.Println(\"JSON compliant:\", ok) ok = t.JSON(got, ` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ \\\"address\\\": NotEmpty, // () are optional when no parameters \\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\") // any of these })\" }`, nil) fmt.Println(\"JSON multilines strings:\", ok) ok = t.JSON(got, ` { \"fullname\": \"$^HasPrefix(r\u003cFoo\u003e)\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ r\u003caddress\u003e: NotEmpty, // () are optional when no parameters r\u003ccar\u003e: Any(r\u003cPeugeot\u003e, r\u003cTesla\u003e, r\u003cJeep\u003e) // any of these })\" }`, nil) fmt.Println(\"Raw strings:\", ok) // Output: // Original: true // JSON compliant: true // JSON multilines strings: true // Raw strings: true File example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\" }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := t.JSON(got, filename, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.JSON(got, file, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true",
    "description": "func JSON(expectedJSON any, params ...any) TestDeep JSON operator allows to compare the JSON representation of data against expectedJSON. expectedJSON can be a:\nstring containing JSON data like {\"fullname\":\"Bob\",\"age\":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.",
    "tags": [],
    "title": "JSON",
    "uri": "/operators/json/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func JSONPointer(ptr string, expectedValue any) TestDeep JSONPointer is a smuggler operator. It takes the JSON representation of data, gets the value corresponding to the JSON pointer ptr (as RFC 6901 specifies it) and compares it to expectedValue.\nLax mode is automatically enabled to simplify numeric tests.\nJSONPointer does its best to convert back the JSON pointed data to the type of expectedValue or to the type behind the expectedValue operator, if it is an operator. Allowing to do things like:\ntype Item struct { Val int `json:\"val\"` Next *Item `json:\"next\"` } got := Item{Val: 1, Next: \u0026Item{Val: 2, Next: \u0026Item{Val: 3}}} td.Cmp(t, got, td.JSONPointer(\"/next/next\", Item{Val: 3})) td.Cmp(t, got, td.JSONPointer(\"/next/next\", \u0026Item{Val: 3})) td.Cmp(t, got, td.JSONPointer(\"/next/next\", td.Struct(Item{}, td.StructFields{\"Val\": td.Gte(3)})), ) got := map[string]int64{\"zzz\": 42} // 42 is int64 here td.Cmp(t, got, td.JSONPointer(\"/zzz\", 42)) td.Cmp(t, got, td.JSONPointer(\"/zzz\", td.Between(40, 45))) Of course, it does this conversion only if the expected type can be guessed. In the case the conversion cannot occur, data is compared as is, in its freshly unmarshaled JSON form (so as bool, float64, string, []any, map[string]any or simply nil).\nNote that as any TestDeep operator can be used as expectedValue, JSON operator works out of the box:\ngot := json.RawMessage(`{\"foo\":{\"bar\": {\"zip\": true}}}`) td.Cmp(t, got, td.JSONPointer(\"/foo/bar\", td.JSON(`{\"zip\": true}`))) It can be used with structs lacking json tags. In this case, fields names have to be used in JSON pointer:\ntype Item struct { Val int Next *Item } got := Item{Val: 1, Next: \u0026Item{Val: 2, Next: \u0026Item{Val: 3}}} td.Cmp(t, got, td.JSONPointer(\"/Next/Next\", Item{Val: 3})) Contrary to Smuggle operator and its fields-path feature, only public fields can be followed, as private ones are never (un)marshaled.\nThere is no JSONHas nor JSONHasnt operators to only check a JSON pointer exists or not, but they can easily be emulated:\nJSONHas := func(pointer string) td.TestDeep { return td.JSONPointer(pointer, td.Ignore()) } JSONHasnt := func(pointer string) td.TestDeep { return td.Not(td.JSONPointer(pointer, td.Ignore())) } TypeBehind method always returns nil as the expected type cannot be guessed from a JSON pointer.\nSee also JSON, SubJSONOf, SuperJSONOf, Smuggle and Flatten.\nSee also JSONPointer godoc.\nExamples Rfc6901 example t := \u0026testing.T{} got := json.RawMessage(` { \"foo\": [\"bar\", \"baz\"], \"\": 0, \"a/b\": 1, \"c%d\": 2, \"e^f\": 3, \"g|h\": 4, \"i\\\\j\": 5, \"k\\\"l\": 6, \" \": 7, \"m~n\": 8 }`) expected := map[string]any{ \"foo\": []any{\"bar\", \"baz\"}, \"\": 0, \"a/b\": 1, \"c%d\": 2, \"e^f\": 3, \"g|h\": 4, `i\\j`: 5, `k\"l`: 6, \" \": 7, \"m~n\": 8, } ok := td.Cmp(t, got, td.JSONPointer(\"\", expected)) fmt.Println(\"Empty JSON pointer means all:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/foo`, []any{\"bar\", \"baz\"})) fmt.Println(\"Extract `foo` key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/foo/0`, \"bar\")) fmt.Println(\"First item of `foo` key slice:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/`, 0)) fmt.Println(\"Empty key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/a~1b`, 1)) fmt.Println(\"Slash has to be escaped using `~1`:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/c%d`, 2)) fmt.Println(\"% in key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/e^f`, 3)) fmt.Println(\"^ in key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/g|h`, 4)) fmt.Println(\"| in key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/i\\j`, 5)) fmt.Println(\"Backslash in key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/k\"l`, 6)) fmt.Println(\"Double-quote in key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/ `, 7)) fmt.Println(\"Space key:\", ok) ok = td.Cmp(t, got, td.JSONPointer(`/m~0n`, 8)) fmt.Println(\"Tilde has to be escaped using `~0`:\", ok) // Output: // Empty JSON pointer means all: true // Extract `foo` key: true // First item of `foo` key slice: true // Empty key: true // Slash has to be escaped using `~1`: true // % in key: true // ^ in key: true // | in key: true // Backslash in key: true // Double-quote in key: true // Space key: true // Tilde has to be escaped using `~0`: true Struct example t := \u0026testing.T{} // Without json tags, encoding/json uses public fields name type Item struct { Name string Value int64 Next *Item } got := Item{ Name: \"first\", Value: 1, Next: \u0026Item{ Name: \"second\", Value: 2, Next: \u0026Item{ Name: \"third\", Value: 3, }, }, } ok := td.Cmp(t, got, td.JSONPointer(\"/Next/Next/Name\", \"third\")) fmt.Println(\"3rd item name is `third`:\", ok) ok = td.Cmp(t, got, td.JSONPointer(\"/Next/Next/Value\", td.Gte(int64(3)))) fmt.Println(\"3rd item value is greater or equal than 3:\", ok) ok = td.Cmp(t, got, td.JSONPointer(\"/Next\", td.JSONPointer(\"/Next\", td.JSONPointer(\"/Value\", td.Gte(int64(3)))))) fmt.Println(\"3rd item value is still greater or equal than 3:\", ok) ok = td.Cmp(t, got, td.JSONPointer(\"/Next/Next/Next/Name\", td.Ignore())) fmt.Println(\"4th item exists and has a name:\", ok) // Struct comparison work with or without pointer: \u0026Item{…} works too ok = td.Cmp(t, got, td.JSONPointer(\"/Next/Next\", Item{ Name: \"third\", Value: 3, })) fmt.Println(\"3rd item full comparison:\", ok) // Output: // 3rd item name is `third`: true // 3rd item value is greater or equal than 3: true // 3rd item value is still greater or equal than 3: true // 4th item exists and has a name: false // 3rd item full comparison: true Has_hasnt example t := \u0026testing.T{} got := json.RawMessage(` { \"name\": \"Bob\", \"age\": 42, \"children\": [ { \"name\": \"Alice\", \"age\": 16 }, { \"name\": \"Britt\", \"age\": 21, \"children\": [ { \"name\": \"John\", \"age\": 1 } ] } ] }`) // Has Bob some children? ok := td.Cmp(t, got, td.JSONPointer(\"/children\", td.Len(td.Gt(0)))) fmt.Println(\"Bob has at least one child:\", ok) // But checking \"children\" exists is enough here ok = td.Cmp(t, got, td.JSONPointer(\"/children/0/children\", td.Ignore())) fmt.Println(\"Alice has children:\", ok) ok = td.Cmp(t, got, td.JSONPointer(\"/children/1/children\", td.Ignore())) fmt.Println(\"Britt has children:\", ok) // The reverse can be checked too ok = td.Cmp(t, got, td.Not(td.JSONPointer(\"/children/0/children\", td.Ignore()))) fmt.Println(\"Alice hasn't children:\", ok) ok = td.Cmp(t, got, td.Not(td.JSONPointer(\"/children/1/children\", td.Ignore()))) fmt.Println(\"Britt hasn't children:\", ok) // Output: // Bob has at least one child: true // Alice has children: false // Britt has children: true // Alice hasn't children: true // Britt hasn't children: false CmpJSONPointer shortcut func CmpJSONPointer(t TestingT, got any, ptr string, expectedValue any, args ...any) bool CmpJSONPointer is a shortcut for:\ntd.Cmp(t, got, td.JSONPointer(ptr, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpJSONPointer godoc.\nExamples Rfc6901 example t := \u0026testing.T{} got := json.RawMessage(` { \"foo\": [\"bar\", \"baz\"], \"\": 0, \"a/b\": 1, \"c%d\": 2, \"e^f\": 3, \"g|h\": 4, \"i\\\\j\": 5, \"k\\\"l\": 6, \" \": 7, \"m~n\": 8 }`) expected := map[string]any{ \"foo\": []any{\"bar\", \"baz\"}, \"\": 0, \"a/b\": 1, \"c%d\": 2, \"e^f\": 3, \"g|h\": 4, `i\\j`: 5, `k\"l`: 6, \" \": 7, \"m~n\": 8, } ok := td.CmpJSONPointer(t, got, \"\", expected) fmt.Println(\"Empty JSON pointer means all:\", ok) ok = td.CmpJSONPointer(t, got, `/foo`, []any{\"bar\", \"baz\"}) fmt.Println(\"Extract `foo` key:\", ok) ok = td.CmpJSONPointer(t, got, `/foo/0`, \"bar\") fmt.Println(\"First item of `foo` key slice:\", ok) ok = td.CmpJSONPointer(t, got, `/`, 0) fmt.Println(\"Empty key:\", ok) ok = td.CmpJSONPointer(t, got, `/a~1b`, 1) fmt.Println(\"Slash has to be escaped using `~1`:\", ok) ok = td.CmpJSONPointer(t, got, `/c%d`, 2) fmt.Println(\"% in key:\", ok) ok = td.CmpJSONPointer(t, got, `/e^f`, 3) fmt.Println(\"^ in key:\", ok) ok = td.CmpJSONPointer(t, got, `/g|h`, 4) fmt.Println(\"| in key:\", ok) ok = td.CmpJSONPointer(t, got, `/i\\j`, 5) fmt.Println(\"Backslash in key:\", ok) ok = td.CmpJSONPointer(t, got, `/k\"l`, 6) fmt.Println(\"Double-quote in key:\", ok) ok = td.CmpJSONPointer(t, got, `/ `, 7) fmt.Println(\"Space key:\", ok) ok = td.CmpJSONPointer(t, got, `/m~0n`, 8) fmt.Println(\"Tilde has to be escaped using `~0`:\", ok) // Output: // Empty JSON pointer means all: true // Extract `foo` key: true // First item of `foo` key slice: true // Empty key: true // Slash has to be escaped using `~1`: true // % in key: true // ^ in key: true // | in key: true // Backslash in key: true // Double-quote in key: true // Space key: true // Tilde has to be escaped using `~0`: true Struct example t := \u0026testing.T{} // Without json tags, encoding/json uses public fields name type Item struct { Name string Value int64 Next *Item } got := Item{ Name: \"first\", Value: 1, Next: \u0026Item{ Name: \"second\", Value: 2, Next: \u0026Item{ Name: \"third\", Value: 3, }, }, } ok := td.CmpJSONPointer(t, got, \"/Next/Next/Name\", \"third\") fmt.Println(\"3rd item name is `third`:\", ok) ok = td.CmpJSONPointer(t, got, \"/Next/Next/Value\", td.Gte(int64(3))) fmt.Println(\"3rd item value is greater or equal than 3:\", ok) ok = td.CmpJSONPointer(t, got, \"/Next\", td.JSONPointer(\"/Next\", td.JSONPointer(\"/Value\", td.Gte(int64(3))))) fmt.Println(\"3rd item value is still greater or equal than 3:\", ok) ok = td.CmpJSONPointer(t, got, \"/Next/Next/Next/Name\", td.Ignore()) fmt.Println(\"4th item exists and has a name:\", ok) // Struct comparison work with or without pointer: \u0026Item{…} works too ok = td.CmpJSONPointer(t, got, \"/Next/Next\", Item{ Name: \"third\", Value: 3, }) fmt.Println(\"3rd item full comparison:\", ok) // Output: // 3rd item name is `third`: true // 3rd item value is greater or equal than 3: true // 3rd item value is still greater or equal than 3: true // 4th item exists and has a name: false // 3rd item full comparison: true Has_hasnt example t := \u0026testing.T{} got := json.RawMessage(` { \"name\": \"Bob\", \"age\": 42, \"children\": [ { \"name\": \"Alice\", \"age\": 16 }, { \"name\": \"Britt\", \"age\": 21, \"children\": [ { \"name\": \"John\", \"age\": 1 } ] } ] }`) // Has Bob some children? ok := td.CmpJSONPointer(t, got, \"/children\", td.Len(td.Gt(0))) fmt.Println(\"Bob has at least one child:\", ok) // But checking \"children\" exists is enough here ok = td.CmpJSONPointer(t, got, \"/children/0/children\", td.Ignore()) fmt.Println(\"Alice has children:\", ok) ok = td.CmpJSONPointer(t, got, \"/children/1/children\", td.Ignore()) fmt.Println(\"Britt has children:\", ok) // The reverse can be checked too ok = td.Cmp(t, got, td.Not(td.JSONPointer(\"/children/0/children\", td.Ignore()))) fmt.Println(\"Alice hasn't children:\", ok) ok = td.Cmp(t, got, td.Not(td.JSONPointer(\"/children/1/children\", td.Ignore()))) fmt.Println(\"Britt hasn't children:\", ok) // Output: // Bob has at least one child: true // Alice has children: false // Britt has children: true // Alice hasn't children: true // Britt hasn't children: false T.JSONPointer shortcut func (t *T) JSONPointer(got any, ptr string, expectedValue any, args ...any) bool JSONPointer is a shortcut for:\nt.Cmp(got, td.JSONPointer(ptr, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.JSONPointer godoc.\nExamples Rfc6901 example t := td.NewT(\u0026testing.T{}) got := json.RawMessage(` { \"foo\": [\"bar\", \"baz\"], \"\": 0, \"a/b\": 1, \"c%d\": 2, \"e^f\": 3, \"g|h\": 4, \"i\\\\j\": 5, \"k\\\"l\": 6, \" \": 7, \"m~n\": 8 }`) expected := map[string]any{ \"foo\": []any{\"bar\", \"baz\"}, \"\": 0, \"a/b\": 1, \"c%d\": 2, \"e^f\": 3, \"g|h\": 4, `i\\j`: 5, `k\"l`: 6, \" \": 7, \"m~n\": 8, } ok := t.JSONPointer(got, \"\", expected) fmt.Println(\"Empty JSON pointer means all:\", ok) ok = t.JSONPointer(got, `/foo`, []any{\"bar\", \"baz\"}) fmt.Println(\"Extract `foo` key:\", ok) ok = t.JSONPointer(got, `/foo/0`, \"bar\") fmt.Println(\"First item of `foo` key slice:\", ok) ok = t.JSONPointer(got, `/`, 0) fmt.Println(\"Empty key:\", ok) ok = t.JSONPointer(got, `/a~1b`, 1) fmt.Println(\"Slash has to be escaped using `~1`:\", ok) ok = t.JSONPointer(got, `/c%d`, 2) fmt.Println(\"% in key:\", ok) ok = t.JSONPointer(got, `/e^f`, 3) fmt.Println(\"^ in key:\", ok) ok = t.JSONPointer(got, `/g|h`, 4) fmt.Println(\"| in key:\", ok) ok = t.JSONPointer(got, `/i\\j`, 5) fmt.Println(\"Backslash in key:\", ok) ok = t.JSONPointer(got, `/k\"l`, 6) fmt.Println(\"Double-quote in key:\", ok) ok = t.JSONPointer(got, `/ `, 7) fmt.Println(\"Space key:\", ok) ok = t.JSONPointer(got, `/m~0n`, 8) fmt.Println(\"Tilde has to be escaped using `~0`:\", ok) // Output: // Empty JSON pointer means all: true // Extract `foo` key: true // First item of `foo` key slice: true // Empty key: true // Slash has to be escaped using `~1`: true // % in key: true // ^ in key: true // | in key: true // Backslash in key: true // Double-quote in key: true // Space key: true // Tilde has to be escaped using `~0`: true Struct example t := td.NewT(\u0026testing.T{}) // Without json tags, encoding/json uses public fields name type Item struct { Name string Value int64 Next *Item } got := Item{ Name: \"first\", Value: 1, Next: \u0026Item{ Name: \"second\", Value: 2, Next: \u0026Item{ Name: \"third\", Value: 3, }, }, } ok := t.JSONPointer(got, \"/Next/Next/Name\", \"third\") fmt.Println(\"3rd item name is `third`:\", ok) ok = t.JSONPointer(got, \"/Next/Next/Value\", td.Gte(int64(3))) fmt.Println(\"3rd item value is greater or equal than 3:\", ok) ok = t.JSONPointer(got, \"/Next\", td.JSONPointer(\"/Next\", td.JSONPointer(\"/Value\", td.Gte(int64(3))))) fmt.Println(\"3rd item value is still greater or equal than 3:\", ok) ok = t.JSONPointer(got, \"/Next/Next/Next/Name\", td.Ignore()) fmt.Println(\"4th item exists and has a name:\", ok) // Struct comparison work with or without pointer: \u0026Item{…} works too ok = t.JSONPointer(got, \"/Next/Next\", Item{ Name: \"third\", Value: 3, }) fmt.Println(\"3rd item full comparison:\", ok) // Output: // 3rd item name is `third`: true // 3rd item value is greater or equal than 3: true // 3rd item value is still greater or equal than 3: true // 4th item exists and has a name: false // 3rd item full comparison: true Has_hasnt example t := td.NewT(\u0026testing.T{}) got := json.RawMessage(` { \"name\": \"Bob\", \"age\": 42, \"children\": [ { \"name\": \"Alice\", \"age\": 16 }, { \"name\": \"Britt\", \"age\": 21, \"children\": [ { \"name\": \"John\", \"age\": 1 } ] } ] }`) // Has Bob some children? ok := t.JSONPointer(got, \"/children\", td.Len(td.Gt(0))) fmt.Println(\"Bob has at least one child:\", ok) // But checking \"children\" exists is enough here ok = t.JSONPointer(got, \"/children/0/children\", td.Ignore()) fmt.Println(\"Alice has children:\", ok) ok = t.JSONPointer(got, \"/children/1/children\", td.Ignore()) fmt.Println(\"Britt has children:\", ok) // The reverse can be checked too ok = t.Cmp(got, td.Not(td.JSONPointer(\"/children/0/children\", td.Ignore()))) fmt.Println(\"Alice hasn't children:\", ok) ok = t.Cmp(got, td.Not(td.JSONPointer(\"/children/1/children\", td.Ignore()))) fmt.Println(\"Britt hasn't children:\", ok) // Output: // Bob has at least one child: true // Alice has children: false // Britt has children: true // Alice hasn't children: true // Britt hasn't children: false",
    "description": "func JSONPointer(ptr string, expectedValue any) TestDeep JSONPointer is a smuggler operator. It takes the JSON representation of data, gets the value corresponding to the JSON pointer ptr (as RFC 6901 specifies it) and compares it to expectedValue.\nLax mode is automatically enabled to simplify numeric tests.\nJSONPointer does its best to convert back the JSON pointed data to the type of expectedValue or to the type behind the expectedValue operator, if it is an operator. Allowing to do things like:",
    "tags": [],
    "title": "JSONPointer",
    "uri": "/operators/jsonpointer/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Keys(val any) TestDeep Keys is a smuggler operator. It takes a map and compares its ordered keys to val.\nval can be a slice of items of the same type as the map keys:\ngot := map[string]bool{\"c\": true, \"a\": false, \"b\": true} td.Cmp(t, got, td.Keys([]string{\"a\", \"b\", \"c\"})) // succeeds, keys sorted td.Cmp(t, got, td.Keys([]string{\"c\", \"a\", \"b\"})) // fails as not sorted as well as an other operator as Bag, for example, to test keys in an unsorted manner:\ngot := map[string]bool{\"c\": true, \"a\": false, \"b\": true} td.Cmp(t, got, td.Keys(td.Bag(\"c\", \"a\", \"b\"))) // succeeds See also Values and ContainsKey.\nSee also Keys godoc.\nExample Base example t := \u0026testing.T{} got := map[string]int{\"foo\": 1, \"bar\": 2, \"zip\": 3} // Keys tests keys in an ordered manner ok := td.Cmp(t, got, td.Keys([]string{\"bar\", \"foo\", \"zip\"})) fmt.Println(\"All sorted keys are found:\", ok) // If the expected keys are not ordered, it fails ok = td.Cmp(t, got, td.Keys([]string{\"zip\", \"bar\", \"foo\"})) fmt.Println(\"All unsorted keys are found:\", ok) // To circumvent that, one can use Bag operator ok = td.Cmp(t, got, td.Keys(td.Bag(\"zip\", \"bar\", \"foo\"))) fmt.Println(\"All unsorted keys are found, with the help of Bag operator:\", ok) // Check that each key is 3 bytes long ok = td.Cmp(t, got, td.Keys(td.ArrayEach(td.Len(3)))) fmt.Println(\"Each key is 3 bytes long:\", ok) // Output: // All sorted keys are found: true // All unsorted keys are found: false // All unsorted keys are found, with the help of Bag operator: true // Each key is 3 bytes long: true CmpKeys shortcut func CmpKeys(t TestingT, got, val any, args ...any) bool CmpKeys is a shortcut for:\ntd.Cmp(t, got, td.Keys(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpKeys godoc.\nExample Base example t := \u0026testing.T{} got := map[string]int{\"foo\": 1, \"bar\": 2, \"zip\": 3} // Keys tests keys in an ordered manner ok := td.CmpKeys(t, got, []string{\"bar\", \"foo\", \"zip\"}) fmt.Println(\"All sorted keys are found:\", ok) // If the expected keys are not ordered, it fails ok = td.CmpKeys(t, got, []string{\"zip\", \"bar\", \"foo\"}) fmt.Println(\"All unsorted keys are found:\", ok) // To circumvent that, one can use Bag operator ok = td.CmpKeys(t, got, td.Bag(\"zip\", \"bar\", \"foo\")) fmt.Println(\"All unsorted keys are found, with the help of Bag operator:\", ok) // Check that each key is 3 bytes long ok = td.CmpKeys(t, got, td.ArrayEach(td.Len(3))) fmt.Println(\"Each key is 3 bytes long:\", ok) // Output: // All sorted keys are found: true // All unsorted keys are found: false // All unsorted keys are found, with the help of Bag operator: true // Each key is 3 bytes long: true T.Keys shortcut func (t *T) Keys(got, val any, args ...any) bool Keys is a shortcut for:\nt.Cmp(got, td.Keys(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Keys godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := map[string]int{\"foo\": 1, \"bar\": 2, \"zip\": 3} // Keys tests keys in an ordered manner ok := t.Keys(got, []string{\"bar\", \"foo\", \"zip\"}) fmt.Println(\"All sorted keys are found:\", ok) // If the expected keys are not ordered, it fails ok = t.Keys(got, []string{\"zip\", \"bar\", \"foo\"}) fmt.Println(\"All unsorted keys are found:\", ok) // To circumvent that, one can use Bag operator ok = t.Keys(got, td.Bag(\"zip\", \"bar\", \"foo\")) fmt.Println(\"All unsorted keys are found, with the help of Bag operator:\", ok) // Check that each key is 3 bytes long ok = t.Keys(got, td.ArrayEach(td.Len(3))) fmt.Println(\"Each key is 3 bytes long:\", ok) // Output: // All sorted keys are found: true // All unsorted keys are found: false // All unsorted keys are found, with the help of Bag operator: true // Each key is 3 bytes long: true",
    "description": "func Keys(val any) TestDeep Keys is a smuggler operator. It takes a map and compares its ordered keys to val.\nval can be a slice of items of the same type as the map keys:\ngot := map[string]bool{\"c\": true, \"a\": false, \"b\": true} td.Cmp(t, got, td.Keys([]string{\"a\", \"b\", \"c\"})) // succeeds, keys sorted td.Cmp(t, got, td.Keys([]string{\"c\", \"a\", \"b\"})) // fails as not sorted as well as an other operator as Bag, for example, to test keys in an unsorted manner:\ngot := map[string]bool{\"c\": true, \"a\": false, \"b\": true} td.Cmp(t, got, td.Keys(td.Bag(\"c\", \"a\", \"b\"))) // succeeds See also Values and ContainsKey.\nSee also Keys godoc.",
    "tags": [],
    "title": "Keys",
    "uri": "/operators/keys/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Last(filter, expectedValue any) TestDeep Last is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool. It takes the last item for which the filter matched and compares it to expectedValue. The filter matches when it is a:\nTestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can of course be a TestDeep operator.\ngot := []int{-3, -2, -1, 0, 1, 2, 3} td.Cmp(t, got, td.Last(td.Lt(0), -1)) // succeeds td.Cmp(t, got, td.Last(func(x int) bool { return x%2 == 0 }, 2)) // succeeds td.Cmp(t, got, td.Last(func(x int) bool { return x%2 == 0 }, td.Gt(0))) // succeeds If the input is empty (and/or nil for a slice), an “item not found” error is raised before comparing to expectedValue.\nvar got []int td.Cmp(t, got, td.Last(td.Gt(0), td.Gt(0))) // fails td.Cmp(t, []int{}, td.Last(td.Gt(0), td.Gt(0))) // fails td.Cmp(t, [0]int{}, td.Last(td.Gt(0), td.Gt(0))) // fails See also First and Grep.\nSee also Last godoc.\nExamples Classic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.Cmp(t, got, td.Last(td.Lt(0), -1)) fmt.Println(\"last negative number is -1:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = td.Cmp(t, got, td.Last(isEven, 2)) fmt.Println(\"last even number is 2:\", ok) ok = td.Cmp(t, got, td.Last(isEven, td.Gt(0))) fmt.Println(\"last even number is \u003e 0:\", ok) ok = td.Cmp(t, got, td.Last(isEven, td.Code(isEven))) fmt.Println(\"last even number is well even:\", ok) // Output: // last negative number is -1: true // last even number is 2: true // last even number is \u003e 0: true // last even number is well even: true Empty example t := \u0026testing.T{} ok := td.Cmp(t, ([]int)(nil), td.Last(td.Gt(0), td.Gt(0))) fmt.Println(\"last in nil slice:\", ok) ok = td.Cmp(t, []int{}, td.Last(td.Gt(0), td.Gt(0))) fmt.Println(\"last in empty slice:\", ok) ok = td.Cmp(t, \u0026[]int{}, td.Last(td.Gt(0), td.Gt(0))) fmt.Println(\"last in empty pointed slice:\", ok) ok = td.Cmp(t, [0]int{}, td.Last(td.Gt(0), td.Gt(0))) fmt.Println(\"last in empty array:\", ok) // Output: // last in nil slice: false // last in empty slice: false // last in empty pointed slice: false // last in empty array: false Struct example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 37, }, } ok := td.Cmp(t, got, td.Last( td.Smuggle(\"Age\", td.Gt(30)), td.Smuggle(\"Fullname\", \"Alice Bingo\"))) fmt.Println(\"last person.Age \u003e 30 → Alice:\", ok) ok = td.Cmp(t, got, td.Last( td.JSONPointer(\"/age\", td.Gt(30)), td.SuperJSONOf(`{\"fullname\":\"Alice Bingo\"}`))) fmt.Println(\"last person.Age \u003e 30 → Alice, using JSON:\", ok) ok = td.Cmp(t, got, td.Last( td.JSONPointer(\"/age\", td.Gt(30)), td.JSONPointer(\"/fullname\", td.HasPrefix(\"Alice\")))) fmt.Println(\"first person.Age \u003e 30 → Alice, using JSONPointer:\", ok) // Output: // last person.Age \u003e 30 → Alice: true // last person.Age \u003e 30 → Alice, using JSON: true // first person.Age \u003e 30 → Alice, using JSONPointer: true Json example t := \u0026testing.T{} got := map[string]any{ \"values\": []int{1, 2, 3, 4}, } ok := td.Cmp(t, got, td.JSON(`{\"values\": Last(Lt(3), 2)}`)) fmt.Println(\"last number \u003c 3:\", ok) got = map[string]any{ \"persons\": []map[string]any{ {\"id\": 1, \"name\": \"Joe\"}, {\"id\": 2, \"name\": \"Bob\"}, {\"id\": 3, \"name\": \"Alice\"}, {\"id\": 4, \"name\": \"Brian\"}, {\"id\": 5, \"name\": \"Britt\"}, }, } ok = td.Cmp(t, got, td.JSON(` { \"persons\": Last(JSONPointer(\"/name\", \"Brian\"), {\"id\": 4, \"name\": \"Brian\"}) }`)) fmt.Println(`is \"Brian\" content OK:`, ok) ok = td.Cmp(t, got, td.JSON(` { \"persons\": Last(JSONPointer(\"/name\", \"Brian\"), JSONPointer(\"/id\", 4)) }`)) fmt.Println(`ID of \"Brian\" is 4:`, ok) // Output: // last number \u003c 3: true // is \"Brian\" content OK: true // ID of \"Brian\" is 4: true CmpLast shortcut func CmpLast(t TestingT, got, filter , expectedValue any, args ...any) bool CmpLast is a shortcut for:\ntd.Cmp(t, got, td.Last(filter, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpLast godoc.\nExamples Classic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.CmpLast(t, got, td.Lt(0), -1) fmt.Println(\"last negative number is -1:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = td.CmpLast(t, got, isEven, 2) fmt.Println(\"last even number is 2:\", ok) ok = td.CmpLast(t, got, isEven, td.Gt(0)) fmt.Println(\"last even number is \u003e 0:\", ok) ok = td.CmpLast(t, got, isEven, td.Code(isEven)) fmt.Println(\"last even number is well even:\", ok) // Output: // last negative number is -1: true // last even number is 2: true // last even number is \u003e 0: true // last even number is well even: true Empty example t := \u0026testing.T{} ok := td.CmpLast(t, ([]int)(nil), td.Gt(0), td.Gt(0)) fmt.Println(\"last in nil slice:\", ok) ok = td.CmpLast(t, []int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"last in empty slice:\", ok) ok = td.CmpLast(t, \u0026[]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"last in empty pointed slice:\", ok) ok = td.CmpLast(t, [0]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"last in empty array:\", ok) // Output: // last in nil slice: false // last in empty slice: false // last in empty pointed slice: false // last in empty array: false Struct example t := \u0026testing.T{} type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 37, }, } ok := td.CmpLast(t, got, td.Smuggle(\"Age\", td.Gt(30)), td.Smuggle(\"Fullname\", \"Alice Bingo\")) fmt.Println(\"last person.Age \u003e 30 → Alice:\", ok) ok = td.CmpLast(t, got, td.JSONPointer(\"/age\", td.Gt(30)), td.SuperJSONOf(`{\"fullname\":\"Alice Bingo\"}`)) fmt.Println(\"last person.Age \u003e 30 → Alice, using JSON:\", ok) ok = td.CmpLast(t, got, td.JSONPointer(\"/age\", td.Gt(30)), td.JSONPointer(\"/fullname\", td.HasPrefix(\"Alice\"))) fmt.Println(\"first person.Age \u003e 30 → Alice, using JSONPointer:\", ok) // Output: // last person.Age \u003e 30 → Alice: true // last person.Age \u003e 30 → Alice, using JSON: true // first person.Age \u003e 30 → Alice, using JSONPointer: true T.Last shortcut func (t *T) Last(got, filter , expectedValue any, args ...any) bool Last is a shortcut for:\nt.Cmp(got, td.Last(filter, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Last godoc.\nExamples Classic example t := td.NewT(\u0026testing.T{}) got := []int{-3, -2, -1, 0, 1, 2, 3} ok := t.Last(got, td.Lt(0), -1) fmt.Println(\"last negative number is -1:\", ok) isEven := func(x int) bool { return x%2 == 0 } ok = t.Last(got, isEven, 2) fmt.Println(\"last even number is 2:\", ok) ok = t.Last(got, isEven, td.Gt(0)) fmt.Println(\"last even number is \u003e 0:\", ok) ok = t.Last(got, isEven, td.Code(isEven)) fmt.Println(\"last even number is well even:\", ok) // Output: // last negative number is -1: true // last even number is 2: true // last even number is \u003e 0: true // last even number is well even: true Empty example t := td.NewT(\u0026testing.T{}) ok := t.Last(([]int)(nil), td.Gt(0), td.Gt(0)) fmt.Println(\"last in nil slice:\", ok) ok = t.Last([]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"last in empty slice:\", ok) ok = t.Last(\u0026[]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"last in empty pointed slice:\", ok) ok = t.Last([0]int{}, td.Gt(0), td.Gt(0)) fmt.Println(\"last in empty array:\", ok) // Output: // last in nil slice: false // last in empty slice: false // last in empty pointed slice: false // last in empty array: false Struct example t := td.NewT(\u0026testing.T{}) type Person struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` } got := []*Person{ { Fullname: \"Bob Foobar\", Age: 42, }, { Fullname: \"Alice Bingo\", Age: 37, }, } ok := t.Last(got, td.Smuggle(\"Age\", td.Gt(30)), td.Smuggle(\"Fullname\", \"Alice Bingo\")) fmt.Println(\"last person.Age \u003e 30 → Alice:\", ok) ok = t.Last(got, td.JSONPointer(\"/age\", td.Gt(30)), td.SuperJSONOf(`{\"fullname\":\"Alice Bingo\"}`)) fmt.Println(\"last person.Age \u003e 30 → Alice, using JSON:\", ok) ok = t.Last(got, td.JSONPointer(\"/age\", td.Gt(30)), td.JSONPointer(\"/fullname\", td.HasPrefix(\"Alice\"))) fmt.Println(\"first person.Age \u003e 30 → Alice, using JSONPointer:\", ok) // Output: // last person.Age \u003e 30 → Alice: true // last person.Age \u003e 30 → Alice, using JSON: true // first person.Age \u003e 30 → Alice, using JSONPointer: true",
    "description": "func Last(filter, expectedValue any) TestDeep Last is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool. It takes the last item for which the filter matched and compares it to expectedValue. The filter matches when it is a:\nTestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can of course be a TestDeep operator.",
    "tags": [],
    "title": "Last",
    "uri": "/operators/last/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Lax(expectedValue any) TestDeep Lax is a smuggler operator, it temporarily enables the BeLax config flag before letting the comparison process continue its course.\nIt is more commonly used as CmpLax function than as an operator. It could be used when, for example, an operator is constructed once but applied to different, but compatible types as in:\nbw := td.Between(20, 30) intValue := 21 floatValue := 21.89 td.Cmp(t, intValue, bw) // no need to be lax here: same int types td.Cmp(t, floatValue, td.Lax(bw)) // be lax please, as float64 ≠ int Note that in the latter case, CmpLax could be used as well:\ntd.CmpLax(t, floatValue, bw) TypeBehind method returns the greatest convertible or more common reflect.Type of expectedValue if it is a base type (bool, int*, uint*, float*, complex*, string), the reflect.Type of expectedValue otherwise, except if expectedValue is a TestDeep operator. In this case, it delegates TypeBehind() to the operator.\nSee also Lax godoc.\nExample Base example t := \u0026testing.T{} gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := td.Between(1230, 1240) // int type here ok := td.Cmp(t, gotInt64, td.Lax(expected)) fmt.Println(\"int64 got between ints [1230 .. 1240]:\", ok) ok = td.Cmp(t, gotInt32, td.Lax(expected)) fmt.Println(\"int32 got between ints [1230 .. 1240]:\", ok) ok = td.Cmp(t, gotMyInt, td.Lax(expected)) fmt.Println(\"myInt got between ints [1230 .. 1240]:\", ok) // Output: // int64 got between ints [1230 .. 1240]: true // int32 got between ints [1230 .. 1240]: true // myInt got between ints [1230 .. 1240]: true CmpLax shortcut func CmpLax(t TestingT, got, expectedValue any, args ...any) bool CmpLax is a shortcut for:\ntd.Cmp(t, got, td.Lax(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpLax godoc.\nExample Base example t := \u0026testing.T{} gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := td.Between(1230, 1240) // int type here ok := td.CmpLax(t, gotInt64, expected) fmt.Println(\"int64 got between ints [1230 .. 1240]:\", ok) ok = td.CmpLax(t, gotInt32, expected) fmt.Println(\"int32 got between ints [1230 .. 1240]:\", ok) ok = td.CmpLax(t, gotMyInt, expected) fmt.Println(\"myInt got between ints [1230 .. 1240]:\", ok) // Output: // int64 got between ints [1230 .. 1240]: true // int32 got between ints [1230 .. 1240]: true // myInt got between ints [1230 .. 1240]: true T.CmpLax shortcut func (t *T) CmpLax(got, expectedValue any, args ...any) bool CmpLax is a shortcut for:\nt.Cmp(got, td.Lax(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.CmpLax godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := td.Between(1230, 1240) // int type here ok := t.CmpLax(gotInt64, expected) fmt.Println(\"int64 got between ints [1230 .. 1240]:\", ok) ok = t.CmpLax(gotInt32, expected) fmt.Println(\"int32 got between ints [1230 .. 1240]:\", ok) ok = t.CmpLax(gotMyInt, expected) fmt.Println(\"myInt got between ints [1230 .. 1240]:\", ok) // Output: // int64 got between ints [1230 .. 1240]: true // int32 got between ints [1230 .. 1240]: true // myInt got between ints [1230 .. 1240]: true",
    "description": "func Lax(expectedValue any) TestDeep Lax is a smuggler operator, it temporarily enables the BeLax config flag before letting the comparison process continue its course.\nIt is more commonly used as CmpLax function than as an operator. It could be used when, for example, an operator is constructed once but applied to different, but compatible types as in:\nbw := td.Between(20, 30) intValue := 21 floatValue := 21.89 td.Cmp(t, intValue, bw) // no need to be lax here: same int types td.Cmp(t, floatValue, td.Lax(bw)) // be lax please, as float64 ≠ int Note that in the latter case, CmpLax could be used as well:",
    "tags": [],
    "title": "Lax",
    "uri": "/operators/lax/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Len(expectedLen any) TestDeep Len is a smuggler operator. It takes data, applies len() function on it and compares its result to expectedLen. Of course, the compared value must be an array, a channel, a map, a slice or a string.\nexpectedLen can be an int value:\ntd.Cmp(t, gotSlice, td.Len(12)) as well as an other operator:\ntd.Cmp(t, gotSlice, td.Len(td.Between(3, 4))) See also Cap.\nSee also Len godoc.\nExamples Slice example t := \u0026testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(3), \"checks %v len is 3\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true Map example t := \u0026testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(3), \"checks %v len is 3\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true OperatorSlice example t := \u0026testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Lt(5)), \"checks %v len is \u003c 5\", got) fmt.Println(ok) // Output: // true // true OperatorMap example t := \u0026testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Gte(3)), \"checks %v len is ≥ 3\", got) fmt.Println(ok) // Output: // true // true CmpLen shortcut func CmpLen(t TestingT, got, expectedLen any, args ...any) bool CmpLen is a shortcut for:\ntd.Cmp(t, got, td.Len(expectedLen), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpLen godoc.\nExamples Slice example t := \u0026testing.T{} got := []int{11, 22, 33} ok := td.CmpLen(t, got, 3, \"checks %v len is 3\", got) fmt.Println(ok) ok = td.CmpLen(t, got, 0, \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = td.CmpLen(t, got, 0, \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true Map example t := \u0026testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.CmpLen(t, got, 3, \"checks %v len is 3\", got) fmt.Println(ok) ok = td.CmpLen(t, got, 0, \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = td.CmpLen(t, got, 0, \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true OperatorSlice example t := \u0026testing.T{} got := []int{11, 22, 33} ok := td.CmpLen(t, got, td.Between(3, 8), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = td.CmpLen(t, got, td.Lt(5), \"checks %v len is \u003c 5\", got) fmt.Println(ok) // Output: // true // true OperatorMap example t := \u0026testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.CmpLen(t, got, td.Between(3, 8), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = td.CmpLen(t, got, td.Gte(3), \"checks %v len is ≥ 3\", got) fmt.Println(ok) // Output: // true // true T.Len shortcut func (t *T) Len(got, expectedLen any, args ...any) bool Len is a shortcut for:\nt.Cmp(got, td.Len(expectedLen), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Len godoc.\nExamples Slice example t := td.NewT(\u0026testing.T{}) got := []int{11, 22, 33} ok := t.Len(got, 3, \"checks %v len is 3\", got) fmt.Println(ok) ok = t.Len(got, 0, \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = t.Len(got, 0, \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true Map example t := td.NewT(\u0026testing.T{}) got := map[int]bool{11: true, 22: false, 33: false} ok := t.Len(got, 3, \"checks %v len is 3\", got) fmt.Println(ok) ok = t.Len(got, 0, \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = t.Len(got, 0, \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true OperatorSlice example t := td.NewT(\u0026testing.T{}) got := []int{11, 22, 33} ok := t.Len(got, td.Between(3, 8), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = t.Len(got, td.Lt(5), \"checks %v len is \u003c 5\", got) fmt.Println(ok) // Output: // true // true OperatorMap example t := td.NewT(\u0026testing.T{}) got := map[int]bool{11: true, 22: false, 33: false} ok := t.Len(got, td.Between(3, 8), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = t.Len(got, td.Gte(3), \"checks %v len is ≥ 3\", got) fmt.Println(ok) // Output: // true // true",
    "description": "func Len(expectedLen any) TestDeep Len is a smuggler operator. It takes data, applies len() function on it and compares its result to expectedLen. Of course, the compared value must be an array, a channel, a map, a slice or a string.\nexpectedLen can be an int value:\ntd.Cmp(t, gotSlice, td.Len(12)) as well as an other operator:\ntd.Cmp(t, gotSlice, td.Len(td.Between(3, 4))) See also Cap.\nSee also Len godoc.\nExamples Slice example t := \u0026testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(3), \"checks %v len is 3\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true Map example t := \u0026testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(3), \"checks %v len is 3\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), \"checks %v len is 0\", got) fmt.Println(ok) // Output: // true // false // true OperatorSlice example t := \u0026testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Lt(5)), \"checks %v len is \u003c 5\", got) fmt.Println(ok) // Output: // true // true OperatorMap example t := \u0026testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), \"checks %v len is in [3 .. 8]\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Gte(3)), \"checks %v len is ≥ 3\", got) fmt.Println(ok) // Output: // true // true",
    "tags": [],
    "title": "Len",
    "uri": "/operators/len/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Lt(maxExpectedValue any) TestDeep Lt operator checks that data is lesser than maxExpectedValue. maxExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b maxExpectedValue must be the same type as the compared value, except if BeLax config flag is true.\ntd.Cmp(t, 17, td.Lt(19)) before := time.Now() td.Cmp(t, before, td.Lt(time.Now())) TypeBehind method returns the reflect.Type of maxExpectedValue.\nSee also Lt godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.Cmp(t, got, td.Lt(157), \"checks %v is \u003c 157\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lt(156), \"checks %v is \u003c 156\", got) fmt.Println(ok) // Output: // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.Cmp(t, got, td.Lt(\"abd\"), `checks \"%v\" is \u003c \"abd\"`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lt(\"abc\"), `checks \"%v\" is \u003c \"abc\"`, got) fmt.Println(ok) // Output: // true // false CmpLt shortcut func CmpLt(t TestingT, got, maxExpectedValue any, args ...any) bool CmpLt is a shortcut for:\ntd.Cmp(t, got, td.Lt(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpLt godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.CmpLt(t, got, 157, \"checks %v is \u003c 157\", got) fmt.Println(ok) ok = td.CmpLt(t, got, 156, \"checks %v is \u003c 156\", got) fmt.Println(ok) // Output: // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.CmpLt(t, got, \"abd\", `checks \"%v\" is \u003c \"abd\"`, got) fmt.Println(ok) ok = td.CmpLt(t, got, \"abc\", `checks \"%v\" is \u003c \"abc\"`, got) fmt.Println(ok) // Output: // true // false T.Lt shortcut func (t *T) Lt(got, maxExpectedValue any, args ...any) bool Lt is a shortcut for:\nt.Cmp(got, td.Lt(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Lt godoc.\nExamples Int example t := td.NewT(\u0026testing.T{}) got := 156 ok := t.Lt(got, 157, \"checks %v is \u003c 157\", got) fmt.Println(ok) ok = t.Lt(got, 156, \"checks %v is \u003c 156\", got) fmt.Println(ok) // Output: // true // false String example t := td.NewT(\u0026testing.T{}) got := \"abc\" ok := t.Lt(got, \"abd\", `checks \"%v\" is \u003c \"abd\"`, got) fmt.Println(ok) ok = t.Lt(got, \"abc\", `checks \"%v\" is \u003c \"abc\"`, got) fmt.Println(ok) // Output: // true // false",
    "description": "func Lt(maxExpectedValue any) TestDeep Lt operator checks that data is lesser than maxExpectedValue. maxExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b maxExpectedValue must be the same type as the compared value, except if BeLax config flag is true.",
    "tags": [],
    "title": "Lt",
    "uri": "/operators/lt/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Lte(maxExpectedValue any) TestDeep Lte operator checks that data is lesser or equal than maxExpectedValue. maxExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b maxExpectedValue must be the same type as the compared value, except if BeLax config flag is true.\ntd.Cmp(t, 17, td.Lte(17)) before := time.Now() td.Cmp(t, before, td.Lt(time.Now())) TypeBehind method returns the reflect.Type of maxExpectedValue.\nSee also Lte godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.Cmp(t, got, td.Lte(156), \"checks %v is ≤ 156\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(157), \"checks %v is ≤ 157\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(155), \"checks %v is ≤ 155\", got) fmt.Println(ok) // Output: // true // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.Cmp(t, got, td.Lte(\"abc\"), `checks \"%v\" is ≤ \"abc\"`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(\"abd\"), `checks \"%v\" is ≤ \"abd\"`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(\"abb\"), `checks \"%v\" is ≤ \"abb\"`, got) fmt.Println(ok) // Output: // true // true // false CmpLte shortcut func CmpLte(t TestingT, got, maxExpectedValue any, args ...any) bool CmpLte is a shortcut for:\ntd.Cmp(t, got, td.Lte(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpLte godoc.\nExamples Int example t := \u0026testing.T{} got := 156 ok := td.CmpLte(t, got, 156, \"checks %v is ≤ 156\", got) fmt.Println(ok) ok = td.CmpLte(t, got, 157, \"checks %v is ≤ 157\", got) fmt.Println(ok) ok = td.CmpLte(t, got, 155, \"checks %v is ≤ 155\", got) fmt.Println(ok) // Output: // true // true // false String example t := \u0026testing.T{} got := \"abc\" ok := td.CmpLte(t, got, \"abc\", `checks \"%v\" is ≤ \"abc\"`, got) fmt.Println(ok) ok = td.CmpLte(t, got, \"abd\", `checks \"%v\" is ≤ \"abd\"`, got) fmt.Println(ok) ok = td.CmpLte(t, got, \"abb\", `checks \"%v\" is ≤ \"abb\"`, got) fmt.Println(ok) // Output: // true // true // false T.Lte shortcut func (t *T) Lte(got, maxExpectedValue any, args ...any) bool Lte is a shortcut for:\nt.Cmp(got, td.Lte(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Lte godoc.\nExamples Int example t := td.NewT(\u0026testing.T{}) got := 156 ok := t.Lte(got, 156, \"checks %v is ≤ 156\", got) fmt.Println(ok) ok = t.Lte(got, 157, \"checks %v is ≤ 157\", got) fmt.Println(ok) ok = t.Lte(got, 155, \"checks %v is ≤ 155\", got) fmt.Println(ok) // Output: // true // true // false String example t := td.NewT(\u0026testing.T{}) got := \"abc\" ok := t.Lte(got, \"abc\", `checks \"%v\" is ≤ \"abc\"`, got) fmt.Println(ok) ok = t.Lte(got, \"abd\", `checks \"%v\" is ≤ \"abd\"`, got) fmt.Println(ok) ok = t.Lte(got, \"abb\", `checks \"%v\" is ≤ \"abb\"`, got) fmt.Println(ok) // Output: // true // true // false",
    "description": "func Lte(maxExpectedValue any) TestDeep Lte operator checks that data is lesser or equal than maxExpectedValue. maxExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:\nfunc (a T) Less(b T) bool // returns true if a \u003c b func (a T) Compare(b T) int // returns -1 if a \u003c b, 1 if a \u003e b, 0 if a == b maxExpectedValue must be the same type as the compared value, except if BeLax config flag is true.",
    "tags": [],
    "title": "Lte",
    "uri": "/operators/lte/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Map(model any, expectedEntries MapEntries) TestDeep Map operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nDuring a match, all expected entries must be found and all data entries must be expected to succeed.\ngot := map[string]string{ \"foo\": \"test\", \"bar\": \"wizz\", \"zip\": \"buzz\", } td.Cmp(t, got, td.Map( map[string]string{ \"foo\": \"test\", \"bar\": \"wizz\", }, td.MapEntries{ \"zip\": td.HasSuffix(\"zz\"), }), ) // succeeds TypeBehind method returns the reflect.Type of model.\nSee also SubMapOf and SuperMapOf.\nSee also Map godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.Map(map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks map %v\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Map(map[string]int{}, td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks map %v\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Map((map[string]int)(nil), td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks map %v\", got) fmt.Println(ok) // Output: // true // true // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.Map(MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks typed map %v\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Map(\u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks pointer on typed map %v\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Map(\u0026MyMap{}, td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks pointer on typed map %v\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Map((*MyMap)(nil), td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}), \"checks pointer on typed map %v\", got) fmt.Println(ok) // Output: // true // true // true // true CmpMap shortcut func CmpMap(t TestingT, got, model any, expectedEntries MapEntries, args ...any) bool CmpMap is a shortcut for:\ntd.Cmp(t, got, td.Map(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpMap godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.CmpMap(t, got, map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks map %v\", got) fmt.Println(ok) ok = td.CmpMap(t, got, map[string]int{}, td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks map %v\", got) fmt.Println(ok) ok = td.CmpMap(t, got, (map[string]int)(nil), td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks map %v\", got) fmt.Println(ok) // Output: // true // true // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.CmpMap(t, got, MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks typed map %v\", got) fmt.Println(ok) ok = td.CmpMap(t, \u0026got, \u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks pointer on typed map %v\", got) fmt.Println(ok) ok = td.CmpMap(t, \u0026got, \u0026MyMap{}, td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks pointer on typed map %v\", got) fmt.Println(ok) ok = td.CmpMap(t, \u0026got, (*MyMap)(nil), td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks pointer on typed map %v\", got) fmt.Println(ok) // Output: // true // true // true // true T.Map shortcut func (t *T) Map(got, model any, expectedEntries MapEntries, args ...any) bool Map is a shortcut for:\nt.Cmp(got, td.Map(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Map godoc.\nExamples Map example t := td.NewT(\u0026testing.T{}) got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := t.Map(got, map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks map %v\", got) fmt.Println(ok) ok = t.Map(got, map[string]int{}, td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks map %v\", got) fmt.Println(ok) ok = t.Map(got, (map[string]int)(nil), td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks map %v\", got) fmt.Println(ok) // Output: // true // true // true TypedMap example t := td.NewT(\u0026testing.T{}) type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := t.Map(got, MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks typed map %v\", got) fmt.Println(ok) ok = t.Map(\u0026got, \u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks pointer on typed map %v\", got) fmt.Println(ok) ok = t.Map(\u0026got, \u0026MyMap{}, td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks pointer on typed map %v\", got) fmt.Println(ok) ok = t.Map(\u0026got, (*MyMap)(nil), td.MapEntries{\"bar\": 42, \"foo\": td.Lt(15), \"zip\": td.Ignore()}, \"checks pointer on typed map %v\", got) fmt.Println(ok) // Output: // true // true // true // true",
    "description": "func Map(model any, expectedEntries MapEntries) TestDeep Map operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nDuring a match, all expected entries must be found and all data entries must be expected to succeed.\ngot := map[string]string{ \"foo\": \"test\", \"bar\": \"wizz\", \"zip\": \"buzz\", } td.Cmp(t, got, td.Map( map[string]string{ \"foo\": \"test\", \"bar\": \"wizz\", }, td.MapEntries{ \"zip\": td.HasSuffix(\"zz\"), }), ) // succeeds TypeBehind method returns the reflect.Type of model.",
    "tags": [],
    "title": "Map",
    "uri": "/operators/map/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func MapEach(expectedValue any) TestDeep MapEach operator has to be applied on maps. It compares each value of data map against expectedValue. During a match, all values have to match to succeed.\ngot := map[string]string{\"test\": \"foo\", \"buzz\": \"bar\"} td.Cmp(t, got, td.MapEach(\"bar\")) // fails, coz \"foo\" ≠ \"bar\" td.Cmp(t, got, td.MapEach(td.Len(3))) // succeeds as values are 3 chars long See also MapEach godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), \"checks each value of map %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), \"checks each value of typed map %v is in [10 .. 90]\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.MapEach(td.Between(10, 90)), \"checks each value of typed map pointer %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true // true CmpMapEach shortcut func CmpMapEach(t TestingT, got, expectedValue any, args ...any) bool CmpMapEach is a shortcut for:\ntd.Cmp(t, got, td.MapEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpMapEach godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.CmpMapEach(t, got, td.Between(10, 90), \"checks each value of map %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.CmpMapEach(t, got, td.Between(10, 90), \"checks each value of typed map %v is in [10 .. 90]\", got) fmt.Println(ok) ok = td.CmpMapEach(t, \u0026got, td.Between(10, 90), \"checks each value of typed map pointer %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true // true T.MapEach shortcut func (t *T) MapEach(got, expectedValue any, args ...any) bool MapEach is a shortcut for:\nt.Cmp(got, td.MapEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.MapEach godoc.\nExamples Map example t := td.NewT(\u0026testing.T{}) got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := t.MapEach(got, td.Between(10, 90), \"checks each value of map %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true TypedMap example t := td.NewT(\u0026testing.T{}) type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := t.MapEach(got, td.Between(10, 90), \"checks each value of typed map %v is in [10 .. 90]\", got) fmt.Println(ok) ok = t.MapEach(\u0026got, td.Between(10, 90), \"checks each value of typed map pointer %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true // true",
    "description": "func MapEach(expectedValue any) TestDeep MapEach operator has to be applied on maps. It compares each value of data map against expectedValue. During a match, all values have to match to succeed.\ngot := map[string]string{\"test\": \"foo\", \"buzz\": \"bar\"} td.Cmp(t, got, td.MapEach(\"bar\")) // fails, coz \"foo\" ≠ \"bar\" td.Cmp(t, got, td.MapEach(td.Len(3))) // succeeds as values are 3 chars long See also MapEach godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), \"checks each value of map %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), \"checks each value of typed map %v is in [10 .. 90]\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.MapEach(td.Between(10, 90)), \"checks each value of typed map pointer %v is in [10 .. 90]\", got) fmt.Println(ok) // Output: // true // true",
    "tags": [],
    "title": "MapEach",
    "uri": "/operators/mapeach/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func N(num any, tolerance ...any) TestDeep N operator compares a numeric data against num ± tolerance. If tolerance is missing, it defaults to 0. num and tolerance must be the same type as the compared value, except if BeLax config flag is true.\ntd.Cmp(t, 12.2, td.N(12., 0.3)) // succeeds td.Cmp(t, 12.2, td.N(12., 0.1)) // fails TypeBehind method returns the reflect.Type of num.\nSee also N godoc.\nExample Base example t := \u0026testing.T{} got := 1.12345 ok := td.Cmp(t, got, td.N(1.1234, 0.00006), \"checks %v = 1.1234 ± 0.00006\", got) fmt.Println(ok) // Output: // true CmpN shortcut func CmpN(t TestingT, got, num , tolerance any, args ...any) bool CmpN is a shortcut for:\ntd.Cmp(t, got, td.N(num, tolerance), args...) See above for details.\nN optional parameter tolerance is here mandatory. 0 value should be passed to mimic its absence in original N call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpN godoc.\nExample Base example t := \u0026testing.T{} got := 1.12345 ok := td.CmpN(t, got, 1.1234, 0.00006, \"checks %v = 1.1234 ± 0.00006\", got) fmt.Println(ok) // Output: // true T.N shortcut func (t *T) N(got, num , tolerance any, args ...any) bool N is a shortcut for:\nt.Cmp(got, td.N(num, tolerance), args...) See above for details.\nN optional parameter tolerance is here mandatory. 0 value should be passed to mimic its absence in original N call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.N godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := 1.12345 ok := t.N(got, 1.1234, 0.00006, \"checks %v = 1.1234 ± 0.00006\", got) fmt.Println(ok) // Output: // true",
    "description": "func N(num any, tolerance ...any) TestDeep N operator compares a numeric data against num ± tolerance. If tolerance is missing, it defaults to 0. num and tolerance must be the same type as the compared value, except if BeLax config flag is true.\ntd.Cmp(t, 12.2, td.N(12., 0.3)) // succeeds td.Cmp(t, 12.2, td.N(12., 0.1)) // fails TypeBehind method returns the reflect.Type of num.\nSee also N godoc.\nExample Base example t := \u0026testing.T{} got := 1.12345 ok := td.Cmp(t, got, td.N(1.1234, 0.00006), \"checks %v = 1.1234 ± 0.00006\", got) fmt.Println(ok) // Output: // true CmpN shortcut func CmpN(t TestingT, got, num , tolerance any, args ...any) bool CmpN is a shortcut for:",
    "tags": [],
    "title": "N",
    "uri": "/operators/n/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func NaN() TestDeep NaN operator checks that data is a float and is not-a-number.\ngot := math.NaN() td.Cmp(t, got, td.NaN()) // succeeds td.Cmp(t, 4.2, td.NaN()) // fails See also NotNaN.\nSee also NaN godoc.\nExamples Float32 example t := \u0026testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is float32 not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is float32 not-a-number: true // float32(12) is float32 not-a-number: false Float64 example t := \u0026testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"math.NaN() is not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float64(12) is not-a-number:\", ok) // Output: // math.NaN() is not-a-number: true // float64(12) is not-a-number: false CmpNaN shortcut func CmpNaN(t TestingT, got any, args ...any) bool CmpNaN is a shortcut for:\ntd.Cmp(t, got, td.NaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNaN godoc.\nExamples Float32 example t := \u0026testing.T{} got := float32(math.NaN()) ok := td.CmpNaN(t, got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is float32 not-a-number:\", ok) got = 12 ok = td.CmpNaN(t, got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is float32 not-a-number: true // float32(12) is float32 not-a-number: false Float64 example t := \u0026testing.T{} got := math.NaN() ok := td.CmpNaN(t, got, \"checks %v is not-a-number\", got) fmt.Println(\"math.NaN() is not-a-number:\", ok) got = 12 ok = td.CmpNaN(t, got, \"checks %v is not-a-number\", got) fmt.Println(\"float64(12) is not-a-number:\", ok) // Output: // math.NaN() is not-a-number: true // float64(12) is not-a-number: false T.NaN shortcut func (t *T) NaN(got any, args ...any) bool NaN is a shortcut for:\nt.Cmp(got, td.NaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.NaN godoc.\nExamples Float32 example t := td.NewT(\u0026testing.T{}) got := float32(math.NaN()) ok := t.NaN(got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is float32 not-a-number:\", ok) got = 12 ok = t.NaN(got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is float32 not-a-number: true // float32(12) is float32 not-a-number: false Float64 example t := td.NewT(\u0026testing.T{}) got := math.NaN() ok := t.NaN(got, \"checks %v is not-a-number\", got) fmt.Println(\"math.NaN() is not-a-number:\", ok) got = 12 ok = t.NaN(got, \"checks %v is not-a-number\", got) fmt.Println(\"float64(12) is not-a-number:\", ok) // Output: // math.NaN() is not-a-number: true // float64(12) is not-a-number: false",
    "description": "func NaN() TestDeep NaN operator checks that data is a float and is not-a-number.\ngot := math.NaN() td.Cmp(t, got, td.NaN()) // succeeds td.Cmp(t, 4.2, td.NaN()) // fails See also NotNaN.\nSee also NaN godoc.\nExamples Float32 example t := \u0026testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is float32 not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is float32 not-a-number: true // float32(12) is float32 not-a-number: false Float64 example t := \u0026testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"math.NaN() is not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float64(12) is not-a-number:\", ok) // Output: // math.NaN() is not-a-number: true // float64(12) is not-a-number: false",
    "tags": [],
    "title": "NaN",
    "uri": "/operators/nan/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Nil() TestDeep Nil operator checks that data is nil (or is a non-nil interface, but containing a nil pointer.)\nvar got *int td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails as (*int)(nil) ≠ untyped nil td.Cmp(t, got, (*int)(nil)) // succeeds but:\nvar got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails, as the interface is not nil got = nil td.Cmp(t, got, nil) // succeeds See also Empty, NotNil and Zero.\nSee also Nil godoc.\nExample Base example t := \u0026testing.T{} var got fmt.Stringer // interface // nil value can be compared directly with nil, no need of Nil() here ok := td.Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway ok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with nil fails, as the interface is not nil ok = td.Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed ok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) // Output: // true // true // false // true CmpNil shortcut func CmpNil(t TestingT, got any, args ...any) bool CmpNil is a shortcut for:\ntd.Cmp(t, got, td.Nil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNil godoc.\nExample Base example t := \u0026testing.T{} var got fmt.Stringer // interface // nil value can be compared directly with nil, no need of Nil() here ok := td.Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway ok = td.CmpNil(t, got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with nil fails, as the interface is not nil ok = td.Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed ok = td.CmpNil(t, got) fmt.Println(ok) // Output: // true // true // false // true T.Nil shortcut func (t *T) Nil(got any, args ...any) bool Nil is a shortcut for:\nt.Cmp(got, td.Nil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Nil godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) var got fmt.Stringer // interface // nil value can be compared directly with nil, no need of Nil() here ok := t.Cmp(got, nil) fmt.Println(ok) // But it works with Nil() anyway ok = t.Nil(got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with nil fails, as the interface is not nil ok = t.Cmp(got, nil) fmt.Println(ok) // In this case Nil() succeed ok = t.Nil(got) fmt.Println(ok) // Output: // true // true // false // true",
    "description": "func Nil() TestDeep Nil operator checks that data is nil (or is a non-nil interface, but containing a nil pointer.)\nvar got *int td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails as (*int)(nil) ≠ untyped nil td.Cmp(t, got, (*int)(nil)) // succeeds but:\nvar got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails, as the interface is not nil got = nil td.Cmp(t, got, nil) // succeeds See also Empty, NotNil and Zero.\nSee also Nil godoc.\nExample Base example t := \u0026testing.T{} var got fmt.Stringer // interface // nil value can be compared directly with nil, no need of Nil() here ok := td.Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway ok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with nil fails, as the interface is not nil ok = td.Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed ok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) // Output: // true // true // false // true CmpNil shortcut func CmpNil(t TestingT, got any, args ...any) bool CmpNil is a shortcut for:",
    "tags": [],
    "title": "Nil",
    "uri": "/operators/nil/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func None(notExpectedValues ...any) TestDeep None operator compares data against several not expected values. During a match, none of them have to match to succeed.\ntd.Cmp(t, 12, td.None(8, 10, 14)) // succeeds td.Cmp(t, 12, td.None(8, 10, 12, 14)) // fails Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nprime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) td.Cmp(t, 9, td.None(prime, even)) // succeeds See also All, Any and Not.\nSee also None godoc.\nExample Base example t := \u0026testing.T{} got := 18 ok := td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 20 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 142 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = td.Cmp(t, got, td.None(prime, even, td.Gt(14)), \"checks %v is not prime number, nor an even number and not \u003e 14\") fmt.Printf(\"%d → %t\\n\", got, ok) } // Output: // true // false // false // 9 → true // 3 → false // 8 → false // 15 → false CmpNone shortcut func CmpNone(t TestingT, got any, notExpectedValues []any, args ...any) bool CmpNone is a shortcut for:\ntd.Cmp(t, got, td.None(notExpectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNone godoc.\nExample Base example t := \u0026testing.T{} got := 18 ok := td.CmpNone(t, got, []any{0, 10, 20, 30, td.Between(100, 199)}, \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 20 ok = td.CmpNone(t, got, []any{0, 10, 20, 30, td.Between(100, 199)}, \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 142 ok = td.CmpNone(t, got, []any{0, 10, 20, 30, td.Between(100, 199)}, \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = td.CmpNone(t, got, []any{prime, even, td.Gt(14)}, \"checks %v is not prime number, nor an even number and not \u003e 14\") fmt.Printf(\"%d → %t\\n\", got, ok) } // Output: // true // false // false // 9 → true // 3 → false // 8 → false // 15 → false T.None shortcut func (t *T) None(got any, notExpectedValues []any, args ...any) bool None is a shortcut for:\nt.Cmp(got, td.None(notExpectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.None godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := 18 ok := t.None(got, []any{0, 10, 20, 30, td.Between(100, 199)}, \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 20 ok = t.None(got, []any{0, 10, 20, 30, td.Between(100, 199)}, \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 142 ok = t.None(got, []any{0, 10, 20, 30, td.Between(100, 199)}, \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = t.None(got, []any{prime, even, td.Gt(14)}, \"checks %v is not prime number, nor an even number and not \u003e 14\") fmt.Printf(\"%d → %t\\n\", got, ok) } // Output: // true // false // false // 9 → true // 3 → false // 8 → false // 15 → false",
    "description": "func None(notExpectedValues ...any) TestDeep None operator compares data against several not expected values. During a match, none of them have to match to succeed.\ntd.Cmp(t, 12, td.None(8, 10, 14)) // succeeds td.Cmp(t, 12, td.None(8, 10, 12, 14)) // fails Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nprime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) td.Cmp(t, 9, td.None(prime, even)) // succeeds See also All, Any and Not.\nSee also None godoc.\nExample Base example t := \u0026testing.T{} got := 18 ok := td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 20 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) got = 142 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \"checks %v is non-null, and ≠ 10, 20 \u0026 30, and not in [100-199]\", got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = td.Cmp(t, got, td.None(prime, even, td.Gt(14)), \"checks %v is not prime number, nor an even number and not \u003e 14\") fmt.Printf(\"%d → %t\\n\", got, ok) } // Output: // true // false // false // 9 → true // 3 → false // 8 → false // 15 → false CmpNone shortcut func CmpNone(t TestingT, got any, notExpectedValues []any, args ...any) bool CmpNone is a shortcut for:",
    "tags": [],
    "title": "None",
    "uri": "/operators/none/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Not(notExpected any) TestDeep Not operator compares data against the not expected value. During a match, it must not match to succeed.\nNot is the same operator as None with only one argument. It is provided as a more readable function when only one argument is needed.\ntd.Cmp(t, 12, td.Not(10)) // succeeds td.Cmp(t, 12, td.Not(12)) // fails See also None.\nSee also Not godoc.\nExample Base example t := \u0026testing.T{} got := 42 ok := td.Cmp(t, got, td.Not(0), \"checks %v is non-null\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Not(td.Between(10, 30)), \"checks %v is not in [10 .. 30]\", got) fmt.Println(ok) got = 0 ok = td.Cmp(t, got, td.Not(0), \"checks %v is non-null\", got) fmt.Println(ok) // Output: // true // true // false CmpNot shortcut func CmpNot(t TestingT, got, notExpected any, args ...any) bool CmpNot is a shortcut for:\ntd.Cmp(t, got, td.Not(notExpected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNot godoc.\nExample Base example t := \u0026testing.T{} got := 42 ok := td.CmpNot(t, got, 0, \"checks %v is non-null\", got) fmt.Println(ok) ok = td.CmpNot(t, got, td.Between(10, 30), \"checks %v is not in [10 .. 30]\", got) fmt.Println(ok) got = 0 ok = td.CmpNot(t, got, 0, \"checks %v is non-null\", got) fmt.Println(ok) // Output: // true // true // false T.Not shortcut func (t *T) Not(got, notExpected any, args ...any) bool Not is a shortcut for:\nt.Cmp(got, td.Not(notExpected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Not godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := 42 ok := t.Not(got, 0, \"checks %v is non-null\", got) fmt.Println(ok) ok = t.Not(got, td.Between(10, 30), \"checks %v is not in [10 .. 30]\", got) fmt.Println(ok) got = 0 ok = t.Not(got, 0, \"checks %v is non-null\", got) fmt.Println(ok) // Output: // true // true // false",
    "description": "func Not(notExpected any) TestDeep Not operator compares data against the not expected value. During a match, it must not match to succeed.\nNot is the same operator as None with only one argument. It is provided as a more readable function when only one argument is needed.\ntd.Cmp(t, 12, td.Not(10)) // succeeds td.Cmp(t, 12, td.Not(12)) // fails See also None.\nSee also Not godoc.\nExample Base example t := \u0026testing.T{} got := 42 ok := td.Cmp(t, got, td.Not(0), \"checks %v is non-null\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Not(td.Between(10, 30)), \"checks %v is not in [10 .. 30]\", got) fmt.Println(ok) got = 0 ok = td.Cmp(t, got, td.Not(0), \"checks %v is non-null\", got) fmt.Println(ok) // Output: // true // true // false CmpNot shortcut func CmpNot(t TestingT, got, notExpected any, args ...any) bool CmpNot is a shortcut for:",
    "tags": [],
    "title": "Not",
    "uri": "/operators/not/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func NotAny(notExpectedItems ...any) TestDeep NotAny operator checks that the contents of an array or a slice (or a pointer on array/slice) does not contain any of “notExpectedItems”.\ntd.Cmp(t, []int{1}, td.NotAny(1, 2, 3)) // fails td.Cmp(t, []int{5}, td.NotAny(1, 2, 3)) // succeeds // works with slices/arrays of any type td.Cmp(t, personSlice, td.NotAny( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nnotExpected := []int{2, 1} td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(td.Flatten(notExpected))) // succeeds // = td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(2, 1)) notExp1 := []int{2, 1} notExp2 := []int{5, 8} td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(td.Flatten(notExp1), 3, td.Flatten(notExp2))) // succeeds // = td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(2, 1, 3, 5, 8)) Beware that NotAny(…) is not equivalent to Not(Any(…)) but is like Not(SuperSet(…)).\nTypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa) and they are equal.\nSee also Set, SubSetOf and SuperSetOf.\nSee also NotAny godoc.\nExample Base example t := \u0026testing.T{} got := []int{4, 5, 9, 42} ok := td.Cmp(t, got, td.NotAny(3, 6, 8, 41, 43), \"checks %v contains no item listed in NotAny()\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.NotAny(3, 6, 8, 42, 43), \"checks %v contains no item listed in NotAny()\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using notExpected... without copying it to a new // []any slice, then use td.Flatten! notExpected := []int{3, 6, 8, 41, 43} ok = td.Cmp(t, got, td.NotAny(td.Flatten(notExpected)), \"checks %v contains no item listed in notExpected\", got) fmt.Println(ok) // Output: // true // false // true CmpNotAny shortcut func CmpNotAny(t TestingT, got any, notExpectedItems []any, args ...any) bool CmpNotAny is a shortcut for:\ntd.Cmp(t, got, td.NotAny(notExpectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNotAny godoc.\nExample Base example t := \u0026testing.T{} got := []int{4, 5, 9, 42} ok := td.CmpNotAny(t, got, []any{3, 6, 8, 41, 43}, \"checks %v contains no item listed in NotAny()\", got) fmt.Println(ok) ok = td.CmpNotAny(t, got, []any{3, 6, 8, 42, 43}, \"checks %v contains no item listed in NotAny()\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using notExpected... without copying it to a new // []any slice, then use td.Flatten! notExpected := []int{3, 6, 8, 41, 43} ok = td.CmpNotAny(t, got, []any{td.Flatten(notExpected)}, \"checks %v contains no item listed in notExpected\", got) fmt.Println(ok) // Output: // true // false // true T.NotAny shortcut func (t *T) NotAny(got any, notExpectedItems []any, args ...any) bool NotAny is a shortcut for:\nt.Cmp(got, td.NotAny(notExpectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.NotAny godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{4, 5, 9, 42} ok := t.NotAny(got, []any{3, 6, 8, 41, 43}, \"checks %v contains no item listed in NotAny()\", got) fmt.Println(ok) ok = t.NotAny(got, []any{3, 6, 8, 42, 43}, \"checks %v contains no item listed in NotAny()\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using notExpected... without copying it to a new // []any slice, then use td.Flatten! notExpected := []int{3, 6, 8, 41, 43} ok = t.NotAny(got, []any{td.Flatten(notExpected)}, \"checks %v contains no item listed in notExpected\", got) fmt.Println(ok) // Output: // true // false // true",
    "description": "func NotAny(notExpectedItems ...any) TestDeep NotAny operator checks that the contents of an array or a slice (or a pointer on array/slice) does not contain any of “notExpectedItems”.\ntd.Cmp(t, []int{1}, td.NotAny(1, 2, 3)) // fails td.Cmp(t, []int{5}, td.NotAny(1, 2, 3)) // succeeds // works with slices/arrays of any type td.Cmp(t, personSlice, td.NotAny( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nnotExpected := []int{2, 1} td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(td.Flatten(notExpected))) // succeeds // = td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(2, 1)) notExp1 := []int{2, 1} notExp2 := []int{5, 8} td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(td.Flatten(notExp1), 3, td.Flatten(notExp2))) // succeeds // = td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(2, 1, 3, 5, 8)) Beware that NotAny(…) is not equivalent to Not(Any(…)) but is like Not(SuperSet(…)).",
    "tags": [],
    "title": "NotAny",
    "uri": "/operators/notany/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func NotEmpty() TestDeep NotEmpty operator checks that an array, a channel, a map, a slice or a string is not empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\ntd.Cmp(t, \"\", td.NotEmpty()) // fails td.Cmp(t, map[string]bool{}, td.NotEmpty()) // fails td.Cmp(t, []string{\"foo\"}, td.NotEmpty()) // succeeds See also NotEmpty godoc.\nExamples Base example t := \u0026testing.T{} ok := td.Cmp(t, nil, td.NotEmpty()) // fails, as nil is considered empty fmt.Println(ok) ok = td.Cmp(t, \"foobar\", td.NotEmpty()) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead ok = td.Cmp(t, 0, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, map[string]int{\"foobar\": 42}, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, []int{1}, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.NotEmpty()) // succeeds, NotEmpty() is not NotZero()! fmt.Println(ok) // Output: // false // true // false // true // true // true Pointers example t := \u0026testing.T{} type MySlice []int ok := td.Cmp(t, MySlice{12}, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, \u0026MySlice{12}, td.NotEmpty()) // Ptr() not needed fmt.Println(ok) l1 := \u0026MySlice{12} l2 := \u0026l1 l3 := \u0026l2 ok = td.Cmp(t, \u0026l3, td.NotEmpty()) fmt.Println(ok) // Works the same for array, map, channel and string // But not for others types as: type MyStruct struct { Value int } ok = td.Cmp(t, \u0026MyStruct{}, td.NotEmpty()) // fails, use NotZero() instead fmt.Println(ok) // Output: // true // true // true // false CmpNotEmpty shortcut func CmpNotEmpty(t TestingT, got any, args ...any) bool CmpNotEmpty is a shortcut for:\ntd.Cmp(t, got, td.NotEmpty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNotEmpty godoc.\nExamples Base example t := \u0026testing.T{} ok := td.CmpNotEmpty(t, nil) // fails, as nil is considered empty fmt.Println(ok) ok = td.CmpNotEmpty(t, \"foobar\") fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead ok = td.CmpNotEmpty(t, 0) fmt.Println(ok) ok = td.CmpNotEmpty(t, map[string]int{\"foobar\": 42}) fmt.Println(ok) ok = td.CmpNotEmpty(t, []int{1}) fmt.Println(ok) ok = td.CmpNotEmpty(t, [3]int{}) // succeeds, NotEmpty() is not NotZero()! fmt.Println(ok) // Output: // false // true // false // true // true // true Pointers example t := \u0026testing.T{} type MySlice []int ok := td.CmpNotEmpty(t, MySlice{12}) fmt.Println(ok) ok = td.CmpNotEmpty(t, \u0026MySlice{12}) // Ptr() not needed fmt.Println(ok) l1 := \u0026MySlice{12} l2 := \u0026l1 l3 := \u0026l2 ok = td.CmpNotEmpty(t, \u0026l3) fmt.Println(ok) // Works the same for array, map, channel and string // But not for others types as: type MyStruct struct { Value int } ok = td.CmpNotEmpty(t, \u0026MyStruct{}) // fails, use NotZero() instead fmt.Println(ok) // Output: // true // true // true // false T.NotEmpty shortcut func (t *T) NotEmpty(got any, args ...any) bool NotEmpty is a shortcut for:\nt.Cmp(got, td.NotEmpty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.NotEmpty godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) ok := t.NotEmpty(nil) // fails, as nil is considered empty fmt.Println(ok) ok = t.NotEmpty(\"foobar\") fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead ok = t.NotEmpty(0) fmt.Println(ok) ok = t.NotEmpty(map[string]int{\"foobar\": 42}) fmt.Println(ok) ok = t.NotEmpty([]int{1}) fmt.Println(ok) ok = t.NotEmpty([3]int{}) // succeeds, NotEmpty() is not NotZero()! fmt.Println(ok) // Output: // false // true // false // true // true // true Pointers example t := td.NewT(\u0026testing.T{}) type MySlice []int ok := t.NotEmpty(MySlice{12}) fmt.Println(ok) ok = t.NotEmpty(\u0026MySlice{12}) // Ptr() not needed fmt.Println(ok) l1 := \u0026MySlice{12} l2 := \u0026l1 l3 := \u0026l2 ok = t.NotEmpty(\u0026l3) fmt.Println(ok) // Works the same for array, map, channel and string // But not for others types as: type MyStruct struct { Value int } ok = t.NotEmpty(\u0026MyStruct{}) // fails, use NotZero() instead fmt.Println(ok) // Output: // true // true // true // false",
    "description": "func NotEmpty() TestDeep NotEmpty operator checks that an array, a channel, a map, a slice or a string is not empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\ntd.Cmp(t, \"\", td.NotEmpty()) // fails td.Cmp(t, map[string]bool{}, td.NotEmpty()) // fails td.Cmp(t, []string{\"foo\"}, td.NotEmpty()) // succeeds See also NotEmpty godoc.",
    "tags": [],
    "title": "NotEmpty",
    "uri": "/operators/notempty/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func NotNaN() TestDeep NotNaN operator checks that data is a float and is not not-a-number.\ngot := math.NaN() td.Cmp(t, got, td.NotNaN()) // fails td.Cmp(t, 4.2, td.NotNaN()) // succeeds td.Cmp(t, 4, td.NotNaN()) // fails, as 4 is not a float See also NaN.\nSee also NotNaN godoc.\nExamples Float32 example t := \u0026testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NotNaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is NOT float32 not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is NOT float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is NOT float32 not-a-number: false // float32(12) is NOT float32 not-a-number: true Float64 example t := \u0026testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NotNaN(), \"checks %v is NOT not-a-number\", got) fmt.Println(\"math.NaN() is NOT not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), \"checks %v is NOT not-a-number\", got) fmt.Println(\"float64(12) is NOT not-a-number:\", ok) // Output: // math.NaN() is NOT not-a-number: false // float64(12) is NOT not-a-number: true CmpNotNaN shortcut func CmpNotNaN(t TestingT, got any, args ...any) bool CmpNotNaN is a shortcut for:\ntd.Cmp(t, got, td.NotNaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNotNaN godoc.\nExamples Float32 example t := \u0026testing.T{} got := float32(math.NaN()) ok := td.CmpNotNaN(t, got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is NOT float32 not-a-number:\", ok) got = 12 ok = td.CmpNotNaN(t, got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is NOT float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is NOT float32 not-a-number: false // float32(12) is NOT float32 not-a-number: true Float64 example t := \u0026testing.T{} got := math.NaN() ok := td.CmpNotNaN(t, got, \"checks %v is NOT not-a-number\", got) fmt.Println(\"math.NaN() is NOT not-a-number:\", ok) got = 12 ok = td.CmpNotNaN(t, got, \"checks %v is NOT not-a-number\", got) fmt.Println(\"float64(12) is NOT not-a-number:\", ok) // Output: // math.NaN() is NOT not-a-number: false // float64(12) is NOT not-a-number: true T.NotNaN shortcut func (t *T) NotNaN(got any, args ...any) bool NotNaN is a shortcut for:\nt.Cmp(got, td.NotNaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.NotNaN godoc.\nExamples Float32 example t := td.NewT(\u0026testing.T{}) got := float32(math.NaN()) ok := t.NotNaN(got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is NOT float32 not-a-number:\", ok) got = 12 ok = t.NotNaN(got, \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is NOT float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is NOT float32 not-a-number: false // float32(12) is NOT float32 not-a-number: true Float64 example t := td.NewT(\u0026testing.T{}) got := math.NaN() ok := t.NotNaN(got, \"checks %v is NOT not-a-number\", got) fmt.Println(\"math.NaN() is NOT not-a-number:\", ok) got = 12 ok = t.NotNaN(got, \"checks %v is NOT not-a-number\", got) fmt.Println(\"float64(12) is NOT not-a-number:\", ok) // Output: // math.NaN() is NOT not-a-number: false // float64(12) is NOT not-a-number: true",
    "description": "func NotNaN() TestDeep NotNaN operator checks that data is a float and is not not-a-number.\ngot := math.NaN() td.Cmp(t, got, td.NotNaN()) // fails td.Cmp(t, 4.2, td.NotNaN()) // succeeds td.Cmp(t, 4, td.NotNaN()) // fails, as 4 is not a float See also NaN.\nSee also NotNaN godoc.\nExamples Float32 example t := \u0026testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NotNaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(math.NaN()) is NOT float32 not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), \"checks %v is not-a-number\", got) fmt.Println(\"float32(12) is NOT float32 not-a-number:\", ok) // Output: // float32(math.NaN()) is NOT float32 not-a-number: false // float32(12) is NOT float32 not-a-number: true Float64 example t := \u0026testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NotNaN(), \"checks %v is NOT not-a-number\", got) fmt.Println(\"math.NaN() is NOT not-a-number:\", ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), \"checks %v is NOT not-a-number\", got) fmt.Println(\"float64(12) is NOT not-a-number:\", ok) // Output: // math.NaN() is NOT not-a-number: false // float64(12) is NOT not-a-number: true",
    "tags": [],
    "title": "NotNaN",
    "uri": "/operators/notnan/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func NotNil() TestDeep NotNil operator checks that data is not nil (or is a non-nil interface, containing a non-nil pointer.)\ngot := \u0026Person{} td.Cmp(t, got, td.NotNil()) // succeeds td.Cmp(t, got, td.Not(nil)) // succeeds too, but be careful it is first // because of got type *Person ≠ untyped nil so prefer NotNil() but:\nvar got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.NotNil()) // fails td.Cmp(t, got, td.Not(nil)) // succeeds, as the interface is not nil See also Nil, NotEmpty and NotZero.\nSee also NotNil godoc.\nExample Base example t := \u0026testing.T{} var got fmt.Stringer = \u0026bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here ok := td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway ok = td.Cmp(t, got, td.NotNil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with Not(nil) succeeds, as the interface is not nil ok = td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // In this case NotNil() fails ok = td.Cmp(t, got, td.NotNil()) fmt.Println(ok) // Output: // true // true // true // false CmpNotNil shortcut func CmpNotNil(t TestingT, got any, args ...any) bool CmpNotNil is a shortcut for:\ntd.Cmp(t, got, td.NotNil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNotNil godoc.\nExample Base example t := \u0026testing.T{} var got fmt.Stringer = \u0026bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here ok := td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway ok = td.CmpNotNil(t, got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with Not(nil) succeeds, as the interface is not nil ok = td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // In this case NotNil() fails ok = td.CmpNotNil(t, got) fmt.Println(ok) // Output: // true // true // true // false T.NotNil shortcut func (t *T) NotNil(got any, args ...any) bool NotNil is a shortcut for:\nt.Cmp(got, td.NotNil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.NotNil godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) var got fmt.Stringer = \u0026bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here ok := t.Cmp(got, td.Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway ok = t.NotNil(got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with Not(nil) succeeds, as the interface is not nil ok = t.Cmp(got, td.Not(nil)) fmt.Println(ok) // In this case NotNil() fails ok = t.NotNil(got) fmt.Println(ok) // Output: // true // true // true // false",
    "description": "func NotNil() TestDeep NotNil operator checks that data is not nil (or is a non-nil interface, containing a non-nil pointer.)\ngot := \u0026Person{} td.Cmp(t, got, td.NotNil()) // succeeds td.Cmp(t, got, td.Not(nil)) // succeeds too, but be careful it is first // because of got type *Person ≠ untyped nil so prefer NotNil() but:\nvar got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.NotNil()) // fails td.Cmp(t, got, td.Not(nil)) // succeeds, as the interface is not nil See also Nil, NotEmpty and NotZero.\nSee also NotNil godoc.",
    "tags": [],
    "title": "NotNil",
    "uri": "/operators/notnil/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func NotZero() TestDeep NotZero operator checks that data is not zero regarding its type.\nnil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \"\" is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized. Beware that:\ntd.Cmp(t, AnyStruct{}, td.NotZero()) // is false td.Cmp(t, \u0026AnyStruct{}, td.NotZero()) // is true, coz pointer ≠ nil td.Cmp(t, \u0026AnyStruct{}, td.Ptr(td.NotZero())) // is false See also NotEmpty, NotNil and Zero.\nSee also NotZero godoc.\nExample Base example t := \u0026testing.T{} ok := td.Cmp(t, 0, td.NotZero()) // fails fmt.Println(ok) ok = td.Cmp(t, float64(0), td.NotZero()) // fails fmt.Println(ok) ok = td.Cmp(t, 12, td.NotZero()) fmt.Println(ok) ok = td.Cmp(t, (map[string]int)(nil), td.NotZero()) // fails, as nil fmt.Println(ok) ok = td.Cmp(t, map[string]int{}, td.NotZero()) // succeeds, as not nil fmt.Println(ok) ok = td.Cmp(t, ([]int)(nil), td.NotZero()) // fails, as nil fmt.Println(ok) ok = td.Cmp(t, []int{}, td.NotZero()) // succeeds, as not nil fmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.NotZero()) // fails fmt.Println(ok) ok = td.Cmp(t, [3]int{0, 1}, td.NotZero()) // succeeds, DATA[1] is not 0 fmt.Println(ok) ok = td.Cmp(t, bytes.Buffer{}, td.NotZero()) // fails fmt.Println(ok) ok = td.Cmp(t, \u0026bytes.Buffer{}, td.NotZero()) // succeeds, as pointer not nil fmt.Println(ok) ok = td.Cmp(t, \u0026bytes.Buffer{}, td.Ptr(td.NotZero())) // fails as deref by Ptr() fmt.Println(ok) // Output: // false // false // true // false // true // false // true // false // true // false // true // false CmpNotZero shortcut func CmpNotZero(t TestingT, got any, args ...any) bool CmpNotZero is a shortcut for:\ntd.Cmp(t, got, td.NotZero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpNotZero godoc.\nExample Base example t := \u0026testing.T{} ok := td.CmpNotZero(t, 0) // fails fmt.Println(ok) ok = td.CmpNotZero(t, float64(0)) // fails fmt.Println(ok) ok = td.CmpNotZero(t, 12) fmt.Println(ok) ok = td.CmpNotZero(t, (map[string]int)(nil)) // fails, as nil fmt.Println(ok) ok = td.CmpNotZero(t, map[string]int{}) // succeeds, as not nil fmt.Println(ok) ok = td.CmpNotZero(t, ([]int)(nil)) // fails, as nil fmt.Println(ok) ok = td.CmpNotZero(t, []int{}) // succeeds, as not nil fmt.Println(ok) ok = td.CmpNotZero(t, [3]int{}) // fails fmt.Println(ok) ok = td.CmpNotZero(t, [3]int{0, 1}) // succeeds, DATA[1] is not 0 fmt.Println(ok) ok = td.CmpNotZero(t, bytes.Buffer{}) // fails fmt.Println(ok) ok = td.CmpNotZero(t, \u0026bytes.Buffer{}) // succeeds, as pointer not nil fmt.Println(ok) ok = td.Cmp(t, \u0026bytes.Buffer{}, td.Ptr(td.NotZero())) // fails as deref by Ptr() fmt.Println(ok) // Output: // false // false // true // false // true // false // true // false // true // false // true // false T.NotZero shortcut func (t *T) NotZero(got any, args ...any) bool NotZero is a shortcut for:\nt.Cmp(got, td.NotZero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.NotZero godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) ok := t.NotZero(0) // fails fmt.Println(ok) ok = t.NotZero(float64(0)) // fails fmt.Println(ok) ok = t.NotZero(12) fmt.Println(ok) ok = t.NotZero((map[string]int)(nil)) // fails, as nil fmt.Println(ok) ok = t.NotZero(map[string]int{}) // succeeds, as not nil fmt.Println(ok) ok = t.NotZero(([]int)(nil)) // fails, as nil fmt.Println(ok) ok = t.NotZero([]int{}) // succeeds, as not nil fmt.Println(ok) ok = t.NotZero([3]int{}) // fails fmt.Println(ok) ok = t.NotZero([3]int{0, 1}) // succeeds, DATA[1] is not 0 fmt.Println(ok) ok = t.NotZero(bytes.Buffer{}) // fails fmt.Println(ok) ok = t.NotZero(\u0026bytes.Buffer{}) // succeeds, as pointer not nil fmt.Println(ok) ok = t.Cmp(\u0026bytes.Buffer{}, td.Ptr(td.NotZero())) // fails as deref by Ptr() fmt.Println(ok) // Output: // false // false // true // false // true // false // true // false // true // false // true // false",
    "description": "func NotZero() TestDeep NotZero operator checks that data is not zero regarding its type.\nnil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \"\" is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized. Beware that:\ntd.Cmp(t, AnyStruct{}, td.NotZero()) // is false td.Cmp(t, \u0026AnyStruct{}, td.NotZero()) // is true, coz pointer ≠ nil td.Cmp(t, \u0026AnyStruct{}, td.Ptr(td.NotZero())) // is false See also NotEmpty, NotNil and Zero.",
    "tags": [],
    "title": "NotZero",
    "uri": "/operators/notzero/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func PPtr(val any) TestDeep PPtr is a smuggler operator. It takes the address of the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an **int, one can have:\nnum := 12 pnum = \u0026num td.Cmp(t, \u0026pnum, td.PPtr(12)) // succeeds as well as an other operator:\nnum := 3 pnum = \u0026num td.Cmp(t, \u0026pnum, td.PPtr(td.Between(3, 4))) // succeeds It is more efficient and shorter to write than:\ntd.Cmp(t, \u0026pnum, td.Ptr(td.Ptr(val))) // succeeds too TypeBehind method returns the reflect.Type of a pointer on a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on a pointer on the returned value (if non-nil of course).\nSee also Ptr.\nSee also PPtr godoc.\nExample Base example t := \u0026testing.T{} num := 12 got := \u0026num ok := td.Cmp(t, \u0026got, td.PPtr(12)) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.PPtr(td.Between(4, 15))) fmt.Println(ok) // Output: // true // true CmpPPtr shortcut func CmpPPtr(t TestingT, got, val any, args ...any) bool CmpPPtr is a shortcut for:\ntd.Cmp(t, got, td.PPtr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpPPtr godoc.\nExample Base example t := \u0026testing.T{} num := 12 got := \u0026num ok := td.CmpPPtr(t, \u0026got, 12) fmt.Println(ok) ok = td.CmpPPtr(t, \u0026got, td.Between(4, 15)) fmt.Println(ok) // Output: // true // true T.PPtr shortcut func (t *T) PPtr(got, val any, args ...any) bool PPtr is a shortcut for:\nt.Cmp(got, td.PPtr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.PPtr godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) num := 12 got := \u0026num ok := t.PPtr(\u0026got, 12) fmt.Println(ok) ok = t.PPtr(\u0026got, td.Between(4, 15)) fmt.Println(ok) // Output: // true // true",
    "description": "func PPtr(val any) TestDeep PPtr is a smuggler operator. It takes the address of the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an **int, one can have:\nnum := 12 pnum = \u0026num td.Cmp(t, \u0026pnum, td.PPtr(12)) // succeeds as well as an other operator:\nnum := 3 pnum = \u0026num td.Cmp(t, \u0026pnum, td.PPtr(td.Between(3, 4))) // succeeds It is more efficient and shorter to write than:\ntd.Cmp(t, \u0026pnum, td.Ptr(td.Ptr(val))) // succeeds too TypeBehind method returns the reflect.Type of a pointer on a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on a pointer on the returned value (if non-nil of course).",
    "tags": [],
    "title": "PPtr",
    "uri": "/operators/pptr/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Ptr(val any) TestDeep Ptr is a smuggler operator. It takes the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an *int, one can have:\nnum := 12 td.Cmp(t, \u0026num, td.Ptr(12)) // succeeds as well as an other operator:\nnum := 3 td.Cmp(t, \u0026num, td.Ptr(td.Between(3, 4))) TypeBehind method returns the reflect.Type of a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on the returned value (if non-nil of course).\nSee also PPtr and Shallow.\nSee also Ptr godoc.\nExample Base example t := \u0026testing.T{} got := 12 ok := td.Cmp(t, \u0026got, td.Ptr(12)) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Ptr(td.Between(4, 15))) fmt.Println(ok) // Output: // true // true CmpPtr shortcut func CmpPtr(t TestingT, got, val any, args ...any) bool CmpPtr is a shortcut for:\ntd.Cmp(t, got, td.Ptr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpPtr godoc.\nExample Base example t := \u0026testing.T{} got := 12 ok := td.CmpPtr(t, \u0026got, 12) fmt.Println(ok) ok = td.CmpPtr(t, \u0026got, td.Between(4, 15)) fmt.Println(ok) // Output: // true // true T.Ptr shortcut func (t *T) Ptr(got, val any, args ...any) bool Ptr is a shortcut for:\nt.Cmp(got, td.Ptr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Ptr godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := 12 ok := t.Ptr(\u0026got, 12) fmt.Println(ok) ok = t.Ptr(\u0026got, td.Between(4, 15)) fmt.Println(ok) // Output: // true // true",
    "description": "func Ptr(val any) TestDeep Ptr is a smuggler operator. It takes the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an *int, one can have:\nnum := 12 td.Cmp(t, \u0026num, td.Ptr(12)) // succeeds as well as an other operator:\nnum := 3 td.Cmp(t, \u0026num, td.Ptr(td.Between(3, 4))) TypeBehind method returns the reflect.Type of a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on the returned value (if non-nil of course).",
    "tags": [],
    "title": "Ptr",
    "uri": "/operators/ptr/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Re(reg any, capture ...any) TestDeep Re operator allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\nreg is the regexp. It can be a string that is automatically compiled using regexp.Compile, or a *regexp.Regexp.\nOptional capture parameter can be used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.\ntd.Cmp(t, \"foobar zip!\", td.Re(`^foobar`)) // succeeds td.Cmp(t, \"John Doe\", td.Re(`^(\\w+) (\\w+)`, []string{\"John\", \"Doe\"})) // succeeds td.Cmp(t, \"John Doe\", td.Re(`^(\\w+) (\\w+)`, td.Bag(\"Doe\", \"John\"))) // succeeds See also ReAll.\nSee also Re godoc.\nExamples Base example t := \u0026testing.T{} got := \"foo bar\" ok := td.Cmp(t, got, td.Re(\"(zip|bar)$\"), \"checks value %s\", got) fmt.Println(ok) got = \"bar foo\" ok = td.Cmp(t, got, td.Re(\"(zip|bar)$\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foo bar\") ok := td.Cmp(t, got, td.Re(\"(zip|bar)$\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foo bar\") ok := td.Cmp(t, got, td.Re(\"(zip|bar)$\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true Capture example t := \u0026testing.T{} got := \"foo bar biz\" ok := td.Cmp(t, got, td.Re(`^(\\w+) (\\w+) (\\w+)$`, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) got = \"foo bar! biz\" ok = td.Cmp(t, got, td.Re(`^(\\w+) (\\w+) (\\w+)$`, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false Compiled example t := \u0026testing.T{} expected := regexp.MustCompile(\"(zip|bar)$\") got := \"foo bar\" ok := td.Cmp(t, got, td.Re(expected), \"checks value %s\", got) fmt.Println(ok) got = \"bar foo\" ok = td.Cmp(t, got, td.Re(expected), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledStringer example t := \u0026testing.T{} expected := regexp.MustCompile(\"(zip|bar)$\") // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foo bar\") ok := td.Cmp(t, got, td.Re(expected), \"checks value %s\", got) fmt.Println(ok) // Output: // true CompiledError example t := \u0026testing.T{} expected := regexp.MustCompile(\"(zip|bar)$\") got := errors.New(\"foo bar\") ok := td.Cmp(t, got, td.Re(expected), \"checks value %s\", got) fmt.Println(ok) // Output: // true CompiledCapture example t := \u0026testing.T{} expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \"foo bar biz\" ok := td.Cmp(t, got, td.Re(expected, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) got = \"foo bar! biz\" ok = td.Cmp(t, got, td.Re(expected, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CmpRe shortcut func CmpRe(t TestingT, got, reg , capture any, args ...any) bool CmpRe is a shortcut for:\ntd.Cmp(t, got, td.Re(reg, capture), args...) See above for details.\nRe optional parameter capture is here mandatory. nil value should be passed to mimic its absence in original Re call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpRe godoc.\nExamples Base example t := \u0026testing.T{} got := \"foo bar\" ok := td.CmpRe(t, got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) got = \"bar foo\" ok = td.CmpRe(t, got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true // false Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foo bar\") ok := td.CmpRe(t, got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foo bar\") ok := td.CmpRe(t, got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true Capture example t := \u0026testing.T{} got := \"foo bar biz\" ok := td.CmpRe(t, got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) got = \"foo bar! biz\" ok = td.CmpRe(t, got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false Compiled example t := \u0026testing.T{} expected := regexp.MustCompile(\"(zip|bar)$\") got := \"foo bar\" ok := td.CmpRe(t, got, expected, nil, \"checks value %s\", got) fmt.Println(ok) got = \"bar foo\" ok = td.CmpRe(t, got, expected, nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledStringer example t := \u0026testing.T{} expected := regexp.MustCompile(\"(zip|bar)$\") // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foo bar\") ok := td.CmpRe(t, got, expected, nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true CompiledError example t := \u0026testing.T{} expected := regexp.MustCompile(\"(zip|bar)$\") got := errors.New(\"foo bar\") ok := td.CmpRe(t, got, expected, nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true CompiledCapture example t := \u0026testing.T{} expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \"foo bar biz\" ok := td.CmpRe(t, got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) got = \"foo bar! biz\" ok = td.CmpRe(t, got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false T.Re shortcut func (t *T) Re(got, reg , capture any, args ...any) bool Re is a shortcut for:\nt.Cmp(got, td.Re(reg, capture), args...) See above for details.\nRe optional parameter capture is here mandatory. nil value should be passed to mimic its absence in original Re call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Re godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) got := \"foo bar\" ok := t.Re(got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) got = \"bar foo\" ok = t.Re(got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true // false Stringer example t := td.NewT(\u0026testing.T{}) // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foo bar\") ok := t.Re(got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true Error example t := td.NewT(\u0026testing.T{}) got := errors.New(\"foo bar\") ok := t.Re(got, \"(zip|bar)$\", nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true Capture example t := td.NewT(\u0026testing.T{}) got := \"foo bar biz\" ok := t.Re(got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) got = \"foo bar! biz\" ok = t.Re(got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false Compiled example t := td.NewT(\u0026testing.T{}) expected := regexp.MustCompile(\"(zip|bar)$\") got := \"foo bar\" ok := t.Re(got, expected, nil, \"checks value %s\", got) fmt.Println(ok) got = \"bar foo\" ok = t.Re(got, expected, nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledStringer example t := td.NewT(\u0026testing.T{}) expected := regexp.MustCompile(\"(zip|bar)$\") // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foo bar\") ok := t.Re(got, expected, nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true CompiledError example t := td.NewT(\u0026testing.T{}) expected := regexp.MustCompile(\"(zip|bar)$\") got := errors.New(\"foo bar\") ok := t.Re(got, expected, nil, \"checks value %s\", got) fmt.Println(ok) // Output: // true CompiledCapture example t := td.NewT(\u0026testing.T{}) expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \"foo bar biz\" ok := t.Re(got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) got = \"foo bar! biz\" ok = t.Re(got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false",
    "description": "func Re(reg any, capture ...any) TestDeep Re operator allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\nreg is the regexp. It can be a string that is automatically compiled using regexp.Compile, or a *regexp.Regexp.\nOptional capture parameter can be used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.",
    "tags": [],
    "title": "Re",
    "uri": "/operators/re/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func ReAll(reg, capture any) TestDeep ReAll operator allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer) and to match its groups contents.\nreg is the regexp. It can be a string that is automatically compiled using regexp.Compile, or a *regexp.Regexp.\ncapture is used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.\ntd.Cmp(t, \"John Doe\", td.ReAll(`(\\w+)(?: |\\z)`, []string{\"John\", \"Doe\"})) // succeeds td.Cmp(t, \"John Doe\", td.ReAll(`(\\w+)(?: |\\z)`, td.Bag(\"Doe\", \"John\"))) // succeeds See also Re.\nSee also ReAll godoc.\nExamples Capture example t := \u0026testing.T{} got := \"foo bar biz\" ok := td.Cmp(t, got, td.ReAll(`(\\w+)`, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) // Matches, but all catured groups do not match Set got = \"foo BAR biz\" ok = td.Cmp(t, got, td.ReAll(`(\\w+)`, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CaptureComplex example t := \u0026testing.T{} got := \"11 45 23 56 85 96\" ok := td.Cmp(t, got, td.ReAll(`(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 }))), \"checks value %s\", got) fmt.Println(ok) // Matches, but 11 is not greater than 20 ok = td.Cmp(t, got, td.ReAll(`(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 20 \u0026\u0026 n \u003c 100 }))), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledCapture example t := \u0026testing.T{} expected := regexp.MustCompile(`(\\w+)`) got := \"foo bar biz\" ok := td.Cmp(t, got, td.ReAll(expected, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) // Matches, but all catured groups do not match Set got = \"foo BAR biz\" ok = td.Cmp(t, got, td.ReAll(expected, td.Set(\"biz\", \"foo\", \"bar\")), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledCaptureComplex example t := \u0026testing.T{} expected := regexp.MustCompile(`(\\d+)`) got := \"11 45 23 56 85 96\" ok := td.Cmp(t, got, td.ReAll(expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 }))), \"checks value %s\", got) fmt.Println(ok) // Matches, but 11 is not greater than 20 ok = td.Cmp(t, got, td.ReAll(expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 20 \u0026\u0026 n \u003c 100 }))), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CmpReAll shortcut func CmpReAll(t TestingT, got, reg , capture any, args ...any) bool CmpReAll is a shortcut for:\ntd.Cmp(t, got, td.ReAll(reg, capture), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpReAll godoc.\nExamples Capture example t := \u0026testing.T{} got := \"foo bar biz\" ok := td.CmpReAll(t, got, `(\\w+)`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Matches, but all catured groups do not match Set got = \"foo BAR biz\" ok = td.CmpReAll(t, got, `(\\w+)`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CaptureComplex example t := \u0026testing.T{} got := \"11 45 23 56 85 96\" ok := td.CmpReAll(t, got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Matches, but 11 is not greater than 20 ok = td.CmpReAll(t, got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 20 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledCapture example t := \u0026testing.T{} expected := regexp.MustCompile(`(\\w+)`) got := \"foo bar biz\" ok := td.CmpReAll(t, got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Matches, but all catured groups do not match Set got = \"foo BAR biz\" ok = td.CmpReAll(t, got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledCaptureComplex example t := \u0026testing.T{} expected := regexp.MustCompile(`(\\d+)`) got := \"11 45 23 56 85 96\" ok := td.CmpReAll(t, got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Matches, but 11 is not greater than 20 ok = td.CmpReAll(t, got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 20 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false T.ReAll shortcut func (t *T) ReAll(got, reg , capture any, args ...any) bool ReAll is a shortcut for:\nt.Cmp(got, td.ReAll(reg, capture), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.ReAll godoc.\nExamples Capture example t := td.NewT(\u0026testing.T{}) got := \"foo bar biz\" ok := t.ReAll(got, `(\\w+)`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Matches, but all catured groups do not match Set got = \"foo BAR biz\" ok = t.ReAll(got, `(\\w+)`, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CaptureComplex example t := td.NewT(\u0026testing.T{}) got := \"11 45 23 56 85 96\" ok := t.ReAll(got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Matches, but 11 is not greater than 20 ok = t.ReAll(got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 20 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledCapture example t := td.NewT(\u0026testing.T{}) expected := regexp.MustCompile(`(\\w+)`) got := \"foo bar biz\" ok := t.ReAll(got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Matches, but all catured groups do not match Set got = \"foo BAR biz\" ok = t.ReAll(got, expected, td.Set(\"biz\", \"foo\", \"bar\"), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false CompiledCaptureComplex example t := td.NewT(\u0026testing.T{}) expected := regexp.MustCompile(`(\\d+)`) got := \"11 45 23 56 85 96\" ok := t.ReAll(got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 10 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Matches, but 11 is not greater than 20 ok = t.ReAll(got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026\u0026 n \u003e 20 \u0026\u0026 n \u003c 100 })), \"checks value %s\", got) fmt.Println(ok) // Output: // true // false",
    "description": "func ReAll(reg, capture any) TestDeep ReAll operator allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer) and to match its groups contents.\nreg is the regexp. It can be a string that is automatically compiled using regexp.Compile, or a *regexp.Regexp.\ncapture is used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.",
    "tags": [],
    "title": "ReAll",
    "uri": "/operators/reall/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Recv(expectedValue any, timeout ...time.Duration) TestDeep Recv is a smuggler operator. It reads from a channel or a pointer to a channel and compares the read value to expectedValue.\nexpectedValue can be any value including a TestDeep operator. It can also be RecvNothing to test nothing can be read from the channel or RecvClosed to check the channel is closed.\nIf timeout is passed it should be only one item. It means: try to read the channel during this duration to get a value before giving up. If timeout is missing or ≤ 0, it defaults to 0 meaning Recv does not wait for a value but gives up instantly if no value is available on the channel.\nch := make(chan int, 6) td.Cmp(t, ch, td.Recv(td.RecvNothing)) // succeeds td.Cmp(t, ch, td.Recv(42)) // fails, nothing to receive // recv(DATA): values differ // got: nothing received on channel // expected: 42 ch \u003c- 42 td.Cmp(t, ch, td.Recv(td.RecvNothing)) // fails, 42 received instead // recv(DATA): values differ // got: 42 // expected: nothing received on channel td.Cmp(t, ch, td.Recv(42)) // fails, nothing to receive anymore // recv(DATA): values differ // got: nothing received on channel // expected: 42 ch \u003c- 666 td.Cmp(t, ch, td.Recv(td.Between(600, 700))) // succeeds close(ch) td.Cmp(t, ch, td.Recv(td.RecvNothing)) // fails as channel is closed // recv(DATA): values differ // got: channel is closed // expected: nothing received on channel td.Cmp(t, ch, td.Recv(td.RecvClosed)) // succeeds Note that for convenience Recv accepts pointer on channel:\nch := make(chan int, 6) ch \u003c- 42 td.Cmp(t, \u0026ch, td.Recv(42)) // succeeds Each time Recv is called, it tries to consume one item from the channel, immediately or, if given, before timeout duration. To consume several items in a same Cmp call, one can use All operator as in:\nch := make(chan int, 6) ch \u003c- 1 ch \u003c- 2 ch \u003c- 3 close(ch) td.Cmp(t, ch, td.All( // succeeds td.Recv(1), td.Recv(2), td.Recv(3), td.Recv(td.RecvClosed), )) To check nothing can be received during 100ms on channel ch (if something is received before, including a close, it fails):\ntd.Cmp(t, ch, td.Recv(td.RecvNothing, 100*time.Millisecond)) note that in case of success, the above Cmp call always lasts 100ms.\nTo check 42 can be received from channel ch during the next 100ms (if nothing is received during these 100ms or something different from 42, including a close, it fails):\ntd.Cmp(t, ch, td.Recv(42, 100*time.Millisecond)) note that in case of success, the above Cmp call lasts less than 100ms.\nA nil channel is not handled specifically, so it “is never ready for communication” as specification says:\nvar ch chan int td.Cmp(t, ch, td.Recv(td.RecvNothing)) // always succeeds td.Cmp(t, ch, td.Recv(42)) // or any other value, always fails td.Cmp(t, ch, td.Recv(td.RecvClosed)) // always fails so to check if a channel is not nil before reading from it, one can either do:\ntd.Cmp(t, ch, td.All( td.NotNil(), td.Recv(42), )) // or if td.Cmp(t, ch, td.NotNil()) { td.Cmp(t, ch, td.Recv(42)) } TypeBehind method returns the reflect.Type of expectedValue, except if expectedValue is a TestDeep operator. In this case, it delegates TypeBehind() to the operator.\nSee also Cap and Len.\nSee also Recv godoc.\nExamples Basic example t := \u0026testing.T{} got := make(chan int, 3) ok := td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"nothing to receive:\", ok) got \u003c- 1 got \u003c- 2 got \u003c- 3 close(got) ok = td.Cmp(t, got, td.Recv(1)) fmt.Println(\"1st receive is 1:\", ok) ok = td.Cmp(t, got, td.All( td.Recv(2), td.Recv(td.Between(3, 4)), td.Recv(td.RecvClosed), )) fmt.Println(\"next receives are 2, 3 then closed:\", ok) ok = td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"nothing to receive:\", ok) // Output: // nothing to receive: true // 1st receive is 1: true // next receives are 2, 3 then closed: true // nothing to receive: false ChannelPointer example t := \u0026testing.T{} got := make(chan int, 3) ok := td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"nothing to receive:\", ok) got \u003c- 1 got \u003c- 2 got \u003c- 3 close(got) ok = td.Cmp(t, \u0026got, td.Recv(1)) fmt.Println(\"1st receive is 1:\", ok) ok = td.Cmp(t, \u0026got, td.All( td.Recv(2), td.Recv(td.Between(3, 4)), td.Recv(td.RecvClosed), )) fmt.Println(\"next receives are 2, 3 then closed:\", ok) ok = td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"nothing to receive:\", ok) // Output: // nothing to receive: true // 1st receive is 1: true // next receives are 2, 3 then closed: true // nothing to receive: false WithTimeout example t := \u0026testing.T{} got := make(chan int, 1) tick := make(chan struct{}) go func() { // ① \u003c-tick time.Sleep(100 * time.Millisecond) got \u003c- 0 // ② \u003c-tick time.Sleep(100 * time.Millisecond) got \u003c- 1 // ③ \u003c-tick time.Sleep(100 * time.Millisecond) close(got) }() td.Cmp(t, got, td.Recv(td.RecvNothing)) // ① tick \u003c- struct{}{} ok := td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"① RecvNothing:\", ok) ok = td.Cmp(t, got, td.Recv(0, 150*time.Millisecond)) fmt.Println(\"① receive 0 w/150ms timeout:\", ok) ok = td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"① RecvNothing:\", ok) // ② tick \u003c- struct{}{} ok = td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"② RecvNothing:\", ok) ok = td.Cmp(t, got, td.Recv(1, 150*time.Millisecond)) fmt.Println(\"② receive 1 w/150ms timeout:\", ok) ok = td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"② RecvNothing:\", ok) // ③ tick \u003c- struct{}{} ok = td.Cmp(t, got, td.Recv(td.RecvNothing)) fmt.Println(\"③ RecvNothing:\", ok) ok = td.Cmp(t, got, td.Recv(td.RecvClosed, 150*time.Millisecond)) fmt.Println(\"③ check closed w/150ms timeout:\", ok) // Output: // ① RecvNothing: true // ① receive 0 w/150ms timeout: true // ① RecvNothing: true // ② RecvNothing: true // ② receive 1 w/150ms timeout: true // ② RecvNothing: true // ③ RecvNothing: true // ③ check closed w/150ms timeout: true NilChannel example t := \u0026testing.T{} var ch chan int ok := td.Cmp(t, ch, td.Recv(td.RecvNothing)) fmt.Println(\"nothing to receive from nil channel:\", ok) ok = td.Cmp(t, ch, td.Recv(42)) fmt.Println(\"something to receive from nil channel:\", ok) ok = td.Cmp(t, ch, td.Recv(td.RecvClosed)) fmt.Println(\"is a nil channel closed:\", ok) // Output: // nothing to receive from nil channel: true // something to receive from nil channel: false // is a nil channel closed: false CmpRecv shortcut func CmpRecv(t TestingT, got, expectedValue any, timeout time.Duration, args ...any) bool CmpRecv is a shortcut for:\ntd.Cmp(t, got, td.Recv(expectedValue, timeout), args...) See above for details.\nRecv optional parameter timeout is here mandatory. 0 value should be passed to mimic its absence in original Recv call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpRecv godoc.\nExamples Basic example t := \u0026testing.T{} got := make(chan int, 3) ok := td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) got \u003c- 1 got \u003c- 2 got \u003c- 3 close(got) ok = td.CmpRecv(t, got, 1, 0) fmt.Println(\"1st receive is 1:\", ok) ok = td.Cmp(t, got, td.All( td.Recv(2), td.Recv(td.Between(3, 4)), td.Recv(td.RecvClosed), )) fmt.Println(\"next receives are 2, 3 then closed:\", ok) ok = td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) // Output: // nothing to receive: true // 1st receive is 1: true // next receives are 2, 3 then closed: true // nothing to receive: false ChannelPointer example t := \u0026testing.T{} got := make(chan int, 3) ok := td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) got \u003c- 1 got \u003c- 2 got \u003c- 3 close(got) ok = td.CmpRecv(t, \u0026got, 1, 0) fmt.Println(\"1st receive is 1:\", ok) ok = td.Cmp(t, \u0026got, td.All( td.Recv(2), td.Recv(td.Between(3, 4)), td.Recv(td.RecvClosed), )) fmt.Println(\"next receives are 2, 3 then closed:\", ok) ok = td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) // Output: // nothing to receive: true // 1st receive is 1: true // next receives are 2, 3 then closed: true // nothing to receive: false WithTimeout example t := \u0026testing.T{} got := make(chan int, 1) tick := make(chan struct{}) go func() { // ① \u003c-tick time.Sleep(100 * time.Millisecond) got \u003c- 0 // ② \u003c-tick time.Sleep(100 * time.Millisecond) got \u003c- 1 // ③ \u003c-tick time.Sleep(100 * time.Millisecond) close(got) }() td.CmpRecv(t, got, td.RecvNothing, 0) // ① tick \u003c- struct{}{} ok := td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"① RecvNothing:\", ok) ok = td.CmpRecv(t, got, 0, 150*time.Millisecond) fmt.Println(\"① receive 0 w/150ms timeout:\", ok) ok = td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"① RecvNothing:\", ok) // ② tick \u003c- struct{}{} ok = td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"② RecvNothing:\", ok) ok = td.CmpRecv(t, got, 1, 150*time.Millisecond) fmt.Println(\"② receive 1 w/150ms timeout:\", ok) ok = td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"② RecvNothing:\", ok) // ③ tick \u003c- struct{}{} ok = td.CmpRecv(t, got, td.RecvNothing, 0) fmt.Println(\"③ RecvNothing:\", ok) ok = td.CmpRecv(t, got, td.RecvClosed, 150*time.Millisecond) fmt.Println(\"③ check closed w/150ms timeout:\", ok) // Output: // ① RecvNothing: true // ① receive 0 w/150ms timeout: true // ① RecvNothing: true // ② RecvNothing: true // ② receive 1 w/150ms timeout: true // ② RecvNothing: true // ③ RecvNothing: true // ③ check closed w/150ms timeout: true NilChannel example t := \u0026testing.T{} var ch chan int ok := td.CmpRecv(t, ch, td.RecvNothing, 0) fmt.Println(\"nothing to receive from nil channel:\", ok) ok = td.CmpRecv(t, ch, 42, 0) fmt.Println(\"something to receive from nil channel:\", ok) ok = td.CmpRecv(t, ch, td.RecvClosed, 0) fmt.Println(\"is a nil channel closed:\", ok) // Output: // nothing to receive from nil channel: true // something to receive from nil channel: false // is a nil channel closed: false T.Recv shortcut func (t *T) Recv(got, expectedValue any, timeout time.Duration, args ...any) bool Recv is a shortcut for:\nt.Cmp(got, td.Recv(expectedValue, timeout), args...) See above for details.\nRecv optional parameter timeout is here mandatory. 0 value should be passed to mimic its absence in original Recv call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Recv godoc.\nExamples Basic example t := td.NewT(\u0026testing.T{}) got := make(chan int, 3) ok := t.Recv(got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) got \u003c- 1 got \u003c- 2 got \u003c- 3 close(got) ok = t.Recv(got, 1, 0) fmt.Println(\"1st receive is 1:\", ok) ok = t.Cmp(got, td.All( td.Recv(2), td.Recv(td.Between(3, 4)), td.Recv(td.RecvClosed), )) fmt.Println(\"next receives are 2, 3 then closed:\", ok) ok = t.Recv(got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) // Output: // nothing to receive: true // 1st receive is 1: true // next receives are 2, 3 then closed: true // nothing to receive: false ChannelPointer example t := td.NewT(\u0026testing.T{}) got := make(chan int, 3) ok := t.Recv(got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) got \u003c- 1 got \u003c- 2 got \u003c- 3 close(got) ok = t.Recv(\u0026got, 1, 0) fmt.Println(\"1st receive is 1:\", ok) ok = t.Cmp(\u0026got, td.All( td.Recv(2), td.Recv(td.Between(3, 4)), td.Recv(td.RecvClosed), )) fmt.Println(\"next receives are 2, 3 then closed:\", ok) ok = t.Recv(got, td.RecvNothing, 0) fmt.Println(\"nothing to receive:\", ok) // Output: // nothing to receive: true // 1st receive is 1: true // next receives are 2, 3 then closed: true // nothing to receive: false WithTimeout example t := td.NewT(\u0026testing.T{}) got := make(chan int, 1) tick := make(chan struct{}) go func() { // ① \u003c-tick time.Sleep(100 * time.Millisecond) got \u003c- 0 // ② \u003c-tick time.Sleep(100 * time.Millisecond) got \u003c- 1 // ③ \u003c-tick time.Sleep(100 * time.Millisecond) close(got) }() t.Recv(got, td.RecvNothing, 0) // ① tick \u003c- struct{}{} ok := t.Recv(got, td.RecvNothing, 0) fmt.Println(\"① RecvNothing:\", ok) ok = t.Recv(got, 0, 150*time.Millisecond) fmt.Println(\"① receive 0 w/150ms timeout:\", ok) ok = t.Recv(got, td.RecvNothing, 0) fmt.Println(\"① RecvNothing:\", ok) // ② tick \u003c- struct{}{} ok = t.Recv(got, td.RecvNothing, 0) fmt.Println(\"② RecvNothing:\", ok) ok = t.Recv(got, 1, 150*time.Millisecond) fmt.Println(\"② receive 1 w/150ms timeout:\", ok) ok = t.Recv(got, td.RecvNothing, 0) fmt.Println(\"② RecvNothing:\", ok) // ③ tick \u003c- struct{}{} ok = t.Recv(got, td.RecvNothing, 0) fmt.Println(\"③ RecvNothing:\", ok) ok = t.Recv(got, td.RecvClosed, 150*time.Millisecond) fmt.Println(\"③ check closed w/150ms timeout:\", ok) // Output: // ① RecvNothing: true // ① receive 0 w/150ms timeout: true // ① RecvNothing: true // ② RecvNothing: true // ② receive 1 w/150ms timeout: true // ② RecvNothing: true // ③ RecvNothing: true // ③ check closed w/150ms timeout: true NilChannel example t := td.NewT(\u0026testing.T{}) var ch chan int ok := t.Recv(ch, td.RecvNothing, 0) fmt.Println(\"nothing to receive from nil channel:\", ok) ok = t.Recv(ch, 42, 0) fmt.Println(\"something to receive from nil channel:\", ok) ok = t.Recv(ch, td.RecvClosed, 0) fmt.Println(\"is a nil channel closed:\", ok) // Output: // nothing to receive from nil channel: true // something to receive from nil channel: false // is a nil channel closed: false",
    "description": "func Recv(expectedValue any, timeout ...time.Duration) TestDeep Recv is a smuggler operator. It reads from a channel or a pointer to a channel and compares the read value to expectedValue.\nexpectedValue can be any value including a TestDeep operator. It can also be RecvNothing to test nothing can be read from the channel or RecvClosed to check the channel is closed.\nIf timeout is passed it should be only one item. It means: try to read the channel during this duration to get a value before giving up. If timeout is missing or ≤ 0, it defaults to 0 meaning Recv does not wait for a value but gives up instantly if no value is available on the channel.",
    "tags": [],
    "title": "Recv",
    "uri": "/operators/recv/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Set(expectedItems ...any) TestDeep Set operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\ntd.Cmp(t, []int{1, 1, 2}, td.Set(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(1, 2, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.Set( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{2, 1} td.Cmp(t, []int{1, 1, 2}, td.Set(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1, 2}, td.Set(2, 1)) exp1 := []int{2, 1} exp2 := []int{5, 8} td.Cmp(t, []int{1, 5, 1, 2, 8, 3, 3}, td.Set(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 2, 8, 3, 3}, td.Set(2, 1, 3, 5, 8)) TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa) and they are equal.\nSee also NotAny, SubSetOf, SuperSetOf and Bag.\nSee also Set godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates ok := td.Cmp(t, got, td.Set(1, 2, 3, 5, 8), \"checks all items are present, in any order\") fmt.Println(ok) // Duplicates are ignored in a Set ok = td.Cmp(t, got, td.Set(1, 2, 2, 2, 2, 2, 3, 5, 8), \"checks all items are present, in any order\") fmt.Println(ok) // Tries its best not to raise an error when a value can be matched // by several Set entries ok = td.Cmp(t, got, td.Set(td.Between(1, 4), 3, td.Between(2, 10)), \"checks all items are present, in any order\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5, 8} ok = td.Cmp(t, got, td.Set(td.Flatten(expected)), \"checks all expected items are present, in any order\") fmt.Println(ok) // Output: // true // true // true // true CmpSet shortcut func CmpSet(t TestingT, got any, expectedItems []any, args ...any) bool CmpSet is a shortcut for:\ntd.Cmp(t, got, td.Set(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSet godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates ok := td.CmpSet(t, got, []any{1, 2, 3, 5, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Duplicates are ignored in a Set ok = td.CmpSet(t, got, []any{1, 2, 2, 2, 2, 2, 3, 5, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Tries its best not to raise an error when a value can be matched // by several Set entries ok = td.CmpSet(t, got, []any{td.Between(1, 4), 3, td.Between(2, 10)}, \"checks all items are present, in any order\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5, 8} ok = td.CmpSet(t, got, []any{td.Flatten(expected)}, \"checks all expected items are present, in any order\") fmt.Println(ok) // Output: // true // true // true // true T.Set shortcut func (t *T) Set(got any, expectedItems []any, args ...any) bool Set is a shortcut for:\nt.Cmp(got, td.Set(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Set godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates ok := t.Set(got, []any{1, 2, 3, 5, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Duplicates are ignored in a Set ok = t.Set(got, []any{1, 2, 2, 2, 2, 2, 3, 5, 8}, \"checks all items are present, in any order\") fmt.Println(ok) // Tries its best not to raise an error when a value can be matched // by several Set entries ok = t.Set(got, []any{td.Between(1, 4), 3, td.Between(2, 10)}, \"checks all items are present, in any order\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5, 8} ok = t.Set(got, []any{td.Flatten(expected)}, \"checks all expected items are present, in any order\") fmt.Println(ok) // Output: // true // true // true // true",
    "description": "func Set(expectedItems ...any) TestDeep Set operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\ntd.Cmp(t, []int{1, 1, 2}, td.Set(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(1, 2, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.Set( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:",
    "tags": [],
    "title": "Set",
    "uri": "/operators/set/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Shallow(expectedPtr any) TestDeep Shallow operator compares pointers only, not their contents. It applies on channels, functions (with some restrictions), maps, pointers, slices and strings.\nDuring a match, the compared data must be the same as expectedPtr to succeed.\na, b := 123, 123 td.Cmp(t, \u0026a, td.Shallow(\u0026a)) // succeeds td.Cmp(t, \u0026a, td.Shallow(\u0026b)) // fails even if a == b as \u0026a != \u0026b back := \"foobarfoobar\" a, b := back[:6], back[6:] // a == b but... td.Cmp(t, \u0026a, td.Shallow(\u0026b)) // fails Be careful for slices and strings! Shallow can succeed but the slices/strings not be identical because of their different lengths. For example:\na := \"foobar yes!\" b := a[:1] // aka \"f\" td.Cmp(t, \u0026a, td.Shallow(\u0026b)) // succeeds as both strings point to the same area, even if len() differ The same behavior occurs for slices:\na := []int{1, 2, 3, 4, 5, 6} b := a[:2] // aka []int{1, 2} td.Cmp(t, \u0026a, td.Shallow(\u0026b)) // succeeds as both slices point to the same area, even if len() differ See also Ptr.\nSee also Shallow godoc.\nExamples Base example t := \u0026testing.T{} type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026data ok := td.Cmp(t, got, td.Shallow(\u0026data), \"checks pointers only, not contents\") fmt.Println(ok) // Same contents, but not same pointer ok = td.Cmp(t, got, td.Shallow(\u0026MyStruct{Value: 12}), \"checks pointers only, not contents\") fmt.Println(ok) // Output: // true // false Slice example t := \u0026testing.T{} back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := td.Cmp(t, a, td.Shallow(back)) fmt.Println(\"are ≠ but share the same area:\", ok) ok = td.Cmp(t, b, td.Shallow(back)) fmt.Println(\"are = but do not point to same area:\", ok) // Output: // are ≠ but share the same area: true // are = but do not point to same area: false String example t := \u0026testing.T{} back := \"foobarfoobar\" a := back[:6] b := back[6:] ok := td.Cmp(t, a, td.Shallow(back)) fmt.Println(\"are ≠ but share the same area:\", ok) ok = td.Cmp(t, b, td.Shallow(a)) fmt.Println(\"are = but do not point to same area:\", ok) // Output: // are ≠ but share the same area: true // are = but do not point to same area: false CmpShallow shortcut func CmpShallow(t TestingT, got, expectedPtr any, args ...any) bool CmpShallow is a shortcut for:\ntd.Cmp(t, got, td.Shallow(expectedPtr), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpShallow godoc.\nExamples Base example t := \u0026testing.T{} type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026data ok := td.CmpShallow(t, got, \u0026data, \"checks pointers only, not contents\") fmt.Println(ok) // Same contents, but not same pointer ok = td.CmpShallow(t, got, \u0026MyStruct{Value: 12}, \"checks pointers only, not contents\") fmt.Println(ok) // Output: // true // false Slice example t := \u0026testing.T{} back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := td.CmpShallow(t, a, back) fmt.Println(\"are ≠ but share the same area:\", ok) ok = td.CmpShallow(t, b, back) fmt.Println(\"are = but do not point to same area:\", ok) // Output: // are ≠ but share the same area: true // are = but do not point to same area: false String example t := \u0026testing.T{} back := \"foobarfoobar\" a := back[:6] b := back[6:] ok := td.CmpShallow(t, a, back) fmt.Println(\"are ≠ but share the same area:\", ok) ok = td.CmpShallow(t, b, a) fmt.Println(\"are = but do not point to same area:\", ok) // Output: // are ≠ but share the same area: true // are = but do not point to same area: false T.Shallow shortcut func (t *T) Shallow(got, expectedPtr any, args ...any) bool Shallow is a shortcut for:\nt.Cmp(got, td.Shallow(expectedPtr), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Shallow godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026data ok := t.Shallow(got, \u0026data, \"checks pointers only, not contents\") fmt.Println(ok) // Same contents, but not same pointer ok = t.Shallow(got, \u0026MyStruct{Value: 12}, \"checks pointers only, not contents\") fmt.Println(ok) // Output: // true // false Slice example t := td.NewT(\u0026testing.T{}) back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := t.Shallow(a, back) fmt.Println(\"are ≠ but share the same area:\", ok) ok = t.Shallow(b, back) fmt.Println(\"are = but do not point to same area:\", ok) // Output: // are ≠ but share the same area: true // are = but do not point to same area: false String example t := td.NewT(\u0026testing.T{}) back := \"foobarfoobar\" a := back[:6] b := back[6:] ok := t.Shallow(a, back) fmt.Println(\"are ≠ but share the same area:\", ok) ok = t.Shallow(b, a) fmt.Println(\"are = but do not point to same area:\", ok) // Output: // are ≠ but share the same area: true // are = but do not point to same area: false",
    "description": "func Shallow(expectedPtr any) TestDeep Shallow operator compares pointers only, not their contents. It applies on channels, functions (with some restrictions), maps, pointers, slices and strings.\nDuring a match, the compared data must be the same as expectedPtr to succeed.\na, b := 123, 123 td.Cmp(t, \u0026a, td.Shallow(\u0026a)) // succeeds td.Cmp(t, \u0026a, td.Shallow(\u0026b)) // fails even if a == b as \u0026a != \u0026b back := \"foobarfoobar\" a, b := back[:6], back[6:] // a == b but... td.Cmp(t, \u0026a, td.Shallow(\u0026b)) // fails Be careful for slices and strings! Shallow can succeed but the slices/strings not be identical because of their different lengths. For example:",
    "tags": [],
    "title": "Shallow",
    "uri": "/operators/shallow/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Slice(model any, expectedEntries ArrayEntries) TestDeep Slice operator compares the contents of a slice or a pointer on a slice against the values of model and the values of expectedEntries. Entries with zero values of model are ignored if the same entry is present in expectedEntries, otherwise they are taken into account. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, all entries are checked. To check only some entries of a slice, see SuperSliceOf operator.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\ngot := []int{12, 14, 17} td.Cmp(t, got, td.Slice([]int{0, 14}, td.ArrayEntries{0: 12, 2: 17})) // succeeds td.Cmp(t, \u0026got, td.Slice(\u0026[]int{0, 14}, td.ArrayEntries{0: td.Gt(10), 2: td.Gt(15)})) // succeeds TypeBehind method returns the reflect.Type of model.\nSee also Array and SuperSliceOf.\nSee also Slice godoc.\nExamples Slice example t := \u0026testing.T{} got := []int{42, 58, 26} ok := td.Cmp(t, got, td.Slice([]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks slice %v\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Slice([]int{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks slice %v\", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Slice(([]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks slice %v\", got) fmt.Println(ok) // Output: // true // true // true TypedSlice example t := \u0026testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.Cmp(t, got, td.Slice(MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks typed slice %v\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Slice(\u0026MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \"checks pointer on typed slice %v\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Slice(\u0026MySlice{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks pointer on typed slice %v\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.Slice((*MySlice)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \"checks pointer on typed slice %v\", got) fmt.Println(ok) // Output: // true // true // true // true CmpSlice shortcut func CmpSlice(t TestingT, got, model any, expectedEntries ArrayEntries, args ...any) bool CmpSlice is a shortcut for:\ntd.Cmp(t, got, td.Slice(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSlice godoc.\nExamples Slice example t := \u0026testing.T{} got := []int{42, 58, 26} ok := td.CmpSlice(t, got, []int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks slice %v\", got) fmt.Println(ok) ok = td.CmpSlice(t, got, []int{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks slice %v\", got) fmt.Println(ok) ok = td.CmpSlice(t, got, ([]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks slice %v\", got) fmt.Println(ok) // Output: // true // true // true TypedSlice example t := \u0026testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.CmpSlice(t, got, MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks typed slice %v\", got) fmt.Println(ok) ok = td.CmpSlice(t, \u0026got, \u0026MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks pointer on typed slice %v\", got) fmt.Println(ok) ok = td.CmpSlice(t, \u0026got, \u0026MySlice{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed slice %v\", got) fmt.Println(ok) ok = td.CmpSlice(t, \u0026got, (*MySlice)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed slice %v\", got) fmt.Println(ok) // Output: // true // true // true // true T.Slice shortcut func (t *T) Slice(got, model any, expectedEntries ArrayEntries, args ...any) bool Slice is a shortcut for:\nt.Cmp(got, td.Slice(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Slice godoc.\nExamples Slice example t := td.NewT(\u0026testing.T{}) got := []int{42, 58, 26} ok := t.Slice(got, []int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks slice %v\", got) fmt.Println(ok) ok = t.Slice(got, []int{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks slice %v\", got) fmt.Println(ok) ok = t.Slice(got, ([]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks slice %v\", got) fmt.Println(ok) // Output: // true // true // true TypedSlice example t := td.NewT(\u0026testing.T{}) type MySlice []int got := MySlice{42, 58, 26} ok := t.Slice(got, MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks typed slice %v\", got) fmt.Println(ok) ok = t.Slice(\u0026got, \u0026MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \"checks pointer on typed slice %v\", got) fmt.Println(ok) ok = t.Slice(\u0026got, \u0026MySlice{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed slice %v\", got) fmt.Println(ok) ok = t.Slice(\u0026got, (*MySlice)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \"checks pointer on typed slice %v\", got) fmt.Println(ok) // Output: // true // true // true // true",
    "description": "func Slice(model any, expectedEntries ArrayEntries) TestDeep Slice operator compares the contents of a slice or a pointer on a slice against the values of model and the values of expectedEntries. Entries with zero values of model are ignored if the same entry is present in expectedEntries, otherwise they are taken into account. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, all entries are checked. To check only some entries of a slice, see SuperSliceOf operator.",
    "tags": [],
    "title": "Slice",
    "uri": "/operators/slice/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Smuggle(fn, expectedValue any) TestDeep Smuggle operator allows to change data contents or mutate it into another type before stepping down in favor of generic comparison process. Of course it is a smuggler operator. So fn is a function that must take one parameter whose type must be convertible to the type of the compared value.\nAs convenient shortcuts, fn can be a string specifying a fields-path through structs, maps \u0026 slices, or any other type, in this case a simple cast is done (see below for details).\nfn must return at least one value. These value will be compared as is to expectedValue, here integer 28:\ntd.Cmp(t, \"0028\", td.Smuggle(func(value string) int { num, _ := strconv.Atoi(value) return num }, 28), ) or using an other TestDeep operator, here Between(28, 30):\ntd.Cmp(t, \"0029\", td.Smuggle(func(value string) int { num, _ := strconv.Atoi(value) return num }, td.Between(28, 30)), ) fn can return a second boolean value, used to tell that a problem occurred and so stop the comparison:\ntd.Cmp(t, \"0029\", td.Smuggle(func(value string) (int, bool) { num, err := strconv.Atoi(value) return num, err == nil }, td.Between(28, 30)), ) fn can return a third string value which is used to describe the test when a problem occurred (false second boolean value):\ntd.Cmp(t, \"0029\", td.Smuggle(func(value string) (int, bool, string) { num, err := strconv.Atoi(value) if err != nil { return 0, false, \"string must contain a number\" } return num, true, \"\" }, td.Between(28, 30)), ) Instead of returning (X, bool) or (X, bool, string), fn can return (X, error). When a problem occurs, the returned error is non-nil, as in:\ntd.Cmp(t, \"0029\", td.Smuggle(func(value string) (int, error) { num, err := strconv.Atoi(value) return num, err }, td.Between(28, 30)), ) Which can be simplified to:\ntd.Cmp(t, \"0029\", td.Smuggle(strconv.Atoi, td.Between(28, 30))) Imagine you want to compare that the Year of a date is between 2010 and 2020:\ntd.Cmp(t, time.Date(2015, time.May, 1, 1, 2, 3, 0, time.UTC), td.Smuggle(func(date time.Time) int { return date.Year() }, td.Between(2010, 2020)), ) In this case the data location forwarded to next test will be something like “DATA.MyTimeField”, but you can act on it too by returning a SmuggledGot struct (by value or by address):\ntd.Cmp(t, time.Date(2015, time.May, 1, 1, 2, 3, 0, time.UTC), td.Smuggle(func(date time.Time) SmuggledGot { return SmuggledGot{ Name: \"Year\", Got: date.Year(), } }, td.Between(2010, 2020)), ) then the data location forwarded to next test will be something like “DATA.MyTimeField.Year”. The “.” between the current path (here “DATA.MyTimeField”) and the returned Name “Year” is automatically added when Name starts with a Letter.\nNote that SmuggledGot and *SmuggledGot returns are treated equally, and they are only used when fn has only one returned value or when the second boolean returned value is true.\nOf course, all cases can go together:\n// Accepts a \"YYYY/mm/DD HH:MM:SS\" string to produce a time.Time and tests // whether this date is contained between 2 hours before now and now. td.Cmp(t, \"2020-01-25 12:13:14\", td.Smuggle(func(date string) (*SmuggledGot, bool, string) { date, err := time.Parse(\"2006/01/02 15:04:05\", date) if err != nil { return nil, false, `date must conform to \"YYYY/mm/DD HH:MM:SS\" format` } return \u0026SmuggledGot{ Name: \"Date\", Got: date, }, true, \"\" }, td.Between(time.Now().Add(-2*time.Hour), time.Now())), ) or:\n// Accepts a \"YYYY/mm/DD HH:MM:SS\" string to produce a time.Time and tests // whether this date is contained between 2 hours before now and now. td.Cmp(t, \"2020-01-25 12:13:14\", td.Smuggle(func(date string) (*SmuggledGot, error) { date, err := time.Parse(\"2006/01/02 15:04:05\", date) if err != nil { return nil, err } return \u0026SmuggledGot{ Name: \"Date\", Got: date, }, nil }, td.Between(time.Now().Add(-2*time.Hour), time.Now())), ) Smuggle can also be used to access a struct field embedded in several struct layers.\ntype A struct{ Num int } // func (a *A) String() string { return fmt.Sprintf(\"Num is %d\", a.Num) } type B struct{ As map[string]*A } type C struct{ B B } got := C{B: B{As: map[string]*A{\"foo\": {Num: 12}}}} // Tests that got.B.A.Num is 12 td.Cmp(t, got, td.Smuggle(func(c C) int { return c.B.As[\"foo\"].Num }, 12)) As brought up above, a fields-path can be passed as fn value instead of a function pointer. Using this feature, the Cmp call in the above example can be rewritten as follows:\n// Tests that got.B.As[\"foo\"].Num is 12 td.Cmp(t, got, td.Smuggle(\"B.As[foo].Num\", 12)) For convenience, if a map[string]… is addressed, it can be done like a struct field as “foo” key in:\ntd.Cmp(t, got, td.Smuggle(\"B.As.foo.Num\", 12)) In addition, simple public methods can also be called like in:\ntd.Cmp(t, got, td.Smuggle(\"B.As[foo].String()\", \"Num is 12\")) Allowed methods must not take any parameter and must return one value or a value and an error. For the latter case, if the method returns a non-nil error, the comparison fails. The comparison also fails if a panic occurs or if a method cannot be called. No private fields should be traversed before calling the method. For fun, consider a more complex example involving reflect and chaining method calls:\ngot := reflect.Valueof(\u0026C{B: B{As: map[string]*A{\"foo\": {Num: 12}}}}) td.Cmp(t, got, td.Smuggle(\"Elem().Interface().B.As[foo].String()\", \"Num is 12\")) Contrary to JSONPointer operator, private fields can be followed and public methods on public fields can be called. Arrays, slices and maps work using the index/key inside square brackets (e.g. [12] or [foo]). Maps work only for simple key types (string or numbers), without \"\" when using strings (e.g. [foo]).\nBehind the scenes, a temporary function is automatically created to achieve the same goal, but adds some checks against nil values and auto-dereferences interfaces and pointers, even on several levels, like in:\ntype A struct{ N any } num := 12 pnum := \u0026num td.Cmp(t, A{N: \u0026pnum}, td.Smuggle(\"N\", 12)) Last but not least, a simple type can be passed as fn to operate a cast, handling specifically strings and slices of bytes:\ntd.Cmp(t, `{\"foo\":1}`, td.Smuggle(json.RawMessage{}, td.JSON(`{\"foo\":1}`))) // or equally td.Cmp(t, `{\"foo\":1}`, td.Smuggle(json.RawMessage(nil), td.JSON(`{\"foo\":1}`))) converts on the fly a string to a json.RawMessage so JSON operator can parse it as JSON. This is mostly a shortcut for:\ntd.Cmp(t, `{\"foo\":1}`, td.Smuggle( func(r json.RawMessage) json.RawMessage { return r }, td.JSON(`{\"foo\":1}`))) except that for strings and slices of bytes (like here), it accepts io.Reader interface too:\nvar body io.Reader // … td.Cmp(t, body, td.Smuggle(json.RawMessage{}, td.JSON(`{\"foo\":1}`))) // or equally td.Cmp(t, body, td.Smuggle(json.RawMessage(nil), td.JSON(`{\"foo\":1}`))) This last example allows to easily inject body content into JSON operator.\nThe difference between Smuggle and Code operators is that Code is used to do a final comparison while Smuggle transforms the data and then steps down in favor of generic comparison process. Moreover, the type accepted as input for the function is more lax to facilitate the writing of tests (e.g. the function can accept a float64 and the got value be an int). See examples. On the other hand, the output type is strict and must match exactly the expected value type. The fields-path string fn shortcut and the cast feature are not available with Code operator.\nTypeBehind method returns the reflect.Type of only parameter of fn. For the case where fn is a fields-path, it is always any, as the type can not be known in advance.\nSee also Code, JSONPointer and Flatten.\nSee also Smuggle godoc.\nExamples Convert example t := \u0026testing.T{} got := int64(123) ok := td.Cmp(t, got, td.Smuggle(func(n int64) int { return int(n) }, 123), \"checks int64 got against an int value\") fmt.Println(ok) ok = td.Cmp(t, \"123\", td.Smuggle( func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, td.Between(120, 130)), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) ok = td.Cmp(t, \"123\", td.Smuggle( func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \"string must contain a number\" } return n, true, \"\" }, td.Between(120, 130)), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) ok = td.Cmp(t, \"123\", td.Smuggle( func(numStr string) (int, error) { //nolint: gocritic return strconv.Atoi(numStr) }, td.Between(120, 130)), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) // Short version :) ok = td.Cmp(t, \"123\", td.Smuggle(strconv.Atoi, td.Between(120, 130)), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) // Output: // true // true // true // true // true Lax example t := \u0026testing.T{} // got is an int16 and Smuggle func input is an int64: it is OK got := int(123) ok := td.Cmp(t, got, td.Smuggle(func(n int64) uint32 { return uint32(n) }, uint32(123))) fmt.Println(\"got int16(123) → smuggle via int64 → uint32(123):\", ok) // Output: // got int16(123) → smuggle via int64 → uint32(123): true Auto_unmarshal example t := \u0026testing.T{} // Automatically json.Unmarshal to compare got := []byte(`{\"a\":1,\"b\":2}`) ok := td.Cmp(t, got, td.Smuggle( func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026r) return }, map[string]int{ \"a\": 1, \"b\": 2, })) fmt.Println(\"JSON contents is OK:\", ok) // Output: // JSON contents is OK: true Cast example t := \u0026testing.T{} // A string containing JSON got := `{ \"foo\": 123 }` // Automatically cast a string to a json.RawMessage so td.JSON can operate ok := td.Cmp(t, got, td.Smuggle(json.RawMessage{}, td.JSON(`{\"foo\":123}`))) fmt.Println(\"JSON contents in string is OK:\", ok) // Automatically read from io.Reader to a json.RawMessage ok = td.Cmp(t, bytes.NewReader([]byte(got)), td.Smuggle(json.RawMessage{}, td.JSON(`{\"foo\":123}`))) fmt.Println(\"JSON contents just read is OK:\", ok) // Output: // JSON contents in string is OK: true // JSON contents just read is OK: true Complex example t := \u0026testing.T{} // No end date but a start date and a duration type StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h // for each of these durations in hours for _, duration := range []time.Duration{48 * time.Hour, 72 * time.Hour, 96 * time.Hour} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration, } // Simplest way, but in case of Between() failure, error will be bound // to DATA\u003csmuggled\u003e, not very clear... ok := td.Cmp(t, got, td.Smuggle( func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC)))) fmt.Println(ok) // Name the computed value \"ComputedEndDate\" to render a Between() failure // more understandable, so error will be bound to DATA.ComputedEndDate ok = td.Cmp(t, got, td.Smuggle( func(sd StartDuration) td.SmuggledGot { return td.SmuggledGot{ Name: \"ComputedEndDate\", Got: sd.StartDate.Add(sd.Duration), } }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC)))) fmt.Println(ok) } // Output: // false // false // true // true // true // true Interface example t := \u0026testing.T{} gotTime, err := time.Parse(time.RFC3339, \"2018-05-23T12:13:14Z\") if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form ok := td.Cmp(t, gotTime, td.Smuggle(func(s fmt.Stringer) string { return s.String() }, \"2018-05-23 12:13:14 +0000 UTC\")) fmt.Println(\"stringified time.Time OK:\", ok) // If got does not implement the fmt.Stringer interface, it fails // without calling the Smuggle func type MyTime time.Time ok = td.Cmp(t, MyTime(gotTime), td.Smuggle(func(s fmt.Stringer) string { fmt.Println(\"Smuggle func called!\") return s.String() }, \"2018-05-23 12:13:14 +0000 UTC\")) fmt.Println(\"stringified MyTime OK:\", ok) // Output: // stringified time.Time OK: true // stringified MyTime OK: false Field_path example t := \u0026testing.T{} type Body struct { Name string Value any } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026Transaction{ Request: Request{ Body: \u0026Body{ Name: \"test\", Value: \u0026ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? ok := td.Cmp(t, got, td.Smuggle( func(tr *Transaction) (int, error) { if tr.Body == nil || tr.Body.Value == nil { return 0, errors.New(\"Request.Body or Request.Body.Value is nil\") } if v, ok := tr.Body.Value.(*ValueNum); ok \u0026\u0026 v != nil { return v.Num, nil } return 0, errors.New(\"Request.Body.Value isn't *ValueNum or nil\") }, td.Between(100, 200))) fmt.Println(\"check Num by hand:\", ok) // Same, but automagically generated... ok = td.Cmp(t, got, td.Smuggle(\"Request.Body.Value.Num\", td.Between(100, 200))) fmt.Println(\"check Num using a fields-path:\", ok) // And as Request is an anonymous field, can be simplified further // as it can be omitted ok = td.Cmp(t, got, td.Smuggle(\"Body.Value.Num\", td.Between(100, 200))) fmt.Println(\"check Num using an other fields-path:\", ok) // Note that maps and array/slices are supported got.Body.Value = map[string]any{ \"foo\": []any{ 3: map[int]string{666: \"bar\"}, }, } ok = td.Cmp(t, got, td.Smuggle(\"Body.Value[foo][3][666]\", \"bar\")) fmt.Println(\"check fields-path including maps/slices:\", ok) // Output: // check Num by hand: true // check Num using a fields-path: true // check Num using an other fields-path: true // check fields-path including maps/slices: true CmpSmuggle shortcut func CmpSmuggle(t TestingT, got, fn , expectedValue any, args ...any) bool CmpSmuggle is a shortcut for:\ntd.Cmp(t, got, td.Smuggle(fn, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSmuggle godoc.\nExamples Convert example t := \u0026testing.T{} got := int64(123) ok := td.CmpSmuggle(t, got, func(n int64) int { return int(n) }, 123, \"checks int64 got against an int value\") fmt.Println(ok) ok = td.CmpSmuggle(t, \"123\", func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) ok = td.CmpSmuggle(t, \"123\", func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \"string must contain a number\" } return n, true, \"\" }, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) ok = td.CmpSmuggle(t, \"123\", func(numStr string) (int, error) { //nolint: gocritic return strconv.Atoi(numStr) }, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) // Short version :) ok = td.CmpSmuggle(t, \"123\", strconv.Atoi, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) // Output: // true // true // true // true // true Lax example t := \u0026testing.T{} // got is an int16 and Smuggle func input is an int64: it is OK got := int(123) ok := td.CmpSmuggle(t, got, func(n int64) uint32 { return uint32(n) }, uint32(123)) fmt.Println(\"got int16(123) → smuggle via int64 → uint32(123):\", ok) // Output: // got int16(123) → smuggle via int64 → uint32(123): true Auto_unmarshal example t := \u0026testing.T{} // Automatically json.Unmarshal to compare got := []byte(`{\"a\":1,\"b\":2}`) ok := td.CmpSmuggle(t, got, func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026r) return }, map[string]int{ \"a\": 1, \"b\": 2, }) fmt.Println(\"JSON contents is OK:\", ok) // Output: // JSON contents is OK: true Cast example t := \u0026testing.T{} // A string containing JSON got := `{ \"foo\": 123 }` // Automatically cast a string to a json.RawMessage so td.JSON can operate ok := td.CmpSmuggle(t, got, json.RawMessage{}, td.JSON(`{\"foo\":123}`)) fmt.Println(\"JSON contents in string is OK:\", ok) // Automatically read from io.Reader to a json.RawMessage ok = td.CmpSmuggle(t, bytes.NewReader([]byte(got)), json.RawMessage{}, td.JSON(`{\"foo\":123}`)) fmt.Println(\"JSON contents just read is OK:\", ok) // Output: // JSON contents in string is OK: true // JSON contents just read is OK: true Complex example t := \u0026testing.T{} // No end date but a start date and a duration type StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h // for each of these durations in hours for _, duration := range []time.Duration{48 * time.Hour, 72 * time.Hour, 96 * time.Hour} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration, } // Simplest way, but in case of Between() failure, error will be bound // to DATA\u003csmuggled\u003e, not very clear... ok := td.CmpSmuggle(t, got, func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) // Name the computed value \"ComputedEndDate\" to render a Between() failure // more understandable, so error will be bound to DATA.ComputedEndDate ok = td.CmpSmuggle(t, got, func(sd StartDuration) td.SmuggledGot { return td.SmuggledGot{ Name: \"ComputedEndDate\", Got: sd.StartDate.Add(sd.Duration), } }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) } // Output: // false // false // true // true // true // true Interface example t := \u0026testing.T{} gotTime, err := time.Parse(time.RFC3339, \"2018-05-23T12:13:14Z\") if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form ok := td.CmpSmuggle(t, gotTime, func(s fmt.Stringer) string { return s.String() }, \"2018-05-23 12:13:14 +0000 UTC\") fmt.Println(\"stringified time.Time OK:\", ok) // If got does not implement the fmt.Stringer interface, it fails // without calling the Smuggle func type MyTime time.Time ok = td.CmpSmuggle(t, MyTime(gotTime), func(s fmt.Stringer) string { fmt.Println(\"Smuggle func called!\") return s.String() }, \"2018-05-23 12:13:14 +0000 UTC\") fmt.Println(\"stringified MyTime OK:\", ok) // Output: // stringified time.Time OK: true // stringified MyTime OK: false Field_path example t := \u0026testing.T{} type Body struct { Name string Value any } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026Transaction{ Request: Request{ Body: \u0026Body{ Name: \"test\", Value: \u0026ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? ok := td.CmpSmuggle(t, got, func(tr *Transaction) (int, error) { if tr.Body == nil || tr.Body.Value == nil { return 0, errors.New(\"Request.Body or Request.Body.Value is nil\") } if v, ok := tr.Body.Value.(*ValueNum); ok \u0026\u0026 v != nil { return v.Num, nil } return 0, errors.New(\"Request.Body.Value isn't *ValueNum or nil\") }, td.Between(100, 200)) fmt.Println(\"check Num by hand:\", ok) // Same, but automagically generated... ok = td.CmpSmuggle(t, got, \"Request.Body.Value.Num\", td.Between(100, 200)) fmt.Println(\"check Num using a fields-path:\", ok) // And as Request is an anonymous field, can be simplified further // as it can be omitted ok = td.CmpSmuggle(t, got, \"Body.Value.Num\", td.Between(100, 200)) fmt.Println(\"check Num using an other fields-path:\", ok) // Note that maps and array/slices are supported got.Body.Value = map[string]any{ \"foo\": []any{ 3: map[int]string{666: \"bar\"}, }, } ok = td.CmpSmuggle(t, got, \"Body.Value[foo][3][666]\", \"bar\") fmt.Println(\"check fields-path including maps/slices:\", ok) // Output: // check Num by hand: true // check Num using a fields-path: true // check Num using an other fields-path: true // check fields-path including maps/slices: true T.Smuggle shortcut func (t *T) Smuggle(got, fn , expectedValue any, args ...any) bool Smuggle is a shortcut for:\nt.Cmp(got, td.Smuggle(fn, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Smuggle godoc.\nExamples Convert example t := td.NewT(\u0026testing.T{}) got := int64(123) ok := t.Smuggle(got, func(n int64) int { return int(n) }, 123, \"checks int64 got against an int value\") fmt.Println(ok) ok = t.Smuggle(\"123\", func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) ok = t.Smuggle(\"123\", func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \"string must contain a number\" } return n, true, \"\" }, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) ok = t.Smuggle(\"123\", func(numStr string) (int, error) { //nolint: gocritic return strconv.Atoi(numStr) }, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) // Short version :) ok = t.Smuggle(\"123\", strconv.Atoi, td.Between(120, 130), \"checks that number in %#v is in [120 .. 130]\") fmt.Println(ok) // Output: // true // true // true // true // true Lax example t := td.NewT(\u0026testing.T{}) // got is an int16 and Smuggle func input is an int64: it is OK got := int(123) ok := t.Smuggle(got, func(n int64) uint32 { return uint32(n) }, uint32(123)) fmt.Println(\"got int16(123) → smuggle via int64 → uint32(123):\", ok) // Output: // got int16(123) → smuggle via int64 → uint32(123): true Auto_unmarshal example t := td.NewT(\u0026testing.T{}) // Automatically json.Unmarshal to compare got := []byte(`{\"a\":1,\"b\":2}`) ok := t.Smuggle(got, func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026r) return }, map[string]int{ \"a\": 1, \"b\": 2, }) fmt.Println(\"JSON contents is OK:\", ok) // Output: // JSON contents is OK: true Cast example t := td.NewT(\u0026testing.T{}) // A string containing JSON got := `{ \"foo\": 123 }` // Automatically cast a string to a json.RawMessage so td.JSON can operate ok := t.Smuggle(got, json.RawMessage{}, td.JSON(`{\"foo\":123}`)) fmt.Println(\"JSON contents in string is OK:\", ok) // Automatically read from io.Reader to a json.RawMessage ok = t.Smuggle(bytes.NewReader([]byte(got)), json.RawMessage{}, td.JSON(`{\"foo\":123}`)) fmt.Println(\"JSON contents just read is OK:\", ok) // Output: // JSON contents in string is OK: true // JSON contents just read is OK: true Complex example t := td.NewT(\u0026testing.T{}) // No end date but a start date and a duration type StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h // for each of these durations in hours for _, duration := range []time.Duration{48 * time.Hour, 72 * time.Hour, 96 * time.Hour} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration, } // Simplest way, but in case of Between() failure, error will be bound // to DATA\u003csmuggled\u003e, not very clear... ok := t.Smuggle(got, func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) // Name the computed value \"ComputedEndDate\" to render a Between() failure // more understandable, so error will be bound to DATA.ComputedEndDate ok = t.Smuggle(got, func(sd StartDuration) td.SmuggledGot { return td.SmuggledGot{ Name: \"ComputedEndDate\", Got: sd.StartDate.Add(sd.Duration), } }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) } // Output: // false // false // true // true // true // true Interface example t := td.NewT(\u0026testing.T{}) gotTime, err := time.Parse(time.RFC3339, \"2018-05-23T12:13:14Z\") if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form ok := t.Smuggle(gotTime, func(s fmt.Stringer) string { return s.String() }, \"2018-05-23 12:13:14 +0000 UTC\") fmt.Println(\"stringified time.Time OK:\", ok) // If got does not implement the fmt.Stringer interface, it fails // without calling the Smuggle func type MyTime time.Time ok = t.Smuggle(MyTime(gotTime), func(s fmt.Stringer) string { fmt.Println(\"Smuggle func called!\") return s.String() }, \"2018-05-23 12:13:14 +0000 UTC\") fmt.Println(\"stringified MyTime OK:\", ok) // Output: // stringified time.Time OK: true // stringified MyTime OK: false Field_path example t := td.NewT(\u0026testing.T{}) type Body struct { Name string Value any } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026Transaction{ Request: Request{ Body: \u0026Body{ Name: \"test\", Value: \u0026ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? ok := t.Smuggle(got, func(tr *Transaction) (int, error) { if tr.Body == nil || tr.Body.Value == nil { return 0, errors.New(\"Request.Body or Request.Body.Value is nil\") } if v, ok := tr.Body.Value.(*ValueNum); ok \u0026\u0026 v != nil { return v.Num, nil } return 0, errors.New(\"Request.Body.Value isn't *ValueNum or nil\") }, td.Between(100, 200)) fmt.Println(\"check Num by hand:\", ok) // Same, but automagically generated... ok = t.Smuggle(got, \"Request.Body.Value.Num\", td.Between(100, 200)) fmt.Println(\"check Num using a fields-path:\", ok) // And as Request is an anonymous field, can be simplified further // as it can be omitted ok = t.Smuggle(got, \"Body.Value.Num\", td.Between(100, 200)) fmt.Println(\"check Num using an other fields-path:\", ok) // Note that maps and array/slices are supported got.Body.Value = map[string]any{ \"foo\": []any{ 3: map[int]string{666: \"bar\"}, }, } ok = t.Smuggle(got, \"Body.Value[foo][3][666]\", \"bar\") fmt.Println(\"check fields-path including maps/slices:\", ok) // Output: // check Num by hand: true // check Num using a fields-path: true // check Num using an other fields-path: true // check fields-path including maps/slices: true",
    "description": "func Smuggle(fn, expectedValue any) TestDeep Smuggle operator allows to change data contents or mutate it into another type before stepping down in favor of generic comparison process. Of course it is a smuggler operator. So fn is a function that must take one parameter whose type must be convertible to the type of the compared value.\nAs convenient shortcuts, fn can be a string specifying a fields-path through structs, maps \u0026 slices, or any other type, in this case a simple cast is done (see below for details).",
    "tags": [],
    "title": "Smuggle",
    "uri": "/operators/smuggle/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Sort(how any, expectedValue any) TestDeep Sort is a smuggler operator. It takes an array, a slice or a pointer on array/slice, it sorts it using how and compares the sorted result to expectedValue. It can be seen as an alternative to Bag.\nhow can be:\nnil or a float64/int \u003e= 0 for a generic ascending order; a float64/int \u003c 0 for a generic descending order; a string specifying a fields-path (optionally prefixed by “+” or “-” for respectively an ascending or a descending order, defaulting to ascending one); a []string containing a list of fields-paths (as above), second and next fields-paths are checked when the previous ones are equal; a function matching func(a, b T) bool signature and returning true if a is before b. A fields-path, also used by Smuggle and Sorted operators, allows to access nested structs fields and maps \u0026 slices items. See Smuggle for details on fields-path possibilities.\ntype A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got := []A{p23, p12, p34} td.Cmp(t, got, td.Sort(\"-props[priority]\", []A{p34, p23, p12})) // succeeds how can be a float64 to allow Sort to be used in expected JSON of JSON, SubJSONOf \u0026 SuperJSONOf operators:\ngot := map[string][]string{\"labels\": {\"c\", \"a\", \"b\"}} td.Cmp(t, got, td.JSON(`{ \"labels\": Sort(1, [\"a\", \"b\", \"c\"]) }`)) // succeeds or using fields-path feature:\ntype Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } got := struct { People []Person `json:\"people\"` }{ People: []Person{ {\"Brian\", 22}, {\"Bob\", 19}, {\"Stephen\", 19}, {\"Alice\", 20}, {\"Marcel\", 25}, }, } td.Cmp(t, got, td.JSON(`{ \"people\": Sort(\"name\", [ // sort by name ascending {\"name\": \"Alice\", \"age\": 20}, {\"name\": \"Bob\", \"age\": 19}, {\"name\": \"Brian\", \"age\": 22}, {\"name\": \"Marcel\", \"age\": 25}, {\"name\": \"Stephen\", \"age\": 19}, ]) }`)) // succeeds td.Cmp(t, got, td.JSON(`{ \"people\": Sort([ \"-age\", \"name\" ], [ // sort by age desc, then by name asc {\"name\": \"Marcel\", \"age\": 25}, {\"name\": \"Brian\", \"age\": 22}, {\"name\": \"Alice\", \"age\": 20}, {\"name\": \"Bob\", \"age\": 19}, {\"name\": \"Stephen\", \"age\": 19}, ]) }`)) // succeeds See also Sorted, Smuggle and Bag.\nSee also Sort godoc.\nExamples Basic example t := \u0026testing.T{} got := []int{-1, 1, 2, -3, 3, -2, 0} // Generic ascending order (≥0 or nil) ok := td.Cmp(t, got, td.Sort(1, []int{-3, -2, -1, 0, 1, 2, 3})) fmt.Println(\"asc order:\", ok) ok = td.Cmp(t, got, td.Sort(0, []int{-3, -2, -1, 0, 1, 2, 3})) fmt.Println(\"asc order:\", ok) ok = td.Cmp(t, got, td.Sort(nil, []int{-3, -2, -1, 0, 1, 2, 3})) fmt.Println(\"asc order:\", ok) // Generic descending order (\u003c 0) ok = td.Cmp(t, got, td.Sort(-1, []int{3, 2, 1, 0, -1, -2, -3})) fmt.Println(\"desc order:\", ok) evenHigher := func(a, b int) bool { if (a%2 == 0) != (b%2 == 0) { return a%2 != 0 } return a \u003c b } ok = td.Cmp(t, got, td.Sort(evenHigher, []int{-3, -1, 1, 3, -2, 0, 2})) fmt.Println(\"even higher order:\", ok) // Output: // asc order: true // asc order: true // asc order: true // desc order: true // even higher order: true Fields_path example t := \u0026testing.T{} type Person struct { Name string Age int } brian := Person{Name: \"Brian\", Age: 22} bob := Person{Name: \"Bob\", Age: 19} stephen := Person{Name: \"Stephen\", Age: 19} alice := Person{Name: \"Alice\", Age: 20} marcel := Person{Name: \"Marcel\", Age: 25} got := []Person{brian, bob, stephen, alice, marcel} ok := td.Cmp(t, got, td.Sort(\"Name\", []Person{alice, bob, brian, marcel, stephen})) fmt.Println(\"by name asc:\", ok) ok = td.Cmp(t, got, td.Sort(\"-Name\", []Person{stephen, marcel, brian, bob, alice})) fmt.Println(\"by name desc:\", ok) ok = td.Cmp(t, got, td.Sort([]string{\"-Age\", \"Name\"}, []Person{marcel, brian, alice, bob, stephen})) fmt.Println(\"by age desc, then by name asc:\", ok) type A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got2 := []A{p23, p12, p34} ok = td.Cmp(t, got2, td.Sort(`-props[priority]`, []A{p34, p23, p12})) fmt.Println(\"by priority desc:\", ok) ok = td.Cmp(t, got2, td.Sort(`props.priority`, []A{p12, p23, p34})) fmt.Println(\"by priority asc:\", ok) // Output: // by name asc: true // by name desc: true // by age desc, then by name asc: true // by priority desc: true // by priority asc: true CmpSort shortcut func CmpSort(t TestingT, got, how , expectedValue any, args ...any) bool CmpSort is a shortcut for:\ntd.Cmp(t, got, td.Sort(how, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSort godoc.\nExamples Basic example t := \u0026testing.T{} got := []int{-1, 1, 2, -3, 3, -2, 0} // Generic ascending order (≥0 or nil) ok := td.CmpSort(t, got, 1, []int{-3, -2, -1, 0, 1, 2, 3}) fmt.Println(\"asc order:\", ok) ok = td.CmpSort(t, got, 0, []int{-3, -2, -1, 0, 1, 2, 3}) fmt.Println(\"asc order:\", ok) ok = td.CmpSort(t, got, nil, []int{-3, -2, -1, 0, 1, 2, 3}) fmt.Println(\"asc order:\", ok) // Generic descending order (\u003c 0) ok = td.CmpSort(t, got, -1, []int{3, 2, 1, 0, -1, -2, -3}) fmt.Println(\"desc order:\", ok) evenHigher := func(a, b int) bool { if (a%2 == 0) != (b%2 == 0) { return a%2 != 0 } return a \u003c b } ok = td.CmpSort(t, got, evenHigher, []int{-3, -1, 1, 3, -2, 0, 2}) fmt.Println(\"even higher order:\", ok) // Output: // asc order: true // asc order: true // asc order: true // desc order: true // even higher order: true Fields_path example t := \u0026testing.T{} type Person struct { Name string Age int } brian := Person{Name: \"Brian\", Age: 22} bob := Person{Name: \"Bob\", Age: 19} stephen := Person{Name: \"Stephen\", Age: 19} alice := Person{Name: \"Alice\", Age: 20} marcel := Person{Name: \"Marcel\", Age: 25} got := []Person{brian, bob, stephen, alice, marcel} ok := td.CmpSort(t, got, \"Name\", []Person{alice, bob, brian, marcel, stephen}) fmt.Println(\"by name asc:\", ok) ok = td.CmpSort(t, got, \"-Name\", []Person{stephen, marcel, brian, bob, alice}) fmt.Println(\"by name desc:\", ok) ok = td.CmpSort(t, got, []string{\"-Age\", \"Name\"}, []Person{marcel, brian, alice, bob, stephen}) fmt.Println(\"by age desc, then by name asc:\", ok) type A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got2 := []A{p23, p12, p34} ok = td.CmpSort(t, got2, `-props[priority]`, []A{p34, p23, p12}) fmt.Println(\"by priority desc:\", ok) ok = td.CmpSort(t, got2, `props.priority`, []A{p12, p23, p34}) fmt.Println(\"by priority asc:\", ok) // Output: // by name asc: true // by name desc: true // by age desc, then by name asc: true // by priority desc: true // by priority asc: true T.Sort shortcut func (t *T) Sort(got, how , expectedValue any, args ...any) bool Sort is a shortcut for:\nt.Cmp(got, td.Sort(how, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Sort godoc.\nExamples Basic example t := td.NewT(\u0026testing.T{}) got := []int{-1, 1, 2, -3, 3, -2, 0} // Generic ascending order (≥0 or nil) ok := t.Sort(got, 1, []int{-3, -2, -1, 0, 1, 2, 3}) fmt.Println(\"asc order:\", ok) ok = t.Sort(got, 0, []int{-3, -2, -1, 0, 1, 2, 3}) fmt.Println(\"asc order:\", ok) ok = t.Sort(got, nil, []int{-3, -2, -1, 0, 1, 2, 3}) fmt.Println(\"asc order:\", ok) // Generic descending order (\u003c 0) ok = t.Sort(got, -1, []int{3, 2, 1, 0, -1, -2, -3}) fmt.Println(\"desc order:\", ok) evenHigher := func(a, b int) bool { if (a%2 == 0) != (b%2 == 0) { return a%2 != 0 } return a \u003c b } ok = t.Sort(got, evenHigher, []int{-3, -1, 1, 3, -2, 0, 2}) fmt.Println(\"even higher order:\", ok) // Output: // asc order: true // asc order: true // asc order: true // desc order: true // even higher order: true Fields_path example t := td.NewT(\u0026testing.T{}) type Person struct { Name string Age int } brian := Person{Name: \"Brian\", Age: 22} bob := Person{Name: \"Bob\", Age: 19} stephen := Person{Name: \"Stephen\", Age: 19} alice := Person{Name: \"Alice\", Age: 20} marcel := Person{Name: \"Marcel\", Age: 25} got := []Person{brian, bob, stephen, alice, marcel} ok := t.Sort(got, \"Name\", []Person{alice, bob, brian, marcel, stephen}) fmt.Println(\"by name asc:\", ok) ok = t.Sort(got, \"-Name\", []Person{stephen, marcel, brian, bob, alice}) fmt.Println(\"by name desc:\", ok) ok = t.Sort(got, []string{\"-Age\", \"Name\"}, []Person{marcel, brian, alice, bob, stephen}) fmt.Println(\"by age desc, then by name asc:\", ok) type A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got2 := []A{p23, p12, p34} ok = t.Sort(got2, `-props[priority]`, []A{p34, p23, p12}) fmt.Println(\"by priority desc:\", ok) ok = t.Sort(got2, `props.priority`, []A{p12, p23, p34}) fmt.Println(\"by priority asc:\", ok) // Output: // by name asc: true // by name desc: true // by age desc, then by name asc: true // by priority desc: true // by priority asc: true",
    "description": "func Sort(how any, expectedValue any) TestDeep Sort is a smuggler operator. It takes an array, a slice or a pointer on array/slice, it sorts it using how and compares the sorted result to expectedValue. It can be seen as an alternative to Bag.\nhow can be:\nnil or a float64/int \u003e= 0 for a generic ascending order; a float64/int \u003c 0 for a generic descending order; a string specifying a fields-path (optionally prefixed by “+” or “-” for respectively an ascending or a descending order, defaulting to ascending one); a []string containing a list of fields-paths (as above), second and next fields-paths are checked when the previous ones are equal; a function matching func(a, b T) bool signature and returning true if a is before b. A fields-path, also used by Smuggle and Sorted operators, allows to access nested structs fields and maps \u0026 slices items. See Smuggle for details on fields-path possibilities.",
    "tags": [],
    "title": "Sort",
    "uri": "/operators/sort/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Sorted(how ...any) TestDeep Sorted operator checks that data is an array, a slice or a pointer on array/slice, and it is well sorted as how tells it should be.\nhow… can be:\nempty to check a generic ascending order; nil or a float64/int \u003e= 0 to check a generic ascending order; a float64/int \u003c 0 to check a generic descending order; strings specifying fields-paths (each optionally prefixed by “+” or “-” for respectively checking an ascending or a descending order, defaulting to ascending one); a function matching func(a, b T) bool signature and returning true if a is before b. A fields-path, also used by Smuggle and Sort operators, allows to access nested structs fields and maps \u0026 slices items. See Smuggle for details on fields-path possibilities.\ntype A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got := []A{p34, p23, p12} td.Cmp(t, got, td.Sorted(\"-props[priority]\")) // succeeds how can be a float64 to allow Sort to be used in expected JSON of JSON, SubJSONOf \u0026 SuperJSONOf operators:\ngot := map[string][]string{\"labels\": {\"a\", \"b\", \"c\"}} td.Cmp(t, got, td.JSON(`{ \"labels\": Sorted }`)) // succeeds or using fields-path feature:\ntype Person struct { Name string `json:\"name\"` Age int `json:\"age\"` } got := struct { People []Person `json:\"people\"` }{ People: []Person{ {\"Marcel\", 25}, {\"Brian\", 22}, {\"Alice\", 20}, {\"Bob\", 19}, {\"Stephen\", 19}, }, } // sorted by age desc, then by name asc td.Cmp(t, got, td.JSON(`{ \"people\": Sorted(\"-age\", \"name\") }`)) // succeeds See also Sort.\nSee also Sorted godoc.\nExamples Basic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.Cmp(t, got, td.Sorted()) fmt.Println(\"is asc order (default):\", ok) ok = td.Cmp(t, got, td.Sorted(1)) fmt.Println(\"is asc order (1):\", ok) ok = td.Cmp(t, got, td.Sorted(0)) fmt.Println(\"is asc order (0):\", ok) ok = td.Cmp(t, got, td.Sorted(nil)) fmt.Println(\"is asc order (nil):\", ok) ok = td.Cmp(t, got, td.Sorted(-1)) fmt.Println(\"is desc order:\", ok) got = []int{-3, -1, 1, 3, -2, 0, 2} evenHigher := func(a, b int) bool { if (a%2 == 0) != (b%2 == 0) { return a%2 != 0 } return a \u003c b } ok = td.Cmp(t, got, td.Sorted(evenHigher)) fmt.Println(\"is even higher order:\", ok) // Output: // is asc order (default): true // is asc order (1): true // is asc order (0): true // is asc order (nil): true // is desc order: false // is even higher order: true Fields_path example t := \u0026testing.T{} type Person struct { Name string Age int } alice := Person{Name: \"Alice\", Age: 20} bob := Person{Name: \"Bob\", Age: 19} brian := Person{Name: \"Brian\", Age: 22} marcel := Person{Name: \"Marcel\", Age: 25} stephen := Person{Name: \"Stephen\", Age: 19} got := []Person{alice, bob, brian, marcel, stephen} ok := td.Cmp(t, got, td.Sorted(\"Name\")) fmt.Println(\"is sorted by name asc:\", ok) got = []Person{stephen, marcel, brian, bob, alice} ok = td.Cmp(t, got, td.Sorted(\"-Name\")) fmt.Println(\"is sorted by name desc:\", ok) got = []Person{marcel, brian, alice, bob, stephen} ok = td.Cmp(t, got, td.Sorted(\"-Age\", \"Name\")) fmt.Println(\"is sorted by age desc, then by name asc 1:\", ok) got = []Person{marcel, brian, alice, stephen, bob} ok = td.Cmp(t, got, td.Sorted(\"-Age\", \"Name\")) fmt.Println(\"is sorted by age desc, then by name asc 2:\", ok) type A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got2 := []A{p34, p23, p12} ok = td.Cmp(t, got2, td.Sorted(`-props[priority]`)) fmt.Println(\"is sorted by priority desc:\", ok) ok = td.Cmp(t, got2, td.Sorted(`props.priority`)) fmt.Println(\"is sorted by priority asc:\", ok) // Output: // is sorted by name asc: true // is sorted by name desc: true // is sorted by age desc, then by name asc 1: true // is sorted by age desc, then by name asc 2: false // is sorted by priority desc: true // is sorted by priority asc: false CmpSorted shortcut func CmpSorted(t TestingT, got, how any, args ...any) bool CmpSorted is a shortcut for:\ntd.Cmp(t, got, td.Sorted(how), args...) See above for details.\nSorted optional parameter how is here mandatory. nil value should be passed to mimic its absence in original Sorted call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSorted godoc.\nExamples Basic example t := \u0026testing.T{} got := []int{-3, -2, -1, 0, 1, 2, 3} ok := td.CmpSorted(t, got, nil) fmt.Println(\"is asc order (default):\", ok) ok = td.CmpSorted(t, got, 1) fmt.Println(\"is asc order (1):\", ok) ok = td.CmpSorted(t, got, 0) fmt.Println(\"is asc order (0):\", ok) ok = td.CmpSorted(t, got, nil) fmt.Println(\"is asc order (nil):\", ok) ok = td.CmpSorted(t, got, -1) fmt.Println(\"is desc order:\", ok) got = []int{-3, -1, 1, 3, -2, 0, 2} evenHigher := func(a, b int) bool { if (a%2 == 0) != (b%2 == 0) { return a%2 != 0 } return a \u003c b } ok = td.CmpSorted(t, got, evenHigher) fmt.Println(\"is even higher order:\", ok) // Output: // is asc order (default): true // is asc order (1): true // is asc order (0): true // is asc order (nil): true // is desc order: false // is even higher order: true Fields_path example t := \u0026testing.T{} type Person struct { Name string Age int } alice := Person{Name: \"Alice\", Age: 20} bob := Person{Name: \"Bob\", Age: 19} brian := Person{Name: \"Brian\", Age: 22} marcel := Person{Name: \"Marcel\", Age: 25} stephen := Person{Name: \"Stephen\", Age: 19} got := []Person{alice, bob, brian, marcel, stephen} ok := td.CmpSorted(t, got, \"Name\") fmt.Println(\"is sorted by name asc:\", ok) got = []Person{stephen, marcel, brian, bob, alice} ok = td.CmpSorted(t, got, \"-Name\") fmt.Println(\"is sorted by name desc:\", ok) got = []Person{marcel, brian, alice, bob, stephen} ok = td.CmpSorted(t, got, []string{\"-Age\", \"Name\"}) fmt.Println(\"is sorted by age desc, then by name asc 1:\", ok) got = []Person{marcel, brian, alice, stephen, bob} ok = td.CmpSorted(t, got, []string{\"-Age\", \"Name\"}) fmt.Println(\"is sorted by age desc, then by name asc 2:\", ok) type A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got2 := []A{p34, p23, p12} ok = td.CmpSorted(t, got2, `-props[priority]`) fmt.Println(\"is sorted by priority desc:\", ok) ok = td.CmpSorted(t, got2, `props.priority`) fmt.Println(\"is sorted by priority asc:\", ok) // Output: // is sorted by name asc: true // is sorted by name desc: true // is sorted by age desc, then by name asc 1: true // is sorted by age desc, then by name asc 2: false // is sorted by priority desc: true // is sorted by priority asc: false T.Sorted shortcut func (t *T) Sorted(got, how any, args ...any) bool Sorted is a shortcut for:\nt.Cmp(got, td.Sorted(how), args...) See above for details.\nSorted optional parameter how is here mandatory. nil value should be passed to mimic its absence in original Sorted call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Sorted godoc.\nExamples Basic example t := td.NewT(\u0026testing.T{}) got := []int{-3, -2, -1, 0, 1, 2, 3} ok := t.Sorted(got, nil) fmt.Println(\"is asc order (default):\", ok) ok = t.Sorted(got, 1) fmt.Println(\"is asc order (1):\", ok) ok = t.Sorted(got, 0) fmt.Println(\"is asc order (0):\", ok) ok = t.Sorted(got, nil) fmt.Println(\"is asc order (nil):\", ok) ok = t.Sorted(got, -1) fmt.Println(\"is desc order:\", ok) got = []int{-3, -1, 1, 3, -2, 0, 2} evenHigher := func(a, b int) bool { if (a%2 == 0) != (b%2 == 0) { return a%2 != 0 } return a \u003c b } ok = t.Sorted(got, evenHigher) fmt.Println(\"is even higher order:\", ok) // Output: // is asc order (default): true // is asc order (1): true // is asc order (0): true // is asc order (nil): true // is desc order: false // is even higher order: true Fields_path example t := td.NewT(\u0026testing.T{}) type Person struct { Name string Age int } alice := Person{Name: \"Alice\", Age: 20} bob := Person{Name: \"Bob\", Age: 19} brian := Person{Name: \"Brian\", Age: 22} marcel := Person{Name: \"Marcel\", Age: 25} stephen := Person{Name: \"Stephen\", Age: 19} got := []Person{alice, bob, brian, marcel, stephen} ok := t.Sorted(got, \"Name\") fmt.Println(\"is sorted by name asc:\", ok) got = []Person{stephen, marcel, brian, bob, alice} ok = t.Sorted(got, \"-Name\") fmt.Println(\"is sorted by name desc:\", ok) got = []Person{marcel, brian, alice, bob, stephen} ok = t.Sorted(got, []string{\"-Age\", \"Name\"}) fmt.Println(\"is sorted by age desc, then by name asc 1:\", ok) got = []Person{marcel, brian, alice, stephen, bob} ok = t.Sorted(got, []string{\"-Age\", \"Name\"}) fmt.Println(\"is sorted by age desc, then by name asc 2:\", ok) type A struct{ props map[string]int } p12 := A{props: map[string]int{\"priority\": 12}} p23 := A{props: map[string]int{\"priority\": 23}} p34 := A{props: map[string]int{\"priority\": 34}} got2 := []A{p34, p23, p12} ok = t.Sorted(got2, `-props[priority]`) fmt.Println(\"is sorted by priority desc:\", ok) ok = t.Sorted(got2, `props.priority`) fmt.Println(\"is sorted by priority asc:\", ok) // Output: // is sorted by name asc: true // is sorted by name desc: true // is sorted by age desc, then by name asc 1: true // is sorted by age desc, then by name asc 2: false // is sorted by priority desc: true // is sorted by priority asc: false",
    "description": "func Sorted(how ...any) TestDeep Sorted operator checks that data is an array, a slice or a pointer on array/slice, and it is well sorted as how tells it should be.\nhow… can be:\nempty to check a generic ascending order; nil or a float64/int \u003e= 0 to check a generic ascending order; a float64/int \u003c 0 to check a generic descending order; strings specifying fields-paths (each optionally prefixed by “+” or “-” for respectively checking an ascending or a descending order, defaulting to ascending one); a function matching func(a, b T) bool signature and returning true if a is before b. A fields-path, also used by Smuggle and Sort operators, allows to access nested structs fields and maps \u0026 slices items. See Smuggle for details on fields-path possibilities.",
    "tags": [],
    "title": "Sorted",
    "uri": "/operators/sorted/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SStruct(model any, expectedFields ...StructFields) TestDeep SStruct operator (aka strict-Struct) compares the contents of a struct or a pointer on a struct against values of model (if any) and the values of expectedFields. The zero values are compared too even if they are omitted from expectedFields: that is the difference with Struct operator.\nmodel must be the same type as compared data. If the expected type is private or anonymous, model can be nil. In this case it is considered lazy and determined each time the operator is involved in a match, see below.\nexpectedFields can be omitted, if no TestDeep operators are involved. If expectedFields contains more than one item, all items are merged before their use, from left to right.\nTo ignore a field, one has to specify it in expectedFields and use the Ignore operator.\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", }, td.StructFields{ \"Children\": 4, }, td.StructFields{ \"Age\": td.Between(40, 45), \"Children\": td.Ignore(), // overwrite 4 }), ) It is an error to set a non-zero field in model AND to set the same field in expectedFields, as in such cases the SStruct operator does not know if the user wants to override the non-zero model field value or if it is an error. To explicitly override a non-zero model in expectedFields, just prefix its name with a “\u003e” (followed by some optional spaces), as in:\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", Age: 23, Children: 4, }, td.StructFields{ \"\u003e Age\": td.Between(40, 45), \"\u003eChildren\": 0, // spaces after \"\u003e\" are optional }), ) expectedFields can also contain regexps or shell patterns to match multiple fields not explicitly listed in model and in expectedFields. Regexps are prefixed by “=~” or “!~” to respectively match or don’t-match. Shell patterns are prefixed by “=” or “!” to respectively match or don’t-match.\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", }, td.StructFields{ \"=*At\": td.Lte(time.Now()), // matches CreatedAt \u0026 UpdatedAt fields using shell pattern \"=~^[a-z]\": td.Ignore(), // explicitly ignore private fields using a regexp }), ) When several patterns can match a same field, it is advised to tell go-testdeep in which order patterns should be tested, as once a pattern matches a field, the other patterns are ignored for this field. To do so, each pattern can be prefixed by a number, as in:\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", }, td.StructFields{ \"1=*At\": td.Lte(time.Now()), \"2=~^[a-z]\": td.NotNil(), }), ) This way, “*At” shell pattern is always used before “^[a-z]” regexp, so if a field “createdAt” exists it is tested against time.Now() and never against NotNil. A pattern without a prefix number is the same as specifying “0” as prefix.\nTo make it clearer, some spaces can be added, as well as bigger numbers used:\ntd.Cmp(t, got, td.SStruct( Person{ Name: \"John Doe\", }, td.StructFields{ \" 900 = *At\": td.Lte(time.Now()), \"2000 =~ ^[a-z]\": td.NotNil(), }), ) The following example combines all possibilities:\ntd.Cmp(t, got, td.SStruct( Person{ NickName: \"Joe\", }, td.StructFields{ \"Firstname\": td.Any(\"John\", \"Johnny\"), \"1 = *[nN]ame\": td.NotEmpty(), // matches LastName, lastname, … \"2 ! [A-Z]*\": td.NotZero(), // matches all private fields \"3 =~ ^(Crea|Upda)tedAt$\": td.Gte(time.Now()), \"4 !~ ^(Dogs|Children)$\": td.Zero(), // matches all remaining fields except Dogs and Children \"5 =~ .\": td.NotNil(), // matches all remaining fields (same as \"5 = *\") }), ) If the expected type is private to the current package, it cannot be passed as model. To overcome this limitation, model can be nil, it is then considered as lazy. This way, the model is automatically set during each match to the same type (still requiring struct or struct pointer) of the compared data. Similarly, testing an anonymous struct can be boring as all fields have to be re-declared to define model. A nil model avoids that:\ngot := struct { name string age int }{\"Bob\", 42} td.Cmp(t, got, td.SStruct(nil, td.StructFields{ \"name\": \"Bob\", \"age\": td.Between(40, 42), })) During a match, all expected and zero fields must be found to succeed.\nTypeBehind method returns the reflect.Type of model.\nSee also SStruct.\nSee also SStruct godoc.\nExamples Base example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 0, } // NumChildren is not listed in expected fields so it must be zero ok := td.Cmp(t, got, td.SStruct(Person{Name: \"Foobar\"}, td.StructFields{ \"Age\": td.Between(40, 50), }), \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Model can be empty got.NumChildren = 3 ok = td.Cmp(t, got, td.SStruct(Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }), \"checks %v is the right Person\") fmt.Println(\"Foobar has some children:\", ok) // Works with pointers too ok = td.Cmp(t, \u0026got, td.SStruct(\u0026Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }), \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using pointer):\", ok) // Model does not need to be instanciated ok = td.Cmp(t, \u0026got, td.SStruct((*Person)(nil), td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }), \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using nil model):\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar has some children: true // Foobar has some children (using pointer): true // Foobar has some children (using nil model): true Overwrite_model example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } ok := td.Cmp(t, got, td.SStruct( Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003eAge\": td.Between(40, 50), // \"\u003e\" to overwrite Age:53 in model \"NumChildren\": td.Gt(2), }), \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) ok = td.Cmp(t, got, td.SStruct( Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003e Age\": td.Between(40, 50), // same, \"\u003e\" can be followed by spaces \"NumChildren\": td.Gt(2), }), \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar is between 40 \u0026 50: true Patterns example t := \u0026testing.T{} type Person struct { Firstname string Lastname string Surname string Nickname string CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time id int64 secret string } now := time.Now() got := Person{ Firstname: \"Maxime\", Lastname: \"Foo\", Surname: \"Max\", Nickname: \"max\", CreatedAt: now, UpdatedAt: now, DeletedAt: nil, // not deleted yet id: 2345, secret: \"5ecr3T\", } ok := td.Cmp(t, got, td.SStruct(Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `= *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `=~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt `! [A-Z]*`: td.Ignore(), // private fields }), \"mix shell \u0026 regexp patterns\") fmt.Println(\"Patterns match only remaining fields:\", ok) ok = td.Cmp(t, got, td.SStruct(Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `1 = *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `2 =~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt `3 !~ ^[A-Z]`: td.Ignore(), // private fields }), \"ordered patterns\") fmt.Println(\"Ordered patterns match only remaining fields:\", ok) // Output: // Patterns match only remaining fields: true // Ordered patterns match only remaining fields: true Lazy_model example t := \u0026testing.T{} got := struct { name string age int }{ name: \"Foobar\", age: 42, } ok := td.Cmp(t, got, td.SStruct(nil, td.StructFields{ \"name\": \"Foobar\", \"age\": td.Between(40, 45), })) fmt.Println(\"Lazy model:\", ok) ok = td.Cmp(t, got, td.SStruct(nil, td.StructFields{ \"name\": \"Foobar\", \"zip\": 666, })) fmt.Println(\"Lazy model with unknown field:\", ok) // Output: // Lazy model: true // Lazy model with unknown field: false CmpSStruct shortcut func CmpSStruct(t TestingT, got, model any, expectedFields StructFields, args ...any) bool CmpSStruct is a shortcut for:\ntd.Cmp(t, got, td.SStruct(model, expectedFields), args...) See above for details.\nSStruct optional parameter expectedFields is here mandatory. nil value should be passed to mimic its absence in original SStruct call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSStruct godoc.\nExamples Base example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 0, } // NumChildren is not listed in expected fields so it must be zero ok := td.CmpSStruct(t, got, Person{Name: \"Foobar\"}, td.StructFields{ \"Age\": td.Between(40, 50), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Model can be empty got.NumChildren = 3 ok = td.CmpSStruct(t, got, Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children:\", ok) // Works with pointers too ok = td.CmpSStruct(t, \u0026got, \u0026Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using pointer):\", ok) // Model does not need to be instanciated ok = td.CmpSStruct(t, \u0026got, (*Person)(nil), td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using nil model):\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar has some children: true // Foobar has some children (using pointer): true // Foobar has some children (using nil model): true Overwrite_model example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } ok := td.CmpSStruct(t, got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003eAge\": td.Between(40, 50), // \"\u003e\" to overwrite Age:53 in model \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) ok = td.CmpSStruct(t, got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003e Age\": td.Between(40, 50), // same, \"\u003e\" can be followed by spaces \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar is between 40 \u0026 50: true Patterns example t := \u0026testing.T{} type Person struct { Firstname string Lastname string Surname string Nickname string CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time id int64 secret string } now := time.Now() got := Person{ Firstname: \"Maxime\", Lastname: \"Foo\", Surname: \"Max\", Nickname: \"max\", CreatedAt: now, UpdatedAt: now, DeletedAt: nil, // not deleted yet id: 2345, secret: \"5ecr3T\", } ok := td.CmpSStruct(t, got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `= *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `=~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt `! [A-Z]*`: td.Ignore(), // private fields }, \"mix shell \u0026 regexp patterns\") fmt.Println(\"Patterns match only remaining fields:\", ok) ok = td.CmpSStruct(t, got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `1 = *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `2 =~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt `3 !~ ^[A-Z]`: td.Ignore(), // private fields }, \"ordered patterns\") fmt.Println(\"Ordered patterns match only remaining fields:\", ok) // Output: // Patterns match only remaining fields: true // Ordered patterns match only remaining fields: true Lazy_model example t := \u0026testing.T{} got := struct { name string age int }{ name: \"Foobar\", age: 42, } ok := td.CmpSStruct(t, got, nil, td.StructFields{ \"name\": \"Foobar\", \"age\": td.Between(40, 45), }) fmt.Println(\"Lazy model:\", ok) ok = td.CmpSStruct(t, got, nil, td.StructFields{ \"name\": \"Foobar\", \"zip\": 666, }) fmt.Println(\"Lazy model with unknown field:\", ok) // Output: // Lazy model: true // Lazy model with unknown field: false T.SStruct shortcut func (t *T) SStruct(got, model any, expectedFields StructFields, args ...any) bool SStruct is a shortcut for:\nt.Cmp(got, td.SStruct(model, expectedFields), args...) See above for details.\nSStruct optional parameter expectedFields is here mandatory. nil value should be passed to mimic its absence in original SStruct call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SStruct godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 0, } // NumChildren is not listed in expected fields so it must be zero ok := t.SStruct(got, Person{Name: \"Foobar\"}, td.StructFields{ \"Age\": td.Between(40, 50), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Model can be empty got.NumChildren = 3 ok = t.SStruct(got, Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children:\", ok) // Works with pointers too ok = t.SStruct(\u0026got, \u0026Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using pointer):\", ok) // Model does not need to be instanciated ok = t.SStruct(\u0026got, (*Person)(nil), td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using nil model):\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar has some children: true // Foobar has some children (using pointer): true // Foobar has some children (using nil model): true Overwrite_model example t := td.NewT(\u0026testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } ok := t.SStruct(got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003eAge\": td.Between(40, 50), // \"\u003e\" to overwrite Age:53 in model \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) ok = t.SStruct(got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003e Age\": td.Between(40, 50), // same, \"\u003e\" can be followed by spaces \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar is between 40 \u0026 50: true Patterns example t := td.NewT(\u0026testing.T{}) type Person struct { Firstname string Lastname string Surname string Nickname string CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time id int64 secret string } now := time.Now() got := Person{ Firstname: \"Maxime\", Lastname: \"Foo\", Surname: \"Max\", Nickname: \"max\", CreatedAt: now, UpdatedAt: now, DeletedAt: nil, // not deleted yet id: 2345, secret: \"5ecr3T\", } ok := t.SStruct(got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `= *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `=~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt `! [A-Z]*`: td.Ignore(), // private fields }, \"mix shell \u0026 regexp patterns\") fmt.Println(\"Patterns match only remaining fields:\", ok) ok = t.SStruct(got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `1 = *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `2 =~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt `3 !~ ^[A-Z]`: td.Ignore(), // private fields }, \"ordered patterns\") fmt.Println(\"Ordered patterns match only remaining fields:\", ok) // Output: // Patterns match only remaining fields: true // Ordered patterns match only remaining fields: true Lazy_model example t := td.NewT(\u0026testing.T{}) got := struct { name string age int }{ name: \"Foobar\", age: 42, } ok := t.SStruct(got, nil, td.StructFields{ \"name\": \"Foobar\", \"age\": td.Between(40, 45), }) fmt.Println(\"Lazy model:\", ok) ok = t.SStruct(got, nil, td.StructFields{ \"name\": \"Foobar\", \"zip\": 666, }) fmt.Println(\"Lazy model with unknown field:\", ok) // Output: // Lazy model: true // Lazy model with unknown field: false",
    "description": "func SStruct(model any, expectedFields ...StructFields) TestDeep SStruct operator (aka strict-Struct) compares the contents of a struct or a pointer on a struct against values of model (if any) and the values of expectedFields. The zero values are compared too even if they are omitted from expectedFields: that is the difference with Struct operator.\nmodel must be the same type as compared data. If the expected type is private or anonymous, model can be nil. In this case it is considered lazy and determined each time the operator is involved in a match, see below.",
    "tags": [],
    "title": "SStruct",
    "uri": "/operators/sstruct/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func String(expected string) TestDeep String operator allows to compare a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\nerr := errors.New(\"error!\") td.Cmp(t, err, td.String(\"error!\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.String(\"fmt.Stringer!\")) // succeeds See also Contains, HasPrefix, HasSuffix, Re and ReAll.\nSee also String godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.String(\"foobar\"), \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.String(\"foobar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.String(\"foobar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.String(\"foobar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true CmpString shortcut func CmpString(t TestingT, got any, expected string, args ...any) bool CmpString is a shortcut for:\ntd.Cmp(t, got, td.String(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpString godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.CmpString(t, got, \"foobar\", \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.String(\"foobar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.CmpString(t, got, \"foobar\", \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.CmpString(t, got, \"foobar\", \"checks %s\", got) fmt.Println(ok) // Output: // true T.String shortcut func (t *T) String(got any, expected string, args ...any) bool String is a shortcut for:\nt.Cmp(got, td.String(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.String godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) got := \"foobar\" ok := t.String(got, \"foobar\", \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = t.Cmp([]byte(got), td.String(\"foobar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := td.NewT(\u0026testing.T{}) // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := t.String(got, \"foobar\", \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := td.NewT(\u0026testing.T{}) got := errors.New(\"foobar\") ok := t.String(got, \"foobar\", \"checks %s\", got) fmt.Println(ok) // Output: // true",
    "description": "func String(expected string) TestDeep String operator allows to compare a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\nerr := errors.New(\"error!\") td.Cmp(t, err, td.String(\"error!\")) // succeeds bstr := bytes.NewBufferString(\"fmt.Stringer!\") td.Cmp(t, bstr, td.String(\"fmt.Stringer!\")) // succeeds See also Contains, HasPrefix, HasSuffix, Re and ReAll.\nSee also String godoc.\nExamples Base example t := \u0026testing.T{} got := \"foobar\" ok := td.Cmp(t, got, td.String(\"foobar\"), \"checks %s\", got) fmt.Println(\"using string:\", ok) ok = td.Cmp(t, []byte(got), td.String(\"foobar\"), \"checks %s\", got) fmt.Println(\"using []byte:\", ok) // Output: // using string: true // using []byte: true Stringer example t := \u0026testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString(\"foobar\") ok := td.Cmp(t, got, td.String(\"foobar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true Error example t := \u0026testing.T{} got := errors.New(\"foobar\") ok := td.Cmp(t, got, td.String(\"foobar\"), \"checks %s\", got) fmt.Println(ok) // Output: // true",
    "tags": [],
    "title": "String",
    "uri": "/operators/string/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Struct(model any, expectedFields ...StructFields) TestDeep Struct operator compares the contents of a struct or a pointer on a struct against the non-zero values of model (if any) and the values of expectedFields. See SStruct to compares against zero fields without specifying them in expectedFields.\nmodel must be the same type as compared data. If the expected type is anonymous or private, model can be nil. In this case it is considered lazy and determined each time the operator is involved in a match, see below.\nexpectedFields can be omitted, if no zero entries are expected and no TestDeep operators are involved. If expectedFields contains more than one item, all items are merged before their use, from left to right.\ntd.Cmp(t, got, td.Struct( Person{ Name: \"John Doe\", }, td.StructFields{ \"Children\": 4, }, td.StructFields{ \"Age\": td.Between(40, 45), \"Children\": 0, // overwrite 4 }), ) It is an error to set a non-zero field in model AND to set the same field in expectedFields, as in such cases the Struct operator does not know if the user wants to override the non-zero model field value or if it is an error. To explicitly override a non-zero model in expectedFields, just prefix its name with a “\u003e” (followed by some optional spaces), as in:\ntd.Cmp(t, got, td.Struct( Person{ Name: \"John Doe\", Age: 23, Children: 4, }, td.StructFields{ \"\u003e Age\": td.Between(40, 45), \"\u003eChildren\": 0, // spaces after \"\u003e\" are optional }), ) expectedFields can also contain regexps or shell patterns to match multiple fields not explicitly listed in model and in expectedFields. Regexps are prefixed by “=~” or “!~” to respectively match or don’t-match. Shell patterns are prefixed by “=” or “!” to respectively match or don’t-match.\ntd.Cmp(t, got, td.Struct( Person{ Name: \"John Doe\", }, td.StructFields{ \"=*At\": td.Lte(time.Now()), // matches CreatedAt \u0026 UpdatedAt fields using shell pattern \"=~^[a-z]\": td.Ignore(), // explicitly ignore private fields using a regexp }), ) When several patterns can match a same field, it is advised to tell go-testdeep in which order patterns should be tested, as once a pattern matches a field, the other patterns are ignored for this field. To do so, each pattern can be prefixed by a number, as in:\ntd.Cmp(t, got, td.Struct( Person{ Name: \"John Doe\", }, td.StructFields{ \"1=*At\": td.Lte(time.Now()), \"2=~^[a-z]\": td.NotNil(), }), ) This way, “*At” shell pattern is always used before “^[a-z]” regexp, so if a field “createdAt” exists it is tested against time.Now() and never against NotNil. A pattern without a prefix number is the same as specifying “0” as prefix.\nTo make it clearer, some spaces can be added, as well as bigger numbers used:\ntd.Cmp(t, got, td.Struct( Person{ Name: \"John Doe\", }, td.StructFields{ \" 900 = *At\": td.Lte(time.Now()), \"2000 =~ ^[a-z]\": td.NotNil(), }), ) The following example combines all possibilities:\ntd.Cmp(t, got, td.Struct( Person{ NickName: \"Joe\", }, td.StructFields{ \"Firstname\": td.Any(\"John\", \"Johnny\"), \"1 = *[nN]ame\": td.NotEmpty(), // matches LastName, lastname, … \"2 ! [A-Z]*\": td.NotZero(), // matches all private fields \"3 =~ ^(Crea|Upda)tedAt$\": td.Gte(time.Now()), \"4 !~ ^(Dogs|Children)$\": td.Zero(), // matches all remaining fields except Dogs and Children \"5 =~ .\": td.NotNil(), // matches all remaining fields (same as \"5 = *\") }), ) If the expected type is private to the current package, it cannot be passed as model. To overcome this limitation, model can be nil, it is then considered as lazy. This way, the model is automatically set during each match to the same type (still requiring struct or struct pointer) of the compared data. Similarly, testing an anonymous struct can be boring as all fields have to be re-declared to define model. A nil model avoids that:\ngot := struct { name string age int }{\"Bob\", 42} td.Cmp(t, got, td.Struct(nil, td.StructFields{\"age\": td.Between(40, 42)})) During a match, all expected fields must be found to succeed. Non-expected fields (and so zero model fields) are ignored.\nTypeBehind method returns the reflect.Type of model.\nSee also SStruct.\nSee also Struct godoc.\nExamples Base example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked ok := td.Cmp(t, got, td.Struct(Person{Name: \"Foobar\"}, td.StructFields{ \"Age\": td.Between(40, 50), }), \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Model can be empty ok = td.Cmp(t, got, td.Struct(Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }), \"checks %v is the right Person\") fmt.Println(\"Foobar has some children:\", ok) // Works with pointers too ok = td.Cmp(t, \u0026got, td.Struct(\u0026Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }), \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using pointer):\", ok) // Model does not need to be instanciated ok = td.Cmp(t, \u0026got, td.Struct((*Person)(nil), td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }), \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using nil model):\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar has some children: true // Foobar has some children (using pointer): true // Foobar has some children (using nil model): true Overwrite_model example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } ok := td.Cmp(t, got, td.Struct( Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003eAge\": td.Between(40, 50), // \"\u003e\" to overwrite Age:53 in model \"NumChildren\": td.Gt(2), }), \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) ok = td.Cmp(t, got, td.Struct( Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003e Age\": td.Between(40, 50), // same, \"\u003e\" can be followed by spaces \"NumChildren\": td.Gt(2), }), \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar is between 40 \u0026 50: true Patterns example t := \u0026testing.T{} type Person struct { Firstname string Lastname string Surname string Nickname string CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time } now := time.Now() got := Person{ Firstname: \"Maxime\", Lastname: \"Foo\", Surname: \"Max\", Nickname: \"max\", CreatedAt: now, UpdatedAt: now, DeletedAt: nil, // not deleted yet } ok := td.Cmp(t, got, td.Struct(Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `= *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `=~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt }), \"mix shell \u0026 regexp patterns\") fmt.Println(\"Patterns match only remaining fields:\", ok) ok = td.Cmp(t, got, td.Struct(Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `1 = *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `2 =~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt }), \"ordered patterns\") fmt.Println(\"Ordered patterns match only remaining fields:\", ok) // Output: // Patterns match only remaining fields: true // Ordered patterns match only remaining fields: true Lazy_model example t := \u0026testing.T{} got := struct { name string age int }{ name: \"Foobar\", age: 42, } ok := td.Cmp(t, got, td.Struct(nil, td.StructFields{ \"name\": \"Foobar\", \"age\": td.Between(40, 45), })) fmt.Println(\"Lazy model:\", ok) ok = td.Cmp(t, got, td.Struct(nil, td.StructFields{ \"name\": \"Foobar\", \"zip\": 666, })) fmt.Println(\"Lazy model with unknown field:\", ok) // Output: // Lazy model: true // Lazy model with unknown field: false CmpStruct shortcut func CmpStruct(t TestingT, got, model any, expectedFields StructFields, args ...any) bool CmpStruct is a shortcut for:\ntd.Cmp(t, got, td.Struct(model, expectedFields), args...) See above for details.\nStruct optional parameter expectedFields is here mandatory. nil value should be passed to mimic its absence in original Struct call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpStruct godoc.\nExamples Base example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked ok := td.CmpStruct(t, got, Person{Name: \"Foobar\"}, td.StructFields{ \"Age\": td.Between(40, 50), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Model can be empty ok = td.CmpStruct(t, got, Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children:\", ok) // Works with pointers too ok = td.CmpStruct(t, \u0026got, \u0026Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using pointer):\", ok) // Model does not need to be instanciated ok = td.CmpStruct(t, \u0026got, (*Person)(nil), td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using nil model):\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar has some children: true // Foobar has some children (using pointer): true // Foobar has some children (using nil model): true Overwrite_model example t := \u0026testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } ok := td.CmpStruct(t, got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003eAge\": td.Between(40, 50), // \"\u003e\" to overwrite Age:53 in model \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) ok = td.CmpStruct(t, got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003e Age\": td.Between(40, 50), // same, \"\u003e\" can be followed by spaces \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar is between 40 \u0026 50: true Patterns example t := \u0026testing.T{} type Person struct { Firstname string Lastname string Surname string Nickname string CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time } now := time.Now() got := Person{ Firstname: \"Maxime\", Lastname: \"Foo\", Surname: \"Max\", Nickname: \"max\", CreatedAt: now, UpdatedAt: now, DeletedAt: nil, // not deleted yet } ok := td.CmpStruct(t, got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `= *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `=~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt }, \"mix shell \u0026 regexp patterns\") fmt.Println(\"Patterns match only remaining fields:\", ok) ok = td.CmpStruct(t, got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `1 = *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `2 =~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt }, \"ordered patterns\") fmt.Println(\"Ordered patterns match only remaining fields:\", ok) // Output: // Patterns match only remaining fields: true // Ordered patterns match only remaining fields: true Lazy_model example t := \u0026testing.T{} got := struct { name string age int }{ name: \"Foobar\", age: 42, } ok := td.CmpStruct(t, got, nil, td.StructFields{ \"name\": \"Foobar\", \"age\": td.Between(40, 45), }) fmt.Println(\"Lazy model:\", ok) ok = td.CmpStruct(t, got, nil, td.StructFields{ \"name\": \"Foobar\", \"zip\": 666, }) fmt.Println(\"Lazy model with unknown field:\", ok) // Output: // Lazy model: true // Lazy model with unknown field: false T.Struct shortcut func (t *T) Struct(got, model any, expectedFields StructFields, args ...any) bool Struct is a shortcut for:\nt.Cmp(got, td.Struct(model, expectedFields), args...) See above for details.\nStruct optional parameter expectedFields is here mandatory. nil value should be passed to mimic its absence in original Struct call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Struct godoc.\nExamples Base example t := td.NewT(\u0026testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked ok := t.Struct(got, Person{Name: \"Foobar\"}, td.StructFields{ \"Age\": td.Between(40, 50), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Model can be empty ok = t.Struct(got, Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children:\", ok) // Works with pointers too ok = t.Struct(\u0026got, \u0026Person{}, td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using pointer):\", ok) // Model does not need to be instanciated ok = t.Struct(\u0026got, (*Person)(nil), td.StructFields{ \"Name\": \"Foobar\", \"Age\": td.Between(40, 50), \"NumChildren\": td.Not(0), }, \"checks %v is the right Person\") fmt.Println(\"Foobar has some children (using nil model):\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar has some children: true // Foobar has some children (using pointer): true // Foobar has some children (using nil model): true Overwrite_model example t := td.NewT(\u0026testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \"Foobar\", Age: 42, NumChildren: 3, } ok := t.Struct(got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003eAge\": td.Between(40, 50), // \"\u003e\" to overwrite Age:53 in model \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) ok = t.Struct(got, Person{ Name: \"Foobar\", Age: 53, }, td.StructFields{ \"\u003e Age\": td.Between(40, 50), // same, \"\u003e\" can be followed by spaces \"NumChildren\": td.Gt(2), }, \"checks %v is the right Person\") fmt.Println(\"Foobar is between 40 \u0026 50:\", ok) // Output: // Foobar is between 40 \u0026 50: true // Foobar is between 40 \u0026 50: true Patterns example t := td.NewT(\u0026testing.T{}) type Person struct { Firstname string Lastname string Surname string Nickname string CreatedAt time.Time UpdatedAt time.Time DeletedAt *time.Time } now := time.Now() got := Person{ Firstname: \"Maxime\", Lastname: \"Foo\", Surname: \"Max\", Nickname: \"max\", CreatedAt: now, UpdatedAt: now, DeletedAt: nil, // not deleted yet } ok := t.Struct(got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `= *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `=~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt }, \"mix shell \u0026 regexp patterns\") fmt.Println(\"Patterns match only remaining fields:\", ok) ok = t.Struct(got, Person{Lastname: \"Foo\"}, td.StructFields{ `DeletedAt`: nil, `1 = *name`: td.Re(`^(?i)max`), // shell pattern, matches all names except Lastname as in model `2 =~ At\\z`: td.Lte(time.Now()), // regexp, matches CreatedAt \u0026 UpdatedAt }, \"ordered patterns\") fmt.Println(\"Ordered patterns match only remaining fields:\", ok) // Output: // Patterns match only remaining fields: true // Ordered patterns match only remaining fields: true Lazy_model example t := td.NewT(\u0026testing.T{}) got := struct { name string age int }{ name: \"Foobar\", age: 42, } ok := t.Struct(got, nil, td.StructFields{ \"name\": \"Foobar\", \"age\": td.Between(40, 45), }) fmt.Println(\"Lazy model:\", ok) ok = t.Struct(got, nil, td.StructFields{ \"name\": \"Foobar\", \"zip\": 666, }) fmt.Println(\"Lazy model with unknown field:\", ok) // Output: // Lazy model: true // Lazy model with unknown field: false",
    "description": "func Struct(model any, expectedFields ...StructFields) TestDeep Struct operator compares the contents of a struct or a pointer on a struct against the non-zero values of model (if any) and the values of expectedFields. See SStruct to compares against zero fields without specifying them in expectedFields.\nmodel must be the same type as compared data. If the expected type is anonymous or private, model can be nil. In this case it is considered lazy and determined each time the operator is involved in a match, see below.",
    "tags": [],
    "title": "Struct",
    "uri": "/operators/struct/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SubBagOf(expectedItems ...any) TestDeep SubBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\ntd.Cmp(t, []int{1}, td.SubBagOf(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 1}, td.SubBagOf(1, 1, 2)) // fails, one 1 is an extra item // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubBagOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{1, 2, 1} td.Cmp(t, []int{1}, td.SubBagOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1}, td.SubBagOf(1, 2, 1)) exp1 := []int{5, 1, 1} exp2 := []int{8, 42, 3} td.Cmp(t, []int{1, 42, 3}, td.SubBagOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 42, 3}, td.SubBagOf(5, 1, 1, 3, 8, 42, 3)) TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\nSee also Bag and SuperBagOf.\nSee also SubBagOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.Cmp(t, got, td.SubBagOf(0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9), \"checks at least all items are present, in any order\") fmt.Println(ok) // got contains one 8 too many ok = td.Cmp(t, got, td.SubBagOf(0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9), \"checks at least all items are present, in any order\") fmt.Println(ok) got = []int{1, 3, 5, 2} ok = td.Cmp(t, got, td.SubBagOf( td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Gt(4), td.Gt(4)), \"checks at least all items match, in any order with TestDeep operators\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5, 9, 8} ok = td.Cmp(t, got, td.SubBagOf(td.Flatten(expected)), \"checks at least all expected items are present, in any order\") fmt.Println(ok) // Output: // true // false // true // true CmpSubBagOf shortcut func CmpSubBagOf(t TestingT, got any, expectedItems []any, args ...any) bool CmpSubBagOf is a shortcut for:\ntd.Cmp(t, got, td.SubBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSubBagOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.CmpSubBagOf(t, got, []any{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9}, \"checks at least all items are present, in any order\") fmt.Println(ok) // got contains one 8 too many ok = td.CmpSubBagOf(t, got, []any{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9}, \"checks at least all items are present, in any order\") fmt.Println(ok) got = []int{1, 3, 5, 2} ok = td.CmpSubBagOf(t, got, []any{td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Gt(4), td.Gt(4)}, \"checks at least all items match, in any order with TestDeep operators\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5, 9, 8} ok = td.CmpSubBagOf(t, got, []any{td.Flatten(expected)}, \"checks at least all expected items are present, in any order\") fmt.Println(ok) // Output: // true // false // true // true T.SubBagOf shortcut func (t *T) SubBagOf(got any, expectedItems []any, args ...any) bool SubBagOf is a shortcut for:\nt.Cmp(got, td.SubBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SubBagOf godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SubBagOf(got, []any{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9}, \"checks at least all items are present, in any order\") fmt.Println(ok) // got contains one 8 too many ok = t.SubBagOf(got, []any{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9}, \"checks at least all items are present, in any order\") fmt.Println(ok) got = []int{1, 3, 5, 2} ok = t.SubBagOf(got, []any{td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Gt(4), td.Gt(4)}, \"checks at least all items match, in any order with TestDeep operators\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 5, 9, 8} ok = t.SubBagOf(got, []any{td.Flatten(expected)}, \"checks at least all expected items are present, in any order\") fmt.Println(ok) // Output: // true // false // true // true",
    "description": "func SubBagOf(expectedItems ...any) TestDeep SubBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\ntd.Cmp(t, []int{1}, td.SubBagOf(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 1}, td.SubBagOf(1, 1, 2)) // fails, one 1 is an extra item // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubBagOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:",
    "tags": [],
    "title": "SubBagOf",
    "uri": "/operators/subbagof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SubJSONOf(expectedJSON any, params ...any) TestDeep SubJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshaled data must be a JSON object/map (aka {…}). expectedJSON can be a:\nstring containing JSON data like {\"fullname\":\"Bob\",\"age\":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some expected entries can be missing from the compared map.\ntype MyStruct struct { Name string `json:\"name\"` Age int `json:\"age\"` } got := MyStruct{ Name: \"Bob\", Age: 42, } td.Cmp(t, got, td.SubJSONOf(`{\"name\": \"Bob\", \"age\": 42, \"city\": \"NY\"}`)) // succeeds td.Cmp(t, got, td.SubJSONOf(`{\"name\": \"Bob\", \"zip\": 666}`)) // fails, extra \"age\" expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n’th “operators” item (starting at 1). Named placeholders are used with Tag operator as follows:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\"fullname\": $name, \"age\": $2, \"gender\": $3}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43), // matches only $2 \"male\")) // matches only $3 Note that placeholders can be double-quoted as in:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\"fullname\": \"$name\", \"age\": \"$2\", \"gender\": \"$3\"}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43), // matches only $2 \"male\")) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a “.json” file.\nSubJSONOf does its best to convert back the JSON corresponding to a placeholder to the type of the placeholder or, if the placeholder is an operator, to the type behind the operator. Allowing to do things like:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\"foo\":$1, \"bar\": 12}`, []int{1, 2, 3, 4})) td.Cmp(t, gotValue, td.SubJSONOf(`{\"foo\":$1, \"bar\": 12}`, []any{1, 2, td.Between(2, 4), 4})) td.Cmp(t, gotValue, td.SubJSONOf(`{\"foo\":$1, \"bar\": 12}`, td.Between(27, 32))) Of course, it does this conversion only if the expected type can be guessed. In the case the conversion cannot occur, data is compared as is, in its freshly unmarshaled JSON form (so as bool, float64, string, []any, map[string]any or simply nil).\nNote expectedJSON can be a []byte, an encoding/json.RawMessage, a JSON filename or a io.Reader:\ntd.Cmp(t, gotValue, td.SubJSONOf(\"file.json\", td.Between(12, 34))) td.Cmp(t, gotValue, td.SubJSONOf([]byte(`[1, $1, 3]`), td.Between(12, 34))) td.Cmp(t, gotValue, td.SubJSONOf(osFile, td.Between(12, 34))) A JSON filename ends with “.json”.\nTo avoid a legit “$” string prefix causes a bad placeholder error, just double it to escape it. Note it is only needed when the “$” is the first character of a string:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\"fullname\": \"$name\", \"details\": \"$$info\", \"age\": $2}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43))) // matches only $2 For the “details” key, the raw value “$info” is expected, no placeholders are involved here.\nNote that Lax mode is automatically enabled by SubJSONOf operator to simplify numeric tests.\nComments can be embedded in JSON data:\ntd.Cmp(t, gotValue, SubJSONOf(` { // A guy properties: \"fullname\": \"$name\", // The full name of the guy \"details\": \"$$info\", // Literally \"$info\", thanks to \"$\" escape \"age\": $2 /* The age of the guy: - placeholder unquoted, but could be without any change - to demonstrate a multi-lines comment */ }`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43))) // matches only $2 Comments, like in go, have 2 forms. To quote the Go language specification:\nline comments start with the character sequence // and stop at the end of the line. multi-lines comments start with the character sequence /* and stop with the first subsequent character sequence */. Other JSON divergences:\n‘,’ can precede a ‘}’ or a ‘]’ (as in go); strings can contain non-escaped \\n, \\r and \\t; raw strings are accepted (r{raw}, r!raw!, …), see below; int_lit \u0026 float_lit numbers as defined in go spec are accepted; numbers can be prefixed by ‘+’. Most operators can be directly embedded in SubJSONOf without requiring any placeholder. If an operators does not take any parameter, the parenthesis can be omitted.\ntd.Cmp(t, gotValue, td.SubJSONOf(` { \"fullname\": HasPrefix(\"Foo\"), \"age\": Between(41, 43), \"details\": SuperMapOf({ \"address\": NotEmpty, // () are optional when no parameters \"car\": Any(\"Peugeot\", \"Tesla\", \"Jeep\") // any of these }) }`)) Placeholders can be used anywhere, even in operators parameters as in:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\"fullname\": HasPrefix($1), \"bar\": 42}`, \"Zip\")) A few notes about operators embedding:\nSubMapOf and SuperMapOf take only one parameter, a JSON object; the optional 3rd parameter of Between has to be specified as a string and can be: “[]” or “BoundsInIn” (default), “[[” or “BoundsInOut”, “]]” or “BoundsOutIn”, “][” or “BoundsOutOut”; not all operators are embeddable only the following are: All, Any, ArrayEach, Bag, Between, Contains, ContainsKey, Empty, First, Grep, Gt, Gte, HasPrefix, HasSuffix, Ignore, JSONPointer, Keys, Last, Len, Lt, Lte, MapEach, N, NaN, Nil, None, Not, NotAny, NotEmpty, NotNaN, NotNil, NotZero, Re, ReAll, Set, Sort, Sorted, SubBagOf, SubMapOf, SubSetOf, SuperBagOf, SuperMapOf, SuperSetOf, Values and Zero. It is also possible to embed operators in JSON strings. This way, the JSON specification can be fulfilled. To avoid collision with possible strings, just prefix the first operator name with “$^”. The previous example becomes:\ntd.Cmp(t, gotValue, td.SubJSONOf(` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ \\\"address\\\": NotEmpty, // () are optional when no parameters \\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\") // any of these })\" }`)) As you can see, in this case, strings in strings have to be escaped. Fortunately, newlines are accepted, but unfortunately they are forbidden by JSON specification. To avoid too much escaping, raw strings are accepted. A raw string is a “r” followed by a delimiter, the corresponding delimiter closes the string. The following raw strings are all the same as “foo\\bar(\"zip\")!”:\nr’foo\\bar\"zip\"!’ r,foo\\bar\"zip\"!, r%foo\\bar\"zip\"!% r(foo\\bar(“zip”)!) r{foo\\bar(“zip”)!} r[foo\\bar(“zip”)!] r\u003cfoo\\bar(“zip”)!\u003e So non-bracketing delimiters use the same character before and after, but the 4 sorts of ASCII brackets (round, angle, square, curly) all nest: r[x[y]z] equals “x[y]z”. The end delimiter cannot be escaped.\nWith raw strings, the previous example becomes:\ntd.Cmp(t, gotValue, td.SubJSONOf(` { \"fullname\": \"$^HasPrefix(r\u003cFoo\u003e)\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ r\u003caddress\u003e: NotEmpty, // () are optional when no parameters r\u003ccar\u003e: Any(r\u003cPeugeot\u003e, r\u003cTesla\u003e, r\u003cJeep\u003e) // any of these })\" }`)) Note that raw strings are accepted anywhere, not only in original JSON strings.\nTo be complete, $^ can prefix an operator even outside a string. This is accepted for compatibility purpose as the first operator embedding feature used this way to embed some operators.\nSo the following calls are all equivalent:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": $1}`, td.NotZero())) td.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": NotZero}`)) td.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": NotZero()}`)) td.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": $^NotZero}`)) td.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": $^NotZero()}`)) td.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": \"$^NotZero\"}`)) td.Cmp(t, gotValue, td.SubJSONOf(`{\"id\": \"$^NotZero()\"}`)) As for placeholders, there is no differences between $^NotZero and “$^NotZero”.\nTip: when an io.Reader is expected to contain JSON data, it cannot be tested directly, but using the Smuggle operator simply solves the problem:\nvar body io.Reader // … td.Cmp(t, body, td.Smuggle(json.RawMessage{}, td.SubJSONOf(`{\"foo\":1,\"bar\":2}`))) // or equally td.Cmp(t, body, td.Smuggle(json.RawMessage(nil), td.SubJSONOf(`{\"foo\":1,\"bar\":2}`))) Smuggle reads from body into an encoding/json.RawMessage then this buffer is unmarshaled by SubJSONOf operator before the comparison.\nTypeBehind method returns the map[string]any type.\nSee also JSON, JSONPointer and SuperJSONOf.\nSee also SubJSONOf godoc.\nExamples Basic example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } ok := td.Cmp(t, got, td.SubJSONOf(`{\"age\":42,\"fullname\":\"Bob\",\"gender\":\"male\"}`)) fmt.Println(\"check got with age then fullname:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`)) fmt.Println(\"check got with fullname then age:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \"gender\": \"male\" // This field is ignored as SubJSONOf }`)) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\"fullname\":\"Bob\",\"gender\":\"male\"}`)) fmt.Println(\"check got without age field:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got without age field: false Placeholders example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob Foobar\", Age: 42, } ok := td.Cmp(t, got, td.SubJSONOf(`{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, 42, \"Bob Foobar\", \"male\")) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty())) fmt.Println(\"check got with numeric placeholders:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\"age\": \"$1\", \"fullname\": \"$2\", \"gender\": \"$3\"}`, td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty())) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\"age\": $age, \"fullname\": $name, \"gender\": $gender}`, td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"gender\", td.NotEmpty()))) fmt.Println(\"check got with named placeholders:\", ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\"age\": $^NotZero, \"fullname\": $^NotEmpty, \"gender\": $^NotEmpty}`)) fmt.Println(\"check got with operator shortcuts:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got with operator shortcuts: true File example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\", \"details\": { \"city\": \"TestCity\", \"zip\": 666 } }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := td.Cmp(t, got, td.SubJSONOf(filename, td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`)))) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.Cmp(t, got, td.SubJSONOf(file, td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`)))) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true CmpSubJSONOf shortcut func CmpSubJSONOf(t TestingT, got, expectedJSON any, params []any, args ...any) bool CmpSubJSONOf is a shortcut for:\ntd.Cmp(t, got, td.SubJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSubJSONOf godoc.\nExamples Basic example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } ok := td.CmpSubJSONOf(t, got, `{\"age\":42,\"fullname\":\"Bob\",\"gender\":\"male\"}`, nil) fmt.Println(\"check got with age then fullname:\", ok) ok = td.CmpSubJSONOf(t, got, `{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`, nil) fmt.Println(\"check got with fullname then age:\", ok) ok = td.CmpSubJSONOf(t, got, ` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \"gender\": \"male\" // This field is ignored as SubJSONOf }`, nil) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = td.CmpSubJSONOf(t, got, `{\"fullname\":\"Bob\",\"gender\":\"male\"}`, nil) fmt.Println(\"check got without age field:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got without age field: false Placeholders example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob Foobar\", Age: 42, } ok := td.CmpSubJSONOf(t, got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{42, \"Bob Foobar\", \"male\"}) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = td.CmpSubJSONOf(t, got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with numeric placeholders:\", ok) ok = td.CmpSubJSONOf(t, got, `{\"age\": \"$1\", \"fullname\": \"$2\", \"gender\": \"$3\"}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = td.CmpSubJSONOf(t, got, `{\"age\": $age, \"fullname\": $name, \"gender\": $gender}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"gender\", td.NotEmpty())}) fmt.Println(\"check got with named placeholders:\", ok) ok = td.CmpSubJSONOf(t, got, `{\"age\": $^NotZero, \"fullname\": $^NotEmpty, \"gender\": $^NotEmpty}`, nil) fmt.Println(\"check got with operator shortcuts:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got with operator shortcuts: true File example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\", \"details\": { \"city\": \"TestCity\", \"zip\": 666 } }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := td.CmpSubJSONOf(t, got, filename, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.CmpSubJSONOf(t, got, file, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true T.SubJSONOf shortcut func (t *T) SubJSONOf(got, expectedJSON any, params []any, args ...any) bool SubJSONOf is a shortcut for:\nt.Cmp(got, td.SubJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SubJSONOf godoc.\nExamples Basic example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob\", Age: 42, } ok := t.SubJSONOf(got, `{\"age\":42,\"fullname\":\"Bob\",\"gender\":\"male\"}`, nil) fmt.Println(\"check got with age then fullname:\", ok) ok = t.SubJSONOf(got, `{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`, nil) fmt.Println(\"check got with fullname then age:\", ok) ok = t.SubJSONOf(got, ` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \"gender\": \"male\" // This field is ignored as SubJSONOf }`, nil) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = t.SubJSONOf(got, `{\"fullname\":\"Bob\",\"gender\":\"male\"}`, nil) fmt.Println(\"check got without age field:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got without age field: false Placeholders example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` }{ Fullname: \"Bob Foobar\", Age: 42, } ok := t.SubJSONOf(got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{42, \"Bob Foobar\", \"male\"}) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = t.SubJSONOf(got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with numeric placeholders:\", ok) ok = t.SubJSONOf(got, `{\"age\": \"$1\", \"fullname\": \"$2\", \"gender\": \"$3\"}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = t.SubJSONOf(got, `{\"age\": $age, \"fullname\": $name, \"gender\": $gender}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"gender\", td.NotEmpty())}) fmt.Println(\"check got with named placeholders:\", ok) ok = t.SubJSONOf(got, `{\"age\": $^NotZero, \"fullname\": $^NotEmpty, \"gender\": $^NotEmpty}`, nil) fmt.Println(\"check got with operator shortcuts:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got with operator shortcuts: true File example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\", \"details\": { \"city\": \"TestCity\", \"zip\": 666 } }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := t.SubJSONOf(got, filename, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.SubJSONOf(got, file, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true",
    "description": "func SubJSONOf(expectedJSON any, params ...any) TestDeep SubJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshaled data must be a JSON object/map (aka {…}). expectedJSON can be a:\nstring containing JSON data like {\"fullname\":\"Bob\",\"age\":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some expected entries can be missing from the compared map.",
    "tags": [],
    "title": "SubJSONOf",
    "uri": "/operators/subjsonof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SubMapOf(model any, expectedEntries MapEntries) TestDeep SubMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nDuring a match, each map entry should be matched by an expected entry to succeed. But some expected entries can be missing from the compared map.\ngot := map[string]string{ \"foo\": \"test\", \"zip\": \"buzz\", } td.Cmp(t, got, td.SubMapOf( map[string]string{ \"foo\": \"test\", \"bar\": \"wizz\", }, td.MapEntries{ \"zip\": td.HasSuffix(\"zz\"), }), ) // succeeds td.Cmp(t, got, td.SubMapOf( map[string]string{ \"bar\": \"wizz\", }, td.MapEntries{ \"zip\": td.HasSuffix(\"zz\"), }), ) // fails, extra {\"foo\": \"test\"} in got TypeBehind method returns the reflect.Type of model.\nSee also Map and SuperMapOf.\nSee also SubMapOf godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42} ok := td.Cmp(t, got, td.SubMapOf(map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}), \"checks map %v is included in expected keys/values\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42} ok := td.Cmp(t, got, td.SubMapOf(MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}), \"checks typed map %v is included in expected keys/values\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.SubMapOf(\u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}), \"checks pointed typed map %v is included in expected keys/values\", got) fmt.Println(ok) // Output: // true // true CmpSubMapOf shortcut func CmpSubMapOf(t TestingT, got, model any, expectedEntries MapEntries, args ...any) bool CmpSubMapOf is a shortcut for:\ntd.Cmp(t, got, td.SubMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSubMapOf godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42} ok := td.CmpSubMapOf(t, got, map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}, \"checks map %v is included in expected keys/values\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42} ok := td.CmpSubMapOf(t, got, MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}, \"checks typed map %v is included in expected keys/values\", got) fmt.Println(ok) ok = td.CmpSubMapOf(t, \u0026got, \u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}, \"checks pointed typed map %v is included in expected keys/values\", got) fmt.Println(ok) // Output: // true // true T.SubMapOf shortcut func (t *T) SubMapOf(got, model any, expectedEntries MapEntries, args ...any) bool SubMapOf is a shortcut for:\nt.Cmp(got, td.SubMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SubMapOf godoc.\nExamples Map example t := td.NewT(\u0026testing.T{}) got := map[string]int{\"foo\": 12, \"bar\": 42} ok := t.SubMapOf(got, map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}, \"checks map %v is included in expected keys/values\", got) fmt.Println(ok) // Output: // true TypedMap example t := td.NewT(\u0026testing.T{}) type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42} ok := t.SubMapOf(got, MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}, \"checks typed map %v is included in expected keys/values\", got) fmt.Println(ok) ok = t.SubMapOf(\u0026got, \u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15), \"zip\": 666}, \"checks pointed typed map %v is included in expected keys/values\", got) fmt.Println(ok) // Output: // true // true",
    "description": "func SubMapOf(model any, expectedEntries MapEntries) TestDeep SubMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nDuring a match, each map entry should be matched by an expected entry to succeed. But some expected entries can be missing from the compared map.",
    "tags": [],
    "title": "SubMapOf",
    "uri": "/operators/submapof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SubSetOf(expectedItems ...any) TestDeep SubSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\ntd.Cmp(t, []int{1, 1}, td.SubSetOf(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SubSetOf(1, 3)) // fails, 2 is an extra item // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubSetOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{2, 1} td.Cmp(t, []int{1, 1}, td.SubSetOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1}, td.SubSetOf(2, 1)) exp1 := []int{2, 1} exp2 := []int{5, 8} td.Cmp(t, []int{1, 5, 1, 3, 3}, td.SubSetOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 3, 3}, td.SubSetOf(2, 1, 3, 5, 8)) TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa) and they are equal.\nSee also NotAny, Set and SuperSetOf.\nSee also SubSetOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates ok := td.Cmp(t, got, td.SubSetOf(1, 2, 3, 4, 5, 6, 7, 8), \"checks at least all items are present, in any order, ignoring duplicates\") fmt.Println(ok) // Tries its best not to raise an error when a value can be matched // by several SubSetOf entries ok = td.Cmp(t, got, td.SubSetOf(td.Between(1, 4), 3, td.Between(2, 10), td.Gt(100)), \"checks at least all items are present, in any order, ignoring duplicates\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 4, 5, 6, 7, 8} ok = td.Cmp(t, got, td.SubSetOf(td.Flatten(expected)), \"checks at least all expected items are present, in any order, ignoring duplicates\") fmt.Println(ok) // Output: // true // true // true CmpSubSetOf shortcut func CmpSubSetOf(t TestingT, got any, expectedItems []any, args ...any) bool CmpSubSetOf is a shortcut for:\ntd.Cmp(t, got, td.SubSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSubSetOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates ok := td.CmpSubSetOf(t, got, []any{1, 2, 3, 4, 5, 6, 7, 8}, \"checks at least all items are present, in any order, ignoring duplicates\") fmt.Println(ok) // Tries its best not to raise an error when a value can be matched // by several SubSetOf entries ok = td.CmpSubSetOf(t, got, []any{td.Between(1, 4), 3, td.Between(2, 10), td.Gt(100)}, \"checks at least all items are present, in any order, ignoring duplicates\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 4, 5, 6, 7, 8} ok = td.CmpSubSetOf(t, got, []any{td.Flatten(expected)}, \"checks at least all expected items are present, in any order, ignoring duplicates\") fmt.Println(ok) // Output: // true // true // true T.SubSetOf shortcut func (t *T) SubSetOf(got any, expectedItems []any, args ...any) bool SubSetOf is a shortcut for:\nt.Cmp(got, td.SubSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SubSetOf godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates ok := t.SubSetOf(got, []any{1, 2, 3, 4, 5, 6, 7, 8}, \"checks at least all items are present, in any order, ignoring duplicates\") fmt.Println(ok) // Tries its best not to raise an error when a value can be matched // by several SubSetOf entries ok = t.SubSetOf(got, []any{td.Between(1, 4), 3, td.Between(2, 10), td.Gt(100)}, \"checks at least all items are present, in any order, ignoring duplicates\") fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3, 4, 5, 6, 7, 8} ok = t.SubSetOf(got, []any{td.Flatten(expected)}, \"checks at least all expected items are present, in any order, ignoring duplicates\") fmt.Println(ok) // Output: // true // true // true",
    "description": "func SubSetOf(expectedItems ...any) TestDeep SubSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\ntd.Cmp(t, []int{1, 1}, td.SubSetOf(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SubSetOf(1, 3)) // fails, 2 is an extra item // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubSetOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:",
    "tags": [],
    "title": "SubSetOf",
    "uri": "/operators/subsetof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SuperBagOf(expectedItems ...any) TestDeep SuperBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\ntd.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1, 1, 1)) // fails, one 1 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperBagOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{1, 2, 1} td.Cmp(t, []int{1}, td.SuperBagOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1}, td.SuperBagOf(1, 2, 1)) exp1 := []int{5, 1, 1} exp2 := []int{8, 42} td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3, 6}, td.SuperBagOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3, 6}, td.SuperBagOf(5, 1, 1, 3, 8, 42)) TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\nSee also Bag and SubBagOf.\nSee also SuperBagOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.Cmp(t, got, td.SuperBagOf(8, 5, 8), \"checks the items are present, in any order\") fmt.Println(ok) ok = td.Cmp(t, got, td.SuperBagOf(td.Gt(5), td.Lte(2)), \"checks at least 2 items of %v match\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{8, 5, 8} ok = td.Cmp(t, got, td.SuperBagOf(td.Flatten(expected)), \"checks the expected items are present, in any order\") fmt.Println(ok) // Output: // true // true // true CmpSuperBagOf shortcut func CmpSuperBagOf(t TestingT, got any, expectedItems []any, args ...any) bool CmpSuperBagOf is a shortcut for:\ntd.Cmp(t, got, td.SuperBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSuperBagOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.CmpSuperBagOf(t, got, []any{8, 5, 8}, \"checks the items are present, in any order\") fmt.Println(ok) ok = td.CmpSuperBagOf(t, got, []any{td.Gt(5), td.Lte(2)}, \"checks at least 2 items of %v match\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{8, 5, 8} ok = td.CmpSuperBagOf(t, got, []any{td.Flatten(expected)}, \"checks the expected items are present, in any order\") fmt.Println(ok) // Output: // true // true // true T.SuperBagOf shortcut func (t *T) SuperBagOf(got any, expectedItems []any, args ...any) bool SuperBagOf is a shortcut for:\nt.Cmp(got, td.SuperBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SuperBagOf godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SuperBagOf(got, []any{8, 5, 8}, \"checks the items are present, in any order\") fmt.Println(ok) ok = t.SuperBagOf(got, []any{td.Gt(5), td.Lte(2)}, \"checks at least 2 items of %v match\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{8, 5, 8} ok = t.SuperBagOf(got, []any{td.Flatten(expected)}, \"checks the expected items are present, in any order\") fmt.Println(ok) // Output: // true // true // true",
    "description": "func SuperBagOf(expectedItems ...any) TestDeep SuperBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\ntd.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1, 1, 1)) // fails, one 1 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperBagOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:",
    "tags": [],
    "title": "SuperBagOf",
    "uri": "/operators/superbagof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SuperJSONOf(expectedJSON any, params ...any) TestDeep SuperJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshaled data must be a JSON object/map (aka {…}). expectedJSON can be a:\nstring containing JSON data like {\"fullname\":\"Bob\",\"age\":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.\ntype MyStruct struct { Name string `json:\"name\"` Age int `json:\"age\"` City string `json:\"city\"` } got := MyStruct{ Name: \"Bob\", Age: 42, City: \"TestCity\", } td.Cmp(t, got, td.SuperJSONOf(`{\"name\": \"Bob\", \"age\": 42}`)) // succeeds td.Cmp(t, got, td.SuperJSONOf(`{\"name\": \"Bob\", \"zip\": 666}`)) // fails, miss \"zip\" expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n’th “operators” item (starting at 1). Named placeholders are used with Tag operator as follows:\ntd.Cmp(t, gotValue, SuperJSONOf(`{\"fullname\": $name, \"age\": $2, \"gender\": $3}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43), // matches only $2 \"male\")) // matches only $3 Note that placeholders can be double-quoted as in:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\"fullname\": \"$name\", \"age\": \"$2\", \"gender\": \"$3\"}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43), // matches only $2 \"male\")) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a “.json” file.\nSuperJSONOf does its best to convert back the JSON corresponding to a placeholder to the type of the placeholder or, if the placeholder is an operator, to the type behind the operator. Allowing to do things like:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\"foo\":$1}`, []int{1, 2, 3, 4})) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"foo\":$1}`, []any{1, 2, td.Between(2, 4), 4})) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"foo\":$1}`, td.Between(27, 32))) Of course, it does this conversion only if the expected type can be guessed. In the case the conversion cannot occur, data is compared as is, in its freshly unmarshaled JSON form (so as bool, float64, string, []any, map[string]any or simply nil).\nNote expectedJSON can be a []byte, an encoding/json.RawMessage, a JSON filename or a io.Reader:\ntd.Cmp(t, gotValue, td.SuperJSONOf(\"file.json\", td.Between(12, 34))) td.Cmp(t, gotValue, td.SuperJSONOf([]byte(`[1, $1, 3]`), td.Between(12, 34))) td.Cmp(t, gotValue, td.SuperJSONOf(osFile, td.Between(12, 34))) A JSON filename ends with “.json”.\nTo avoid a legit “$” string prefix causes a bad placeholder error, just double it to escape it. Note it is only needed when the “$” is the first character of a string:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\"fullname\": \"$name\", \"details\": \"$$info\", \"age\": $2}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43))) // matches only $2 For the “details” key, the raw value “$info” is expected, no placeholders are involved here.\nNote that Lax mode is automatically enabled by SuperJSONOf operator to simplify numeric tests.\nComments can be embedded in JSON data:\ntd.Cmp(t, gotValue, td.SuperJSONOf(` { // A guy properties: \"fullname\": \"$name\", // The full name of the guy \"details\": \"$$info\", // Literally \"$info\", thanks to \"$\" escape \"age\": $2 /* The age of the guy: - placeholder unquoted, but could be without any change - to demonstrate a multi-lines comment */ }`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $1 and $name td.Between(41, 43))) // matches only $2 Comments, like in go, have 2 forms. To quote the Go language specification:\nline comments start with the character sequence // and stop at the end of the line. multi-lines comments start with the character sequence /* and stop with the first subsequent character sequence */. Other JSON divergences:\n‘,’ can precede a ‘}’ or a ‘]’ (as in go); strings can contain non-escaped \\n, \\r and \\t; raw strings are accepted (r{raw}, r!raw!, …), see below; int_lit \u0026 float_lit numbers as defined in go spec are accepted; numbers can be prefixed by ‘+’. Most operators can be directly embedded in SuperJSONOf without requiring any placeholder. If an operators does not take any parameter, the parenthesis can be omitted.\ntd.Cmp(t, gotValue, td.SuperJSONOf(` { \"fullname\": HasPrefix(\"Foo\"), \"age\": Between(41, 43), \"details\": SuperMapOf({ \"address\": NotEmpty, // () are optional when no parameters \"car\": Any(\"Peugeot\", \"Tesla\", \"Jeep\") // any of these }) }`)) Placeholders can be used anywhere, even in operators parameters as in:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\"fullname\": HasPrefix($1)}`, \"Zip\")) A few notes about operators embedding:\nSubMapOf and SuperMapOf take only one parameter, a JSON object; the optional 3rd parameter of Between has to be specified as a string and can be: “[]” or “BoundsInIn” (default), “[[” or “BoundsInOut”, “]]” or “BoundsOutIn”, “][” or “BoundsOutOut”; not all operators are embeddable only the following are: All, Any, ArrayEach, Bag, Between, Contains, ContainsKey, Empty, First, Grep, Gt, Gte, HasPrefix, HasSuffix, Ignore, JSONPointer, Keys, Last, Len, Lt, Lte, MapEach, N, NaN, Nil, None, Not, NotAny, NotEmpty, NotNaN, NotNil, NotZero, Re, ReAll, Set, Sort, Sorted, SubBagOf, SubMapOf, SubSetOf, SuperBagOf, SuperMapOf, SuperSetOf, Values and Zero. It is also possible to embed operators in JSON strings. This way, the JSON specification can be fulfilled. To avoid collision with possible strings, just prefix the first operator name with “$^”. The previous example becomes:\ntd.Cmp(t, gotValue, td.SuperJSONOf(` { \"fullname\": \"$^HasPrefix(\\\"Foo\\\")\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ \\\"address\\\": NotEmpty, // () are optional when no parameters \\\"car\\\": Any(\\\"Peugeot\\\", \\\"Tesla\\\", \\\"Jeep\\\") // any of these })\" }`)) As you can see, in this case, strings in strings have to be escaped. Fortunately, newlines are accepted, but unfortunately they are forbidden by JSON specification. To avoid too much escaping, raw strings are accepted. A raw string is a “r” followed by a delimiter, the corresponding delimiter closes the string. The following raw strings are all the same as “foo\\bar(\"zip\")!”:\nr’foo\\bar\"zip\"!’ r,foo\\bar\"zip\"!, r%foo\\bar\"zip\"!% r(foo\\bar(“zip”)!) r{foo\\bar(“zip”)!} r[foo\\bar(“zip”)!] r\u003cfoo\\bar(“zip”)!\u003e So non-bracketing delimiters use the same character before and after, but the 4 sorts of ASCII brackets (round, angle, square, curly) all nest: r[x[y]z] equals “x[y]z”. The end delimiter cannot be escaped.\nWith raw strings, the previous example becomes:\ntd.Cmp(t, gotValue, td.SuperJSONOf(` { \"fullname\": \"$^HasPrefix(r\u003cFoo\u003e)\", \"age\": \"$^Between(41, 43)\", \"details\": \"$^SuperMapOf({ r\u003caddress\u003e: NotEmpty, // () are optional when no parameters r\u003ccar\u003e: Any(r\u003cPeugeot\u003e, r\u003cTesla\u003e, r\u003cJeep\u003e) // any of these })\" }`)) Note that raw strings are accepted anywhere, not only in original JSON strings.\nTo be complete, $^ can prefix an operator even outside a string. This is accepted for compatibility purpose as the first operator embedding feature used this way to embed some operators.\nSo the following calls are all equivalent:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": $1}`, td.NotZero())) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": NotZero}`)) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": NotZero()}`)) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": $^NotZero}`)) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": $^NotZero()}`)) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": \"$^NotZero\"}`)) td.Cmp(t, gotValue, td.SuperJSONOf(`{\"id\": \"$^NotZero()\"}`)) As for placeholders, there is no differences between $^NotZero and “$^NotZero”.\nTip: when an io.Reader is expected to contain JSON data, it cannot be tested directly, but using the Smuggle operator simply solves the problem:\nvar body io.Reader // … td.Cmp(t, body, td.Smuggle(json.RawMessage{}, td.SuperJSONOf(`{\"foo\":1}`))) // or equally td.Cmp(t, body, td.Smuggle(json.RawMessage(nil), td.SuperJSONOf(`{\"foo\":1}`))) Smuggle reads from body into an encoding/json.RawMessage then this buffer is unmarshaled by SuperJSONOf operator before the comparison.\nTypeBehind method returns the map[string]any type.\nSee also JSON, JSONPointer and SubJSONOf.\nSee also SuperJSONOf godoc.\nExamples Basic example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } ok := td.Cmp(t, got, td.SuperJSONOf(`{\"age\":42,\"fullname\":\"Bob\",\"gender\":\"male\"}`)) fmt.Println(\"check got with age then fullname:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`)) fmt.Println(\"check got with fullname then age:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \"gender\": \"male\" // The gender! }`)) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\"fullname\":\"Bob\",\"gender\":\"male\",\"details\":{}}`)) fmt.Println(\"check got with details field:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got with details field: false Placeholders example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } ok := td.Cmp(t, got, td.SuperJSONOf(`{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, 42, \"Bob Foobar\", \"male\")) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty())) fmt.Println(\"check got with numeric placeholders:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\"age\": \"$1\", \"fullname\": \"$2\", \"gender\": \"$3\"}`, td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty())) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\"age\": $age, \"fullname\": $name, \"gender\": $gender}`, td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"gender\", td.NotEmpty()))) fmt.Println(\"check got with named placeholders:\", ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\"age\": $^NotZero, \"fullname\": $^NotEmpty, \"gender\": $^NotEmpty}`)) fmt.Println(\"check got with operator shortcuts:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got with operator shortcuts: true File example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\" }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := td.Cmp(t, got, td.SuperJSONOf(filename, td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`)))) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.Cmp(t, got, td.SuperJSONOf(file, td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`)))) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true CmpSuperJSONOf shortcut func CmpSuperJSONOf(t TestingT, got, expectedJSON any, params []any, args ...any) bool CmpSuperJSONOf is a shortcut for:\ntd.Cmp(t, got, td.SuperJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSuperJSONOf godoc.\nExamples Basic example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } ok := td.CmpSuperJSONOf(t, got, `{\"age\":42,\"fullname\":\"Bob\",\"gender\":\"male\"}`, nil) fmt.Println(\"check got with age then fullname:\", ok) ok = td.CmpSuperJSONOf(t, got, `{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`, nil) fmt.Println(\"check got with fullname then age:\", ok) ok = td.CmpSuperJSONOf(t, got, ` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \"gender\": \"male\" // The gender! }`, nil) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = td.CmpSuperJSONOf(t, got, `{\"fullname\":\"Bob\",\"gender\":\"male\",\"details\":{}}`, nil) fmt.Println(\"check got with details field:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got with details field: false Placeholders example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } ok := td.CmpSuperJSONOf(t, got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{42, \"Bob Foobar\", \"male\"}) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = td.CmpSuperJSONOf(t, got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with numeric placeholders:\", ok) ok = td.CmpSuperJSONOf(t, got, `{\"age\": \"$1\", \"fullname\": \"$2\", \"gender\": \"$3\"}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = td.CmpSuperJSONOf(t, got, `{\"age\": $age, \"fullname\": $name, \"gender\": $gender}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"gender\", td.NotEmpty())}) fmt.Println(\"check got with named placeholders:\", ok) ok = td.CmpSuperJSONOf(t, got, `{\"age\": $^NotZero, \"fullname\": $^NotEmpty, \"gender\": $^NotEmpty}`, nil) fmt.Println(\"check got with operator shortcuts:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got with operator shortcuts: true File example t := \u0026testing.T{} got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\" }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := td.CmpSuperJSONOf(t, got, filename, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.CmpSuperJSONOf(t, got, file, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true T.SuperJSONOf shortcut func (t *T) SuperJSONOf(got, expectedJSON any, params []any, args ...any) bool SuperJSONOf is a shortcut for:\nt.Cmp(got, td.SuperJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SuperJSONOf godoc.\nExamples Basic example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } ok := t.SuperJSONOf(got, `{\"age\":42,\"fullname\":\"Bob\",\"gender\":\"male\"}`, nil) fmt.Println(\"check got with age then fullname:\", ok) ok = t.SuperJSONOf(got, `{\"fullname\":\"Bob\",\"age\":42,\"gender\":\"male\"}`, nil) fmt.Println(\"check got with fullname then age:\", ok) ok = t.SuperJSONOf(got, ` // This should be the JSON representation of a struct { // A person: \"fullname\": \"Bob\", // The name of this person \"age\": 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \"gender\": \"male\" // The gender! }`, nil) fmt.Println(\"check got with nicely formatted and commented JSON:\", ok) ok = t.SuperJSONOf(got, `{\"fullname\":\"Bob\",\"gender\":\"male\",\"details\":{}}`, nil) fmt.Println(\"check got with details field:\", ok) // Output: // check got with age then fullname: true // check got with fullname then age: true // check got with nicely formatted and commented JSON: true // check got with details field: false Placeholders example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } ok := t.SuperJSONOf(got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{42, \"Bob Foobar\", \"male\"}) fmt.Println(\"check got with numeric placeholders without operators:\", ok) ok = t.SuperJSONOf(got, `{\"age\": $1, \"fullname\": $2, \"gender\": $3}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with numeric placeholders:\", ok) ok = t.SuperJSONOf(got, `{\"age\": \"$1\", \"fullname\": \"$2\", \"gender\": \"$3\"}`, []any{td.Between(40, 45), td.HasSuffix(\"Foobar\"), td.NotEmpty()}) fmt.Println(\"check got with double-quoted numeric placeholders:\", ok) ok = t.SuperJSONOf(got, `{\"age\": $age, \"fullname\": $name, \"gender\": $gender}`, []any{td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"name\", td.HasSuffix(\"Foobar\")), td.Tag(\"gender\", td.NotEmpty())}) fmt.Println(\"check got with named placeholders:\", ok) ok = t.SuperJSONOf(got, `{\"age\": $^NotZero, \"fullname\": $^NotEmpty, \"gender\": $^NotEmpty}`, nil) fmt.Println(\"check got with operator shortcuts:\", ok) // Output: // check got with numeric placeholders without operators: true // check got with numeric placeholders: true // check got with double-quoted numeric placeholders: true // check got with named placeholders: true // check got with operator shortcuts: true File example t := td.NewT(\u0026testing.T{}) got := \u0026struct { Fullname string `json:\"fullname\"` Age int `json:\"age\"` Gender string `json:\"gender\"` City string `json:\"city\"` Zip int `json:\"zip\"` }{ Fullname: \"Bob Foobar\", Age: 42, Gender: \"male\", City: \"TestCity\", Zip: 666, } tmpDir, err := os.MkdirTemp(\"\", \"\") if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) //nolint: errcheck // clean up filename := tmpDir + \"/test.json\" if err = os.WriteFile(filename, []byte(` { \"fullname\": \"$name\", \"age\": \"$age\", \"gender\": \"$gender\" }`), 0644); err != nil { t.Fatal(err) } // OK let's test with this file ok := t.SuperJSONOf(got, filename, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from file name:\", ok) // When the file is already open file, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.SuperJSONOf(got, file, []any{td.Tag(\"name\", td.HasPrefix(\"Bob\")), td.Tag(\"age\", td.Between(40, 45)), td.Tag(\"gender\", td.Re(`^(male|female)\\z`))}) fmt.Println(\"Full match from io.Reader:\", ok) // Output: // Full match from file name: true // Full match from io.Reader: true",
    "description": "func SuperJSONOf(expectedJSON any, params ...any) TestDeep SuperJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshaled data must be a JSON object/map (aka {…}). expectedJSON can be a:\nstring containing JSON data like {\"fullname\":\"Bob\",\"age\":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.",
    "tags": [],
    "title": "SuperJSONOf",
    "uri": "/operators/superjsonof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SuperMapOf(model any, expectedEntries MapEntries) TestDeep SuperMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nDuring a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.\ngot := map[string]string{ \"foo\": \"test\", \"bar\": \"wizz\", \"zip\": \"buzz\", } td.Cmp(t, got, td.SuperMapOf( map[string]string{ \"foo\": \"test\", }, td.MapEntries{ \"zip\": td.HasSuffix(\"zz\"), }), ) // succeeds td.Cmp(t, got, td.SuperMapOf( map[string]string{ \"foo\": \"test\", }, td.MapEntries{ \"biz\": td.HasSuffix(\"zz\"), }), ) // fails, missing {\"biz\": …} in got TypeBehind method returns the reflect.Type of model.\nSee also SuperMapOf and SubMapOf.\nSee also SuperMapOf godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.SuperMapOf(map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}), \"checks map %v contains at least all expected keys/values\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.Cmp(t, got, td.SuperMapOf(MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}), \"checks typed map %v contains at least all expected keys/values\", got) fmt.Println(ok) ok = td.Cmp(t, \u0026got, td.SuperMapOf(\u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}), \"checks pointed typed map %v contains at least all expected keys/values\", got) fmt.Println(ok) // Output: // true // true CmpSuperMapOf shortcut func CmpSuperMapOf(t TestingT, got, model any, expectedEntries MapEntries, args ...any) bool CmpSuperMapOf is a shortcut for:\ntd.Cmp(t, got, td.SuperMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSuperMapOf godoc.\nExamples Map example t := \u0026testing.T{} got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.CmpSuperMapOf(t, got, map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}, \"checks map %v contains at least all expected keys/values\", got) fmt.Println(ok) // Output: // true TypedMap example t := \u0026testing.T{} type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := td.CmpSuperMapOf(t, got, MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}, \"checks typed map %v contains at least all expected keys/values\", got) fmt.Println(ok) ok = td.CmpSuperMapOf(t, \u0026got, \u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}, \"checks pointed typed map %v contains at least all expected keys/values\", got) fmt.Println(ok) // Output: // true // true T.SuperMapOf shortcut func (t *T) SuperMapOf(got, model any, expectedEntries MapEntries, args ...any) bool SuperMapOf is a shortcut for:\nt.Cmp(got, td.SuperMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SuperMapOf godoc.\nExamples Map example t := td.NewT(\u0026testing.T{}) got := map[string]int{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := t.SuperMapOf(got, map[string]int{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}, \"checks map %v contains at least all expected keys/values\", got) fmt.Println(ok) // Output: // true TypedMap example t := td.NewT(\u0026testing.T{}) type MyMap map[string]int got := MyMap{\"foo\": 12, \"bar\": 42, \"zip\": 89} ok := t.SuperMapOf(got, MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}, \"checks typed map %v contains at least all expected keys/values\", got) fmt.Println(ok) ok = t.SuperMapOf(\u0026got, \u0026MyMap{\"bar\": 42}, td.MapEntries{\"foo\": td.Lt(15)}, \"checks pointed typed map %v contains at least all expected keys/values\", got) fmt.Println(ok) // Output: // true // true",
    "description": "func SuperMapOf(model any, expectedEntries MapEntries) TestDeep SuperMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nDuring a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.",
    "tags": [],
    "title": "SuperMapOf",
    "uri": "/operators/supermapof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SuperSetOf(expectedItems ...any) TestDeep SuperSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\ntd.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperSetOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{2, 1} td.Cmp(t, []int{1, 1, 2, 8}, td.SuperSetOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1, 2, 8}, td.SubSetOf(2, 1)) exp1 := []int{2, 1} exp2 := []int{5, 8} td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.SuperSetOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.SuperSetOf(2, 1, 3, 5, 8)) TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa) and they are equal.\nSee also NotAny, Set and SubSetOf.\nSee also SuperSetOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.Cmp(t, got, td.SuperSetOf(1, 2, 3), \"checks the items are present, in any order and ignoring duplicates\") fmt.Println(ok) ok = td.Cmp(t, got, td.SuperSetOf(td.Gt(5), td.Lte(2)), \"checks at least 2 items of %v match ignoring duplicates\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3} ok = td.Cmp(t, got, td.SuperSetOf(td.Flatten(expected)), \"checks the expected items are present, in any order and ignoring duplicates\") fmt.Println(ok) // Output: // true // true // true CmpSuperSetOf shortcut func CmpSuperSetOf(t TestingT, got any, expectedItems []any, args ...any) bool CmpSuperSetOf is a shortcut for:\ntd.Cmp(t, got, td.SuperSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSuperSetOf godoc.\nExample Base example t := \u0026testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.CmpSuperSetOf(t, got, []any{1, 2, 3}, \"checks the items are present, in any order and ignoring duplicates\") fmt.Println(ok) ok = td.CmpSuperSetOf(t, got, []any{td.Gt(5), td.Lte(2)}, \"checks at least 2 items of %v match ignoring duplicates\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3} ok = td.CmpSuperSetOf(t, got, []any{td.Flatten(expected)}, \"checks the expected items are present, in any order and ignoring duplicates\") fmt.Println(ok) // Output: // true // true // true T.SuperSetOf shortcut func (t *T) SuperSetOf(got any, expectedItems []any, args ...any) bool SuperSetOf is a shortcut for:\nt.Cmp(got, td.SuperSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SuperSetOf godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SuperSetOf(got, []any{1, 2, 3}, \"checks the items are present, in any order and ignoring duplicates\") fmt.Println(ok) ok = t.SuperSetOf(got, []any{td.Gt(5), td.Lte(2)}, \"checks at least 2 items of %v match ignoring duplicates\", got) fmt.Println(ok) // When expected is already a non-[]any slice, it cannot be // flattened directly using expected... without copying it to a new // []any slice, then use td.Flatten! expected := []int{1, 2, 3} ok = t.SuperSetOf(got, []any{td.Flatten(expected)}, \"checks the expected items are present, in any order and ignoring duplicates\") fmt.Println(ok) // Output: // true // true // true",
    "description": "func SuperSetOf(expectedItems ...any) TestDeep SuperSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\ntd.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperSetOf( Person{Name: \"Bob\", Age: 32}, Person{Name: \"Alice\", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:",
    "tags": [],
    "title": "SuperSetOf",
    "uri": "/operators/supersetof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func SuperSliceOf(model any, expectedEntries ArrayEntries) TestDeep SuperSliceOf operator compares the contents of an array, a pointer on an array, a slice or a pointer on a slice against the non-zero values of model (if any) and the values of expectedEntries. So entries with zero value of model are always ignored. If a zero value check is needed, this zero value has to be set in expectedEntries. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, only entries present in expectedEntries and non-zero ones present in model are checked. To check all entries of an array see Array operator. To check all entries of a slice see Slice operator.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.\nWorks with slices:\ngot := []int{12, 14, 17} td.Cmp(t, got, td.SuperSliceOf([]int{12}, nil)) // succeeds td.Cmp(t, got, td.SuperSliceOf([]int{12}, td.ArrayEntries{2: 17})) // succeeds td.Cmp(t, \u0026got, td.SuperSliceOf(\u0026[]int{0, 14}, td.ArrayEntries{2: td.Gt(16)})) // succeeds and arrays:\ngot := [5]int{12, 14, 17, 26, 56} td.Cmp(t, got, td.SuperSliceOf([5]int{12}, nil)) // succeeds td.Cmp(t, got, td.SuperSliceOf([5]int{12}, td.ArrayEntries{2: 17})) // succeeds td.Cmp(t, \u0026got, td.SuperSliceOf(\u0026[5]int{0, 14}, td.ArrayEntries{2: td.Gt(16)})) // succeeds See also Array and Slice.\nSee also SuperSliceOf godoc.\nExamples Array example t := \u0026testing.T{} got := [4]int{42, 58, 26, 666} ok := td.Cmp(t, got, td.SuperSliceOf([4]int{1: 58}, td.ArrayEntries{3: td.Gt(660)}), \"checks array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.Cmp(t, got, td.SuperSliceOf([4]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf(\u0026[4]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf((*[4]int)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of an array pointer: true // Only check items #0 \u0026 #3 of an array pointer, using nil model: true TypedArray example t := \u0026testing.T{} type MyArray [4]int got := MyArray{42, 58, 26, 666} ok := td.Cmp(t, got, td.SuperSliceOf(MyArray{1: 58}, td.ArrayEntries{3: td.Gt(660)}), \"checks typed array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.Cmp(t, got, td.SuperSliceOf(MyArray{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf(\u0026MyArray{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf((*MyArray)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of an array pointer: true // Only check items #0 \u0026 #3 of an array pointer, using nil model: true Slice example t := \u0026testing.T{} got := []int{42, 58, 26, 666} ok := td.Cmp(t, got, td.SuperSliceOf([]int{1: 58}, td.ArrayEntries{3: td.Gt(660)}), \"checks array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.Cmp(t, got, td.SuperSliceOf([]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf(\u0026[]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf((*[]int)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of a slice pointer: true // Only check items #0 \u0026 #3 of a slice pointer, using nil model: true TypedSlice example t := \u0026testing.T{} type MySlice []int got := MySlice{42, 58, 26, 666} ok := td.Cmp(t, got, td.SuperSliceOf(MySlice{1: 58}, td.ArrayEntries{3: td.Gt(660)}), \"checks typed array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.Cmp(t, got, td.SuperSliceOf(MySlice{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf(\u0026MySlice{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer:\", ok) ok = td.Cmp(t, \u0026got, td.SuperSliceOf((*MySlice)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}), \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of a slice pointer: true // Only check items #0 \u0026 #3 of a slice pointer, using nil model: true CmpSuperSliceOf shortcut func CmpSuperSliceOf(t TestingT, got, model any, expectedEntries ArrayEntries, args ...any) bool CmpSuperSliceOf is a shortcut for:\ntd.Cmp(t, got, td.SuperSliceOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpSuperSliceOf godoc.\nExamples Array example t := \u0026testing.T{} got := [4]int{42, 58, 26, 666} ok := td.CmpSuperSliceOf(t, got, [4]int{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, got, [4]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, \u0026[4]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, (*[4]int)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of an array pointer: true // Only check items #0 \u0026 #3 of an array pointer, using nil model: true TypedArray example t := \u0026testing.T{} type MyArray [4]int got := MyArray{42, 58, 26, 666} ok := td.CmpSuperSliceOf(t, got, MyArray{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks typed array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, got, MyArray{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, \u0026MyArray{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, (*MyArray)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of an array pointer: true // Only check items #0 \u0026 #3 of an array pointer, using nil model: true Slice example t := \u0026testing.T{} got := []int{42, 58, 26, 666} ok := td.CmpSuperSliceOf(t, got, []int{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, got, []int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, \u0026[]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, (*[]int)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of a slice pointer: true // Only check items #0 \u0026 #3 of a slice pointer, using nil model: true TypedSlice example t := \u0026testing.T{} type MySlice []int got := MySlice{42, 58, 26, 666} ok := td.CmpSuperSliceOf(t, got, MySlice{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks typed array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, got, MySlice{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, \u0026MySlice{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer:\", ok) ok = td.CmpSuperSliceOf(t, \u0026got, (*MySlice)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of a slice pointer: true // Only check items #0 \u0026 #3 of a slice pointer, using nil model: true T.SuperSliceOf shortcut func (t *T) SuperSliceOf(got, model any, expectedEntries ArrayEntries, args ...any) bool SuperSliceOf is a shortcut for:\nt.Cmp(got, td.SuperSliceOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.SuperSliceOf godoc.\nExamples Array example t := td.NewT(\u0026testing.T{}) got := [4]int{42, 58, 26, 666} ok := t.SuperSliceOf(got, [4]int{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = t.SuperSliceOf(got, [4]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = t.SuperSliceOf(\u0026got, \u0026[4]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer:\", ok) ok = t.SuperSliceOf(\u0026got, (*[4]int)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of an array pointer: true // Only check items #0 \u0026 #3 of an array pointer, using nil model: true TypedArray example t := td.NewT(\u0026testing.T{}) type MyArray [4]int got := MyArray{42, 58, 26, 666} ok := t.SuperSliceOf(got, MyArray{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks typed array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = t.SuperSliceOf(got, MyArray{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = t.SuperSliceOf(\u0026got, \u0026MyArray{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer:\", ok) ok = t.SuperSliceOf(\u0026got, (*MyArray)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of an array pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of an array pointer: true // Only check items #0 \u0026 #3 of an array pointer, using nil model: true Slice example t := td.NewT(\u0026testing.T{}) got := []int{42, 58, 26, 666} ok := t.SuperSliceOf(got, []int{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = t.SuperSliceOf(got, []int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = t.SuperSliceOf(\u0026got, \u0026[]int{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer:\", ok) ok = t.SuperSliceOf(\u0026got, (*[]int)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of a slice pointer: true // Only check items #0 \u0026 #3 of a slice pointer, using nil model: true TypedSlice example t := td.NewT(\u0026testing.T{}) type MySlice []int got := MySlice{42, 58, 26, 666} ok := t.SuperSliceOf(got, MySlice{1: 58}, td.ArrayEntries{3: td.Gt(660)}, \"checks typed array %v\", got) fmt.Println(\"Only check items #1 \u0026 #3:\", ok) ok = t.SuperSliceOf(got, MySlice{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3:\", ok) ok = t.SuperSliceOf(\u0026got, \u0026MySlice{}, td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer:\", ok) ok = t.SuperSliceOf(\u0026got, (*MySlice)(nil), td.ArrayEntries{0: 42, 3: td.Between(660, 670)}, \"checks array %v\", got) fmt.Println(\"Only check items #0 \u0026 #3 of a slice pointer, using nil model:\", ok) // Output: // Only check items #1 \u0026 #3: true // Only check items #0 \u0026 #3: true // Only check items #0 \u0026 #3 of a slice pointer: true // Only check items #0 \u0026 #3 of a slice pointer, using nil model: true",
    "description": "func SuperSliceOf(model any, expectedEntries ArrayEntries) TestDeep SuperSliceOf operator compares the contents of an array, a pointer on an array, a slice or a pointer on a slice against the non-zero values of model (if any) and the values of expectedEntries. So entries with zero value of model are always ignored. If a zero value check is needed, this zero value has to be set in expectedEntries. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, only entries present in expectedEntries and non-zero ones present in model are checked. To check all entries of an array see Array operator. To check all entries of a slice see Slice operator.",
    "tags": [],
    "title": "SuperSliceOf",
    "uri": "/operators/supersliceof/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Tag(tag string, expectedValue any) TestDeep Tag is a smuggler operator. It only allows to name expectedValue, which can be an operator or a value. The data is then compared against expectedValue as if Tag was never called. It is only useful as JSON operator parameter, to name placeholders. See JSON operator for more details.\ntd.Cmp(t, gotValue, td.JSON(`{\"fullname\": $name, \"age\": $age, \"gender\": $gender}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $name td.Tag(\"age\", td.Between(41, 43)), // matches $age td.Tag(\"gender\", \"male\"))) // matches $gender TypeBehind method is delegated to expectedValue one if expectedValue is a TestDeep operator, otherwise it returns the type of expectedValue (or nil if it is originally untyped nil).\nSee also Tag godoc.",
    "description": "func Tag(tag string, expectedValue any) TestDeep Tag is a smuggler operator. It only allows to name expectedValue, which can be an operator or a value. The data is then compared against expectedValue as if Tag was never called. It is only useful as JSON operator parameter, to name placeholders. See JSON operator for more details.\ntd.Cmp(t, gotValue, td.JSON(`{\"fullname\": $name, \"age\": $age, \"gender\": $gender}`, td.Tag(\"name\", td.HasPrefix(\"Foo\")), // matches $name td.Tag(\"age\", td.Between(41, 43)), // matches $age td.Tag(\"gender\", \"male\"))) // matches $gender TypeBehind method is delegated to expectedValue one if expectedValue is a TestDeep operator, otherwise it returns the type of expectedValue (or nil if it is originally untyped nil).",
    "tags": [],
    "title": "Tag",
    "uri": "/operators/tag/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func TruncTime(expectedTime any, trunc ...time.Duration) TestDeep TruncTime operator compares time.Time (or assignable) values after truncating them to the optional trunc duration. See time.Time.Truncate for details about the truncation.\nIf trunc is missing, it defaults to 0.\nDuring comparison, location does not matter as time.Time.Equal method is used behind the scenes: a time instant in two different locations is the same time instant.\nWhatever the trunc value is, the monotonic clock is stripped before the comparison against expectedTime.\ngotDate := time.Date(2018, time.March, 9, 1, 2, 3, 999999999, time.UTC). In(time.FixedZone(\"UTC+2\", 2)) expected := time.Date(2018, time.March, 9, 1, 2, 3, 0, time.UTC) td.Cmp(t, gotDate, td.TruncTime(expected)) // fails, ns differ td.Cmp(t, gotDate, td.TruncTime(expected, time.Second)) // succeeds TypeBehind method returns the reflect.Type of expectedTime.\nSee also TruncTime godoc.\nExample Base example t := \u0026testing.T{} dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\"2018-05-01T12:45:53.123456789Z\") // Compare dates ignoring nanoseconds and monotonic parts expected := dateToTime(\"2018-05-01T12:45:53Z\") ok := td.Cmp(t, got, td.TruncTime(expected, time.Second), \"checks date %v, truncated to the second\", got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts expected = dateToTime(\"2018-05-01T11:22:33.444444444Z\") ok = td.Cmp(t, got, td.TruncTime(expected, 24*time.Hour), \"checks date %v, truncated to the day\", got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part expected = dateToTime(\"2018-05-01T12:45:53.123456789Z\") ok = td.Cmp(t, got, td.TruncTime(expected), \"checks date %v ignoring monotonic part\", got) fmt.Println(ok) // Output: // true // true // true CmpTruncTime shortcut func CmpTruncTime(t TestingT, got, expectedTime any, trunc time.Duration, args ...any) bool CmpTruncTime is a shortcut for:\ntd.Cmp(t, got, td.TruncTime(expectedTime, trunc), args...) See above for details.\nTruncTime optional parameter trunc is here mandatory. 0 value should be passed to mimic its absence in original TruncTime call.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpTruncTime godoc.\nExample Base example t := \u0026testing.T{} dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\"2018-05-01T12:45:53.123456789Z\") // Compare dates ignoring nanoseconds and monotonic parts expected := dateToTime(\"2018-05-01T12:45:53Z\") ok := td.CmpTruncTime(t, got, expected, time.Second, \"checks date %v, truncated to the second\", got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts expected = dateToTime(\"2018-05-01T11:22:33.444444444Z\") ok = td.CmpTruncTime(t, got, expected, 24*time.Hour, \"checks date %v, truncated to the day\", got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part expected = dateToTime(\"2018-05-01T12:45:53.123456789Z\") ok = td.CmpTruncTime(t, got, expected, 0, \"checks date %v ignoring monotonic part\", got) fmt.Println(ok) // Output: // true // true // true T.TruncTime shortcut func (t *T) TruncTime(got, expectedTime any, trunc time.Duration, args ...any) bool TruncTime is a shortcut for:\nt.Cmp(got, td.TruncTime(expectedTime, trunc), args...) See above for details.\nTruncTime optional parameter trunc is here mandatory. 0 value should be passed to mimic its absence in original TruncTime call.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.TruncTime godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\"2018-05-01T12:45:53.123456789Z\") // Compare dates ignoring nanoseconds and monotonic parts expected := dateToTime(\"2018-05-01T12:45:53Z\") ok := t.TruncTime(got, expected, time.Second, \"checks date %v, truncated to the second\", got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts expected = dateToTime(\"2018-05-01T11:22:33.444444444Z\") ok = t.TruncTime(got, expected, 24*time.Hour, \"checks date %v, truncated to the day\", got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part expected = dateToTime(\"2018-05-01T12:45:53.123456789Z\") ok = t.TruncTime(got, expected, 0, \"checks date %v ignoring monotonic part\", got) fmt.Println(ok) // Output: // true // true // true",
    "description": "func TruncTime(expectedTime any, trunc ...time.Duration) TestDeep TruncTime operator compares time.Time (or assignable) values after truncating them to the optional trunc duration. See time.Time.Truncate for details about the truncation.\nIf trunc is missing, it defaults to 0.\nDuring comparison, location does not matter as time.Time.Equal method is used behind the scenes: a time instant in two different locations is the same time instant.\nWhatever the trunc value is, the monotonic clock is stripped before the comparison against expectedTime.",
    "tags": [],
    "title": "TruncTime",
    "uri": "/operators/trunctime/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "To check the freshly created record contents using standard testing package, we have to do something like that:\nimport ( \"testing\" \"time\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if err != nil { t.Errorf(\"An error occurred: %s\", err) } else { expected := Record{Name: \"Bob\", Age: 23} if record.Id == 0 { t.Error(\"Id probably not initialized\") } if record.Name != expected.Name { t.Errorf(\"Name field differs, got=%s, expected=%s\", record.Name, expected.Name) } if record.Age != expected.Age { t.Errorf(\"Age field differs, got=%d, expected=%d\", record.Age, expected.Age) } if before.After(record.CreatedAt) || time.Now().Before(record.CreatedAt) { t.Errorf(\"CreatedAt field not expected: %s\", record.CreatedAt) } } } Test in in playground: https://play.golang.org/p/Qyc7L2z1Rf-",
    "description": "To check the freshly created record contents using standard testing package, we have to do something like that:\nimport ( \"testing\" \"time\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if err != nil { t.Errorf(\"An error occurred: %s\", err) } else { expected := Record{Name: \"Bob\", Age: 23} if record.Id == 0 { t.Error(\"Id probably not initialized\") } if record.Name != expected.Name { t.Errorf(\"Name field differs, got=%s, expected=%s\", record.Name, expected.Name) } if record.Age != expected.Age { t.Errorf(\"Age field differs, got=%d, expected=%d\", record.Age, expected.Age) } if before.After(record.CreatedAt) || time.Now().Before(record.CreatedAt) { t.Errorf(\"CreatedAt field not expected: %s\", record.CreatedAt) } } } Test in in playground: https://play.golang.org/p/Qyc7L2z1Rf-",
    "tags": [],
    "title": "Using testing package",
    "uri": "/example/using-testing/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Values(val any) TestDeep Values is a smuggler operator. It takes a map and compares its ordered values to val.\nval can be a slice of items of the same type as the map values:\ngot := map[int]string{3: \"c\", 1: \"a\", 2: \"b\"} td.Cmp(t, got, td.Values([]string{\"a\", \"b\", \"c\"})) // succeeds, values sorted td.Cmp(t, got, td.Values([]string{\"c\", \"a\", \"b\"})) // fails as not sorted as well as an other operator as Bag, for example, to test values in an unsorted manner:\ngot := map[int]string{3: \"c\", 1: \"a\", 2: \"b\"} td.Cmp(t, got, td.Values(td.Bag(\"c\", \"a\", \"b\"))) // succeeds See also Keys.\nSee also Values godoc.\nExample Base example t := \u0026testing.T{} got := map[string]int{\"foo\": 1, \"bar\": 2, \"zip\": 3} // Values tests values in an ordered manner ok := td.Cmp(t, got, td.Values([]int{1, 2, 3})) fmt.Println(\"All sorted values are found:\", ok) // If the expected values are not ordered, it fails ok = td.Cmp(t, got, td.Values([]int{3, 1, 2})) fmt.Println(\"All unsorted values are found:\", ok) // To circumvent that, one can use Bag operator ok = td.Cmp(t, got, td.Values(td.Bag(3, 1, 2))) fmt.Println(\"All unsorted values are found, with the help of Bag operator:\", ok) // Check that each value is between 1 and 3 ok = td.Cmp(t, got, td.Values(td.ArrayEach(td.Between(1, 3)))) fmt.Println(\"Each value is between 1 and 3:\", ok) // Output: // All sorted values are found: true // All unsorted values are found: false // All unsorted values are found, with the help of Bag operator: true // Each value is between 1 and 3: true CmpValues shortcut func CmpValues(t TestingT, got, val any, args ...any) bool CmpValues is a shortcut for:\ntd.Cmp(t, got, td.Values(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpValues godoc.\nExample Base example t := \u0026testing.T{} got := map[string]int{\"foo\": 1, \"bar\": 2, \"zip\": 3} // Values tests values in an ordered manner ok := td.CmpValues(t, got, []int{1, 2, 3}) fmt.Println(\"All sorted values are found:\", ok) // If the expected values are not ordered, it fails ok = td.CmpValues(t, got, []int{3, 1, 2}) fmt.Println(\"All unsorted values are found:\", ok) // To circumvent that, one can use Bag operator ok = td.CmpValues(t, got, td.Bag(3, 1, 2)) fmt.Println(\"All unsorted values are found, with the help of Bag operator:\", ok) // Check that each value is between 1 and 3 ok = td.CmpValues(t, got, td.ArrayEach(td.Between(1, 3))) fmt.Println(\"Each value is between 1 and 3:\", ok) // Output: // All sorted values are found: true // All unsorted values are found: false // All unsorted values are found, with the help of Bag operator: true // Each value is between 1 and 3: true T.Values shortcut func (t *T) Values(got, val any, args ...any) bool Values is a shortcut for:\nt.Cmp(got, td.Values(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Values godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) got := map[string]int{\"foo\": 1, \"bar\": 2, \"zip\": 3} // Values tests values in an ordered manner ok := t.Values(got, []int{1, 2, 3}) fmt.Println(\"All sorted values are found:\", ok) // If the expected values are not ordered, it fails ok = t.Values(got, []int{3, 1, 2}) fmt.Println(\"All unsorted values are found:\", ok) // To circumvent that, one can use Bag operator ok = t.Values(got, td.Bag(3, 1, 2)) fmt.Println(\"All unsorted values are found, with the help of Bag operator:\", ok) // Check that each value is between 1 and 3 ok = t.Values(got, td.ArrayEach(td.Between(1, 3))) fmt.Println(\"Each value is between 1 and 3:\", ok) // Output: // All sorted values are found: true // All unsorted values are found: false // All unsorted values are found, with the help of Bag operator: true // Each value is between 1 and 3: true",
    "description": "func Values(val any) TestDeep Values is a smuggler operator. It takes a map and compares its ordered values to val.\nval can be a slice of items of the same type as the map values:\ngot := map[int]string{3: \"c\", 1: \"a\", 2: \"b\"} td.Cmp(t, got, td.Values([]string{\"a\", \"b\", \"c\"})) // succeeds, values sorted td.Cmp(t, got, td.Values([]string{\"c\", \"a\", \"b\"})) // fails as not sorted as well as an other operator as Bag, for example, to test values in an unsorted manner:\ngot := map[int]string{3: \"c\", 1: \"a\", 2: \"b\"} td.Cmp(t, got, td.Values(td.Bag(\"c\", \"a\", \"b\"))) // succeeds See also Keys.\nSee also Values godoc.",
    "tags": [],
    "title": "Values",
    "uri": "/operators/values/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Operators",
    "content": "func Zero() TestDeep Zero operator checks that data is zero regarding its type.\nnil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \"\" is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized. Beware that:\ntd.Cmp(t, AnyStruct{}, td.Zero()) // is true td.Cmp(t, \u0026AnyStruct{}, td.Zero()) // is false, coz pointer ≠ nil td.Cmp(t, \u0026AnyStruct{}, td.Ptr(td.Zero())) // is true See also Empty, Nil and NotZero.\nSee also Zero godoc.\nExample Base example t := \u0026testing.T{} ok := td.Cmp(t, 0, td.Zero()) fmt.Println(ok) ok = td.Cmp(t, float64(0), td.Zero()) fmt.Println(ok) ok = td.Cmp(t, 12, td.Zero()) // fails, as 12 is not 0 :) fmt.Println(ok) ok = td.Cmp(t, (map[string]int)(nil), td.Zero()) fmt.Println(ok) ok = td.Cmp(t, map[string]int{}, td.Zero()) // fails, as not nil fmt.Println(ok) ok = td.Cmp(t, ([]int)(nil), td.Zero()) fmt.Println(ok) ok = td.Cmp(t, []int{}, td.Zero()) // fails, as not nil fmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.Zero()) fmt.Println(ok) ok = td.Cmp(t, [3]int{0, 1}, td.Zero()) // fails, DATA[1] is not 0 fmt.Println(ok) ok = td.Cmp(t, bytes.Buffer{}, td.Zero()) fmt.Println(ok) ok = td.Cmp(t, \u0026bytes.Buffer{}, td.Zero()) // fails, as pointer not nil fmt.Println(ok) ok = td.Cmp(t, \u0026bytes.Buffer{}, td.Ptr(td.Zero())) // OK with the help of Ptr() fmt.Println(ok) // Output: // true // true // false // true // false // true // false // true // false // true // false // true CmpZero shortcut func CmpZero(t TestingT, got any, args ...any) bool CmpZero is a shortcut for:\ntd.Cmp(t, got, td.Zero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nIf t is a *T then its Config field is inherited.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also CmpZero godoc.\nExample Base example t := \u0026testing.T{} ok := td.CmpZero(t, 0) fmt.Println(ok) ok = td.CmpZero(t, float64(0)) fmt.Println(ok) ok = td.CmpZero(t, 12) // fails, as 12 is not 0 :) fmt.Println(ok) ok = td.CmpZero(t, (map[string]int)(nil)) fmt.Println(ok) ok = td.CmpZero(t, map[string]int{}) // fails, as not nil fmt.Println(ok) ok = td.CmpZero(t, ([]int)(nil)) fmt.Println(ok) ok = td.CmpZero(t, []int{}) // fails, as not nil fmt.Println(ok) ok = td.CmpZero(t, [3]int{}) fmt.Println(ok) ok = td.CmpZero(t, [3]int{0, 1}) // fails, DATA[1] is not 0 fmt.Println(ok) ok = td.CmpZero(t, bytes.Buffer{}) fmt.Println(ok) ok = td.CmpZero(t, \u0026bytes.Buffer{}) // fails, as pointer not nil fmt.Println(ok) ok = td.Cmp(t, \u0026bytes.Buffer{}, td.Ptr(td.Zero())) // OK with the help of Ptr() fmt.Println(ok) // Output: // true // true // false // true // false // true // false // true // false // true // false // true T.Zero shortcut func (t *T) Zero(got any, args ...any) bool Zero is a shortcut for:\nt.Cmp(got, td.Zero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs… are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u003e 1 and the first item of args is a string and contains a ‘%’ rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\nSee also T.Zero godoc.\nExample Base example t := td.NewT(\u0026testing.T{}) ok := t.Zero(0) fmt.Println(ok) ok = t.Zero(float64(0)) fmt.Println(ok) ok = t.Zero(12) // fails, as 12 is not 0 :) fmt.Println(ok) ok = t.Zero((map[string]int)(nil)) fmt.Println(ok) ok = t.Zero(map[string]int{}) // fails, as not nil fmt.Println(ok) ok = t.Zero(([]int)(nil)) fmt.Println(ok) ok = t.Zero([]int{}) // fails, as not nil fmt.Println(ok) ok = t.Zero([3]int{}) fmt.Println(ok) ok = t.Zero([3]int{0, 1}) // fails, DATA[1] is not 0 fmt.Println(ok) ok = t.Zero(bytes.Buffer{}) fmt.Println(ok) ok = t.Zero(\u0026bytes.Buffer{}) // fails, as pointer not nil fmt.Println(ok) ok = t.Cmp(\u0026bytes.Buffer{}, td.Ptr(td.Zero())) // OK with the help of Ptr() fmt.Println(ok) // Output: // true // true // false // true // false // true // false // true // false // true // false // true",
    "description": "func Zero() TestDeep Zero operator checks that data is zero regarding its type.\nnil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \"\" is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized. Beware that:\ntd.Cmp(t, AnyStruct{}, td.Zero()) // is true td.Cmp(t, \u0026AnyStruct{}, td.Zero()) // is false, coz pointer ≠ nil td.Cmp(t, \u0026AnyStruct{}, td.Ptr(td.Zero())) // is true See also Empty, Nil and NotZero.",
    "tags": [],
    "title": "Zero",
    "uri": "/operators/zero/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "Imagine a function returning a struct containing a newly created database record. The Id and the CreatedAt fields are set by the database layer:\ntype Record struct { Id uint64 Name string Age int CreatedAt time.Time } func CreateRecord(name string, age int) (*Record, error) { // Do INSERT INTO … and return newly created record or error if it failed }",
    "description": "Imagine a function returning a struct containing a newly created database record. The Id and the CreatedAt fields are set by the database layer:\ntype Record struct { Id uint64 Name string Age int CreatedAt time.Time } func CreateRecord(name string, age int) (*Record, error) { // Do INSERT INTO … and return newly created record or error if it failed }",
    "tags": [],
    "title": "Tutorial",
    "uri": "/example/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { // Compares MyFunc() result against a fixed value td.Cmp(t, MyFunc(), 128, \"MyFunc() result is 128\") // Compares MyFunc() result using the Between Testdeep operator td.Cmp(t, MyFunc(), td.Between(100, 199), \"MyFunc() result is between 100 and 199\") } func Cmp(t TestingT, got, expected any, args ...any) bool func CmpError(t TestingT, got error, args ...any) bool func CmpFalse(t TestingT, got any, args ...any) bool func CmpLax(t TestingT, got, expected any, args ...any) bool (in fact the shortcut of Lax operator) func CmpNoError(t TestingT, got error, args ...any) bool func CmpNot(t TestingT, got, notExpected any, args ...any) bool (in fact the shortcut of Not operator) func CmpNotPanic(t TestingT, fn func(), args ...any) bool func CmpPanic(t TestingT, fn func(), expectedPanic any, args ...any) bool func CmpTrue(t TestingT, got any, args ...any) bool func EqDeeply(got, expected any) bool func EqDeeplyError(got, expected any) error CmpDeeply() is now replaced by Cmp(), but it is still available for backward compatibility purpose.\nMain shortcut functions import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { td.CmpBetween(t, MyFunc(), 100, 199, td.BoundsInIn, \"MyFunc() result is between 100 and 199\") } For each of these functions, it is always a shortcut on Cmp() and the correponding Testdeep operator:\nCmpHasPrefix(t, got, expected, …) ⇒ Cmp(t, got, HasPrefix(expected), …) ^-------^ ^-------^ +---------------------------------------------+ Each shortcut method is described in the corresponding operator page. See operators list.",
    "description": "import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { // Compares MyFunc() result against a fixed value td.Cmp(t, MyFunc(), 128, \"MyFunc() result is 128\") // Compares MyFunc() result using the Between Testdeep operator td.Cmp(t, MyFunc(), td.Between(100, 199), \"MyFunc() result is between 100 and 199\") } func Cmp(t TestingT, got, expected any, args ...any) bool func CmpError(t TestingT, got error, args ...any) bool func CmpFalse(t TestingT, got any, args ...any) bool func CmpLax(t TestingT, got, expected any, args ...any) bool (in fact the shortcut of Lax operator) func CmpNoError(t TestingT, got error, args ...any) bool func CmpNot(t TestingT, got, notExpected any, args ...any) bool (in fact the shortcut of Not operator) func CmpNotPanic(t TestingT, fn func(), args ...any) bool func CmpPanic(t TestingT, fn func(), expectedPanic any, args ...any) bool func CmpTrue(t TestingT, got any, args ...any) bool func EqDeeply(got, expected any) bool func EqDeeplyError(got, expected any) error CmpDeeply() is now replaced by Cmp(), but it is still available for backward compatibility purpose.",
    "tags": [],
    "title": "Functions",
    "uri": "/functions/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "All operators All all expected values have to match Any at least one expected value have to match Array compares the contents of an array or a pointer on an array ArrayEach compares each array or slice item Bag compares the contents of an array or a slice without taking care of the order of items Between checks that a number, string or time.Time is between two bounds Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Code checks using a custom function Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key Delay delays the operator construction till first use Empty checks that an array, a channel, a map, a slice or a string is empty ErrorIs checks the data is an error and matches a wrapped error First find the first matching item of a slice or an array then compare its content Grep reduces a slice or an array before comparing its content Gt checks that a number, string or time.Time is greater than a value Gte checks that a number, string or time.Time is greater or equal than a value HasPrefix checks the prefix of a string, []byte, error or fmt.Stringer interfaces HasSuffix checks the suffix of a string, []byte, error or fmt.Stringer interfaces Ignore allows to ignore a comparison Isa checks the data type or whether data implements an interface or not JSON compares against JSON representation JSONPointer compares against JSON representation using a JSON pointer Keys checks keys of a map Last find the last matching item of a slice or an array then compare its content Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length Lt checks that a number, string or time.Time is lesser than a value Lte checks that a number, string or time.Time is lesser or equal than a value Map compares the contents of a map MapEach compares each map entry N compares a number with a tolerance value NaN checks a floating number is math.NaN Nil compares to nil None no values have to match Not value must not match NotAny compares the contents of an array or a slice, no values have to match NotEmpty checks that an array, a channel, a map, a slice or a string is not empty NotNaN checks a floating number is not math.NaN NotNil checks that data is not nil NotZero checks that data is not zero regarding its type PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Re allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups ReAll allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Recv checks the value read from a channel Set compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items Shallow compares pointers only, not their contents Slice compares the contents of a slice or a pointer on a slice Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Sort sorts a slice or an array before comparing its content Sorted checks a slice or an array is sorted SStruct strictly compares the contents of a struct or a pointer on a struct String checks a string, []byte, error or fmt.Stringer interfaces string contents Struct compares the contents of a struct or a pointer on a struct SubBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some exclusions SubJSONOf compares struct or map against JSON representation but with potentially some exclusions SubMapOf compares the contents of a map but with potentially some exclusions SubSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some exclusions SuperBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some extra items SuperJSONOf compares struct or map against JSON representation but with potentially extra entries SuperMapOf compares the contents of a map but with potentially some extra entries SuperSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some extra items SuperSliceOf compares the contents of a slice, a pointer on a slice, an array or a pointer on an array but with potentially some extra entries Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders TruncTime compares time.Time (or assignable) values after truncating them Values checks values of a map Zero checks data against its zero’ed conterpart Smuggler operators A smuggler operator is an operator able to transform the value (by changing its value or even its type) before comparing it.\nThe following operators are smuggler ones:\nCap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key ErrorIs checks the data is an error and matches a wrapped error First find the first matching item of a slice or an array then compare its content Grep reduces a slice or an array before comparing its content JSONPointer compares against JSON representation using a JSON pointer Keys checks keys of a map Last find the last matching item of a slice or an array then compare its content Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Recv checks the value read from a channel Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Sort sorts a slice or an array before comparing its content Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders Values checks values of a map TypeBehind method TypeBehind() reflect.Type This method returns the type handled by the operator or nil if it is not known. tdhttp helper uses it to know how to unmarshal HTTP responses bodies before comparing them using the operator.\nIt is usually not used outside the go-testdeep repository.",
    "description": "All operators All all expected values have to match Any at least one expected value have to match Array compares the contents of an array or a pointer on an array ArrayEach compares each array or slice item Bag compares the contents of an array or a slice without taking care of the order of items Between checks that a number, string or time.Time is between two bounds Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Code checks using a custom function Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key Delay delays the operator construction till first use Empty checks that an array, a channel, a map, a slice or a string is empty ErrorIs checks the data is an error and matches a wrapped error First find the first matching item of a slice or an array then compare its content Grep reduces a slice or an array before comparing its content Gt checks that a number, string or time.Time is greater than a value Gte checks that a number, string or time.Time is greater or equal than a value HasPrefix checks the prefix of a string, []byte, error or fmt.Stringer interfaces HasSuffix checks the suffix of a string, []byte, error or fmt.Stringer interfaces Ignore allows to ignore a comparison Isa checks the data type or whether data implements an interface or not JSON compares against JSON representation JSONPointer compares against JSON representation using a JSON pointer Keys checks keys of a map Last find the last matching item of a slice or an array then compare its content Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length Lt checks that a number, string or time.Time is lesser than a value Lte checks that a number, string or time.Time is lesser or equal than a value Map compares the contents of a map MapEach compares each map entry N compares a number with a tolerance value NaN checks a floating number is math.NaN Nil compares to nil None no values have to match Not value must not match NotAny compares the contents of an array or a slice, no values have to match NotEmpty checks that an array, a channel, a map, a slice or a string is not empty NotNaN checks a floating number is not math.NaN NotNil checks that data is not nil NotZero checks that data is not zero regarding its type PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Re allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups ReAll allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Recv checks the value read from a channel Set compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items Shallow compares pointers only, not their contents Slice compares the contents of a slice or a pointer on a slice Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Sort sorts a slice or an array before comparing its content Sorted checks a slice or an array is sorted SStruct strictly compares the contents of a struct or a pointer on a struct String checks a string, []byte, error or fmt.Stringer interfaces string contents Struct compares the contents of a struct or a pointer on a struct SubBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some exclusions SubJSONOf compares struct or map against JSON representation but with potentially some exclusions SubMapOf compares the contents of a map but with potentially some exclusions SubSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some exclusions SuperBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some extra items SuperJSONOf compares struct or map against JSON representation but with potentially extra entries SuperMapOf compares the contents of a map but with potentially some extra entries SuperSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some extra items SuperSliceOf compares the contents of a slice, a pointer on a slice, an array or a pointer on an array but with potentially some extra entries Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders TruncTime compares time.Time (or assignable) values after truncating them Values checks values of a map Zero checks data against its zero’ed conterpart Smuggler operators A smuggler operator is an operator able to transform the value (by changing its value or even its type) before comparing it.",
    "tags": [],
    "title": "Operators",
    "uri": "/operators/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "td package, via its Cmp* functions, handles the tests and all the error message boiler plate. Let’s do it:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.Cmp(t, record.Id, td.NotZero(), \"Id initialized\") td.Cmp(t, record.Name, \"Bob\") td.Cmp(t, record.Age, 23) td.Cmp(t, record.CreatedAt, td.Between(before, time.Now())) } } Test it in playground: https://play.golang.org/p/bfe-aj_gx8Q\nAs we cannot guess the Id field value before its creation, we use the NotZero operator to check it is set by CreateRecord() call. The same is true for the creation date field CreatedAt. Thanks to the Between operator we can check it is set with a value included between the date before CreateRecord() call and the date just after.\nNote that if Id and CreateAt could be known in advance, we could simply do:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.Cmp(t, record, \u0026Record{ Id: 1234, Name: \"Bob\", Age: 23, CreatedAt: time.Date(2019, time.May, 1, 12, 13, 14, 0, time.UTC), }) } } But unfortunately, it is common to not know exactly the value of some fields…",
    "description": "td package, via its Cmp* functions, handles the tests and all the error message boiler plate. Let’s do it:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.Cmp(t, record.Id, td.NotZero(), \"Id initialized\") td.Cmp(t, record.Name, \"Bob\") td.Cmp(t, record.Age, 23) td.Cmp(t, record.CreatedAt, td.Between(before, time.Now())) } } Test it in playground: https://play.golang.org/p/bfe-aj_gx8Q\nAs we cannot guess the Id field value before its creation, we use the NotZero operator to check it is set by CreateRecord() call. The same is true for the creation date field CreatedAt. Thanks to the Between operator we can check it is set with a value included between the date before CreateRecord() call and the date just after.",
    "tags": [],
    "title": "Basic go-testdeep approach",
    "uri": "/example/basic-testdeep/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "HTTP API test helper aka tdhttp The tdhttp package helper allows to easily test HTTP APIs.\nIt handles any kind of API, with some specific features for the routes accepting and/or returning JSON or XML.\nAll known web frameworks are handled:\nnet/http standard, see Main example below Beego echo Gin gorilla/mux go-swagger HttpRouter pat and any other ones as long as they provide a net/http.Handler instance. See examples of use in tdhttp package example section, in FAQ or expand the one below:\nMain example package myapi import ( \"encoding/json\" \"encoding/xml\" \"fmt\" \"io\" \"net/http\" \"net/url\" \"strconv\" \"strings\" \"sync\" \"testing\" \"time\" \"github.com/maxatome/go-testdeep/helpers/tdhttp\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyAPI(t *testing.T) { // Our API handle Persons with 3 routes: // - POST /person // - GET /person/{personID} // - DELETE /person/{personID} // Person describes a person. type Person struct { ID int64 `json:\"id,omitempty\" xml:\"ID,omitempty\"` Name string `json:\"name\" xml:\"Name\"` Age int `json:\"age\" xml:\"Age\"` CreatedAt *time.Time `json:\"created_at,omitempty\" xml:\"CreatedAt,omitempty\"` } // Error is returned to the client in case of error. type Error struct { Mesg string `json:\"message\" xml:\"Message\"` Code int `json:\"code\" xml:\"Code\"` } // Our µDB :) var mu sync.Mutex personByID := map[int64]*Person{} personByName := map[string]*Person{} var lastID int64 // reply is a helper to send responses. reply := func(w http.ResponseWriter, status int, contentType string, body any) { if body == nil { w.WriteHeader(status) return } w.Header().Set(\"Content-Type\", contentType) w.WriteHeader(status) switch contentType { case \"application/json\": json.NewEncoder(w).Encode(body) //nolint: errcheck case \"application/xml\": xml.NewEncoder(w).Encode(body) //nolint: errcheck default: // text/plain fmt.Fprintf(w, \"%+v\", body) //nolint: errcheck } } // Our API mux := http.NewServeMux() // POST /person mux.HandleFunc(\"/person\", func(w http.ResponseWriter, req *http.Request) { if req.Method != http.MethodPost { http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed) return } if req.Body == nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } defer req.Body.Close() //nolint: errcheck var in Person var contentType string switch req.Header.Get(\"Content-Type\") { case \"application/json\": err := json.NewDecoder(req.Body).Decode(\u0026in) if err != nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } case \"application/xml\": err := xml.NewDecoder(req.Body).Decode(\u0026in) if err != nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } case \"application/x-www-form-urlencoded\": b, err := io.ReadAll(req.Body) if err != nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } v, err := url.ParseQuery(string(b)) if err != nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } in.Name = v.Get(\"name\") in.Age, err = strconv.Atoi(v.Get(\"age\")) if err != nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } default: http.Error(w, \"Unsupported media type\", http.StatusUnsupportedMediaType) return } contentType = req.Header.Get(\"Accept\") if in.Name == \"\" || in.Age \u003c= 0 { reply(w, http.StatusBadRequest, contentType, Error{ Mesg: \"Empty name or bad age\", Code: http.StatusBadRequest, }) return } mu.Lock() defer mu.Unlock() if personByName[in.Name] != nil { reply(w, http.StatusConflict, contentType, Error{ Mesg: \"Person already exists\", Code: http.StatusConflict, }) return } lastID++ in.ID = lastID now := time.Now() in.CreatedAt = \u0026now personByID[in.ID] = \u0026in personByName[in.Name] = \u0026in reply(w, http.StatusCreated, contentType, in) }) // GET /person/{id} // DELETE /person/{id} mux.HandleFunc(\"/person/\", func(w http.ResponseWriter, req *http.Request) { id, err := strconv.ParseInt(strings.TrimPrefix(req.URL.Path, \"/person/\"), 10, 64) if err != nil { http.Error(w, \"Bad request\", http.StatusBadRequest) return } accept := req.Header.Get(\"Accept\") mu.Lock() defer mu.Unlock() if personByID[id] == nil { reply(w, http.StatusNotFound, accept, Error{ Mesg: \"Person does not exist\", Code: http.StatusNotFound, }) return } switch req.Method { case http.MethodGet: reply(w, http.StatusOK, accept, personByID[id]) case http.MethodDelete: delete(personByID, id) reply(w, http.StatusNoContent, \"\", nil) default: http.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed) } }) // // Let's test our API // ta := tdhttp.NewTestAPI(t, mux) // Re-usable custom operator to check Content-Type header contentTypeIs := func(ct string) td.TestDeep { return td.SuperMapOf(http.Header{\"Content-Type\": []string{ct}}, nil) } // // Person not found // ta.Get(\"/person/42\", \"Accept\", \"application/json\"). Name(\"GET /person/42 - JSON\"). CmpStatus(404). CmpHeader(contentTypeIs(\"application/json\")). CmpJSONBody(Error{ Mesg: \"Person does not exist\", Code: 404, }) t.Log(\"GET /person/42 - JSON:\", !ta.Failed()) ta.Get(\"/person/42\", \"Accept\", \"application/xml\"). Name(\"GET /person/42 - XML\"). CmpStatus(404). CmpHeader(contentTypeIs(\"application/xml\")). CmpXMLBody(Error{ Mesg: \"Person does not exist\", Code: 404, }) t.Log(\"GET /person/42 - XML:\", !ta.Failed()) ta.Get(\"/person/42\", \"Accept\", \"text/plain\"). Name(\"GET /person/42 - raw\"). CmpStatus(404). CmpHeader(contentTypeIs(\"text/plain\")). CmpBody(\"{Mesg:Person does not exist Code:404}\") t.Log(\"GET /person/42 - raw:\", !ta.Failed()) // // Create a Person // var bobID int64 ta.PostXML(\"/person\", Person{Name: \"Bob\", Age: 32}, \"Accept\", \"application/xml\"). Name(\"POST /person - XML\"). CmpStatus(201). CmpHeader(contentTypeIs(\"application/xml\")). CmpXMLBody(Person{ // using operator anchoring directly in literal ID: ta.A(td.Catch(\u0026bobID, td.NotZero()), int64(0)).(int64), Name: \"Bob\", Age: 32, CreatedAt: ta.A(td.Ptr(td.Between(ta.SentAt(), time.Now()))).(*time.Time), }) t.Logf(\"POST /person - XML: %t → Bob ID=%d\\n\", !ta.Failed(), bobID) var aliceID int64 ta.PostJSON(\"/person\", Person{Name: \"Alice\", Age: 35}, \"Accept\", \"application/json\"). Name(\"POST /person - JSON\"). CmpStatus(201). CmpHeader(contentTypeIs(\"application/json\")). CmpJSONBody(td.JSON(` // using JSON operator (yes comment allowed in JSON!) { \"id\": $1, \"name\": \"Alice\", \"age\": 35, \"created_at\": $2 }`, td.Catch(\u0026aliceID, td.NotZero()), td.Smuggle(func(date string) (time.Time, error) { return time.Parse(time.RFC3339Nano, date) }, td.Between(ta.SentAt(), time.Now())))) t.Logf(\"POST /person - JSON: %t → Alice ID=%d\\n\", !ta.Failed(), aliceID) var brittID int64 ta.PostForm(\"/person\", url.Values{ \"name\": []string{\"Britt\"}, \"age\": []string{\"29\"}, }, \"Accept\", \"text/plain\"). Name(\"POST /person - raw\"). CmpStatus(201). CmpHeader(contentTypeIs(\"text/plain\")). // using Re (= Regexp) operator CmpBody(td.Re(`\\{ID:(\\d+) Name:Britt Age:29 CreatedAt:.*\\}\\z`, td.Smuggle(func(groups []string) (int64, error) { return strconv.ParseInt(groups[0], 10, 64) }, td.Catch(\u0026brittID, td.NotZero())))) t.Logf(\"POST /person - raw: %t → Britt ID=%d\\n\", !ta.Failed(), brittID) // // Get a Person // ta.Get(fmt.Sprintf(\"/person/%d\", aliceID), \"Accept\", \"application/xml\"). Name(\"GET Alice - XML (ID #%d)\", aliceID). CmpStatus(200). CmpHeader(contentTypeIs(\"application/xml\")). CmpXMLBody(td.SStruct( // using SStruct operator Person{ ID: aliceID, Name: \"Alice\", Age: 35, }, td.StructFields{ \"CreatedAt\": td.Ptr(td.NotZero()), }, )) t.Log(\"GET XML Alice:\", !ta.Failed()) ta.Get(fmt.Sprintf(\"/person/%d\", aliceID), \"Accept\", \"application/json\"). Name(\"GET Alice - JSON (ID #%d)\", aliceID). CmpStatus(200). CmpHeader(contentTypeIs(\"application/json\")). CmpJSONBody(td.JSON(` // using JSON operator (yes comment allowed in JSON!) { \"id\": $1, \"name\": \"Alice\", \"age\": 35, \"created_at\": $2 }`, aliceID, td.Not(td.Re(`^0001-01-01`)), // time is not 0001-01-01… aka zero time.Time )) t.Log(\"GET JSON Alice:\", !ta.Failed()) // // Delete a Person // ta.Delete(fmt.Sprintf(\"/person/%d\", aliceID), nil). Name(\"DELETE Alice (ID #%d)\", aliceID). CmpStatus(204). CmpHeader(td.Not(td.ContainsKey(\"Content-Type\"))). NoBody() t.Log(\"DELETE Alice:\", !ta.Failed()) // Check Alice is deleted ta.Get(fmt.Sprintf(\"/person/%d\", aliceID), \"Accept\", \"application/json\"). Name(\"GET (deleted) Alice - JSON (ID #%d)\", aliceID). CmpStatus(404). CmpHeader(contentTypeIs(\"application/json\")). CmpJSONBody(td.JSON(` { \"message\": \"Person does not exist\", \"code\": 404 }`)) t.Log(\"Alice is not found anymore:\", !ta.Failed()) } Tests suite helper aka tdsuite The package tdsuite adds tests suite feature to go-testdeep in a non-intrusive way, but easily and powerfully.\nHelpers utils aka tdutil To write helpers, some commonly used functions are shared in tdutil package.",
    "description": "HTTP API test helper aka tdhttp The tdhttp package helper allows to easily test HTTP APIs.\nIt handles any kind of API, with some specific features for the routes accepting and/or returning JSON or XML.\nAll known web frameworks are handled:\nnet/http standard, see Main example below Beego echo Gin gorilla/mux go-swagger HttpRouter pat and any other ones as long as they provide a net/http.Handler instance. See examples of use in tdhttp package example section, in FAQ or expand the one below:",
    "tags": [],
    "title": "Helpers",
    "uri": "/helpers/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "How to mix strict requirements and simple assertions? import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestAssertionsAndRequirements(t *testing.T) { assert, require := td.AssertRequire(t) got := SomeFunction() require.Cmp(got, expected) // if it fails: report error + abort assert.Cmp(got, expected) // if it fails: report error + continue } Why nil is handled so specifically? var pn *int td.Cmp(t, pn, nil) fails with the error And, yes, it is normal. (TL;DR use CmpNil instead, safer, or use CmpLax, but be careful of edge cases.)\nTo understand why, look at the following examples:\nvar err error td.Cmp(t, err, nil) works (and you want it works), but\nvar err error = (*MyError)(nil) td.Cmp(t, err, nil) fails with the error and in most cases you want it fails, because err is not nil! The pointer stored in the interface is nil, but not the interface itself.\nAs Cmp got parameter type is any, when you pass an interface variable in it (whatever the interface is), Cmp always receives an any. So here, Cmp receives (*MyError)(nil) in the got interface, and not error((*MyError)(nil)) ⇒ the error interface information is lost at the compilation time.\nIn other words, Cmp has no abilities to tell the difference between error((*MyError)(nil)) and (*MyError)(nil) when passed in got parameter.\nThat is why Cmp is strict by default, and requires that nil be strongly typed, to be able to detect when a non-nil interface contains a nil pointer.\nSo to recap:\nvar pn *int td.Cmp(t, pn, nil) // fails as nil is not strongly typed td.Cmp(t, pn, (*int)(nil)) // succeeds td.Cmp(t, pn, td.Nil()) // succeeds td.CmpNil(t, pn) // succeeds td.Cmp(t, pn, td.Lax(nil)) // succeeds td.CmpLax(t, pn, nil) // succeeds var err error td.Cmp(t, err, nil) // succeeds td.Cmp(t, err, (*MyError)(nil)) // fails as err does not contain any value td.Cmp(t, err, td.Nil()) // succeeds td.CmpNil(t, err) // succeeds td.Cmp(t, err, td.Lax(nil)) // succeeds td.CmpLax(t, err, nil) // succeeds td.CmpError(t, err) // fails as err is nil td.CmpNoError(t, err) // succeeds err = (*MyError)(nil) td.Cmp(t, err, nil) // fails as err contains a value td.Cmp(t, err, (*MyError)(nil)) // succeeds td.Cmp(t, err, td.Nil()) // succeeds td.CmpNil(t, err) // succeeds td.Cmp(t, err, td.Lax(nil)) // succeeds *** /!\\ be careful here! *** td.CmpLax(t, err, nil) // succeeds *** /!\\ be careful here! *** td.CmpError(t, err) // succeeds td.CmpNoError(t, err) // fails as err contains a value Morality:\nto compare a pointer against nil, use CmpNil or strongly type nil (e.g. (*int)(nil)) in expected parameter of Cmp; to compare an error against nil, use CmpNoError or nil direcly in expected parameter of Cmp. How does operator anchoring work? Take this struct, returned by a GetPerson() function:\ntype Person struct { ID int64 Name string Age uint8 } For the Person returned by GetPerson(), we expect that:\nID field should be ≠ 0; Name field should always be “Bob”; Age field should be ≥ 40 and ≤ 45. Without operator anchoring:\nfunc TestPerson(t *testing.T) { assert := td.Assert(t) assert.Cmp(GetPerson(), // ← ① td.Struct(Person{Name: \"Bob\"}, // ← ② td.StructFields{ // ← ③ \"ID\": td.NotZero(), // ← ④ \"Age\": td.Between(uint8(40), uint8(45)), // ← ⑤ })) } Try it in playground 🔗\nGetPerson() returns a Person; as some fields of the returned Person are not exactly known in advance, we use the Struct operator as expected parameter. It allows to match exactly some fields, and use TestDeep operators on others. Here we know that Name field should always be “Bob”; StructFields is a map allowing to use TestDeep operators for any field; ID field should be ≠ 0. See NotZero operator for details; Age field should be ≥ 40 and ≤ 45. See Between operator for details. With operator anchoring, the use of Struct operator is no longer needed:\nfunc TestPerson(t *testing.T) { assert := td.Assert(t) assert.Cmp(GetPerson(), // ← ① Person{ // ← ② Name: \"Bob\", // ← ③ ID: assert.A(td.NotZero(), int64(0)).(int64), // ← ④ Age: assert.A(td.Between(uint8(40), uint8(45))).(uint8), // ← ⑤ }) // Or using generics from go1.18 assert.Cmp(GetPerson(), // ← ① Person{ // ← ② Name: \"Bob\", // ← ③ ID: td.A[int64](assert, td.NotZero()), // ← ④ Age: td.A[uint8](assert, td.Between(uint8(40), uint8(45))), // ← ⑤ }) } Try it in playground 🔗\nGetPerson() still returns a Person; expected parameter is directly a Person. No operator needed here; Name field should always be “Bob”, no change here; ID field should be ≠ 0: anchor the NotZero operator: using the A method. Break this line down: assert.A( // ← ① td.NotZero(), // ← ② int64(0), // ← ③ ).(int64) // ← ④ the A method is the key of the anchoring system. It saves the operator in assert instance, so it can be retrieved during the comparison of the next Cmp call on assert, the operator we want to anchor, this optional parameter is needed to tell A that the returned value must be a int64. Sometimes, this type can be deduced from the operator, but as NotZero can handle any kind of number, it is not the case here. So we have to pass it, as A method returns an any, we need to assert the int64 type to bypass the golang static typing system, using the A generic function. Break this line down: td.A[ // ← ① int64, // ← ② ]( assert, // ← ③ td.NotZero(), // ← ④ ) the A function is the key of the anchoring system. It saves the operator in assert instance, so it can be retrieved during the comparison of the next Cmp call on assert, the type A function will return, instance in which the operator is anchored, the operator we want to anchor, Age field should be ≥ 40 and ≤ 45: anchor the Between operator: using the A method. Break this line down: assert.A( // ← ① td.Between(uint8(40), uint8(45)), // ← ② ).(uint8) // ← ③ the A method saves the operator in assert, so it can be retrieved during the comparison of the next Cmp call on assert, the operator we want to anchor. As Between knows the type of its operands (here uint8), there is no need to tell A the returned type must be uint8. It can be deduced from Between, as A method returns an any, we need to assert the uint8 type to bypass the golang static typing system. using the A generic function. Break this line down: td.A[ // ← ① uint8, // ← ② ]( assert, // ← ③ td.Between(uint8(40), uint8(45)), // ← ④ ) the A function saves the operator in assert, so it can be retrieved during the comparison of the next Cmp call on assert, the type A function will return, instance in which the operator is anchored, the operator we want to anchor, Note the A method is a shortcut of Anchor method, as well as A function is a shortcut of Anchor function.\nSome rules have to be kept in mind:\nnever cast a value returned by A or Anchor methods: assert := td.Assert(t) // t is a *testing.T assert.A(td.NotZero(), uint(8)).(uint8) // OK uint16(assert.A(td.NotZero(), uint(8)).(uint8)) // Not OK! assert.A(td.NotZero(), uint16(0)).(uint16) // OK anchored operators disappear once the next Cmp call done. To share them between Cmp calls, use the SetAnchorsPersist method as in: assert := td.Assert(t) // t is a *testing.T age := assert.A(td.Between(uint8(40), uint8(45))).(uint8) assert.SetAnchorsPersist(true) // ← Don't reset anchors after next Cmp() call assert.Cmp(GetPerson(1), Person{ Name: \"Bob\", Age: age, }) assert.Cmp(GetPerson(2), Person{ Name: \"Bob\", Age: age, // ← OK }) Try it in playground 🔗 How to test io.Reader contents, like net/http.Response.Body for example? The Smuggle operator is done for that, here with the help of ReadAll.\nimport ( \"io\" \"net/http\" \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestResponseBody(t *testing.T) { // Expect this response sends \"Expected Response!\" var resp *http.Response = GetResponse() td.Cmp(t, resp.Body, td.Smuggle(io.ReadAll, []byte(\"Expected Response!\"))) } Try it in playground 🔗\nOK, but I prefer comparing strings instead of bytes No problem, ReadAll the body (still using Smuggle operator), then ask go-testdeep to compare it against a string using String operator:\nimport ( \"io\" \"net/http\" \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestResponseBody(t *testing.T) { // Expect this response sends \"Expected Response!\" var resp *http.Response = GetResponse() td.Cmp(t, resp.Body, td.Smuggle(io.ReadAll, td.String(\"Expected Response!\"))) } Try it in playground 🔗\nOK, but my response is in fact a JSON marshaled struct of my own No problem, JSON decode while reading the body:\nimport ( \"encoding/json\" \"io\" \"net/http\" \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestResponseBody(t *testing.T) { // Expect this response sends `{\"ID\":42,\"Name\":\"Bob\",\"Age\":28}` var resp *http.Response = GetResponse() type Person struct { ID uint64 Name string Age int } td.Cmp(t, resp.Body, td.Smuggle( // ← transform a io.Reader in *Person func(body io.Reader) (*Person, error) { var p Person return \u0026p, json.NewDecoder(body).Decode(\u0026p) }, \u0026Person{ // ← check Person content ID: 42, Name: \"Bob\", Age: 28, })) } Try it in playground 🔗\nSo I always need to manually unmarshal in a struct? It is up to you! Using JSON operator for example, you can test any JSON content. The first step is to read all the body (which is an io.Reader) into a json.RawMessage thanks to the Smuggle operator special cast feature, then ask JSON operator to do the comparison:\nimport ( \"encoding/json\" \"net/http\" \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestResponseBody(t *testing.T) { // Expect this response sends `{\"ID\":42,\"Name\":\"Bob\",\"Age\":28}` var resp *http.Response = GetResponse() td.Cmp(t, resp.Body, td.Smuggle(json.RawMessage{}, td.JSON(` { \"ID\": 42, \"Name\": \"Bob\", \"Age\": 28 }`))) } Try it in playground 🔗\nOK, but you are funny, this response sends a new created object, so I don’t know the ID in advance! No problem, use Struct operator to test that ID field is non-zero (as a bonus, add a CreatedAt field):\nimport ( \"encoding/json\" \"io\" \"net/http\" \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestResponseBody(t *testing.T) { // Expect this response sends: // `{\"ID\":42,\"Name\":\"Bob\",\"Age\":28,\"CreatedAt\":\"2019-01-02T11:22:33Z\"}` var resp *http.Response = GetResponse() type Person struct { ID uint64 Name string Age int CreatedAt time.Time } y2019, _ := time.Parse(time.RFC3339, \"2019-01-01T00:00:00Z\") // Using Struct operator td.Cmp(t, resp.Body, td.Smuggle( // ← transform a io.Reader in *Person func(body io.Reader) (*Person, error) { var s Person return \u0026s, json.NewDecoder(body).Decode(\u0026s) }, td.Struct(\u0026Person{ // ← check Person content Name: \"Bob\", Age: 28, }, td.StructFields{ \"ID\": td.NotZero(), // check ID ≠ 0 \"CreatedAt\": td.Gte(y2019), // check CreatedAt ≥ 2019/01/01 }))) // Using anchoring feature resp = GetResponse() assert := td.Assert(t) assert.Cmp(resp.Body, td.Smuggle( // ← transform a io.Reader in *Person func(body io.Reader) (*Person, error) { var s Person return \u0026s, json.NewDecoder(body).Decode(\u0026s) }, \u0026Person{ // ← check Person content Name: \"Bob\", Age: 28, ID: assert.A(td.NotZero(), uint64(0)).(uint64), // check ID ≠ 0 CreatedAt: assert.A(td.Gte(y2019)).(time.Time), // check CreatedAt ≥ 2019/01/01 })) // Using anchoring feature with generics resp = GetResponse() assert.Cmp(resp.Body, td.Smuggle( // ← transform a io.Reader in *Person func(body io.Reader) (*Person, error) { var s Person return \u0026s, json.NewDecoder(body).Decode(\u0026s) }, \u0026Person{ // ← check Person content Name: \"Bob\", Age: 28, ID: td.A[uint64](assert, td.NotZero()), // check ID ≠ 0 CreatedAt: td.A[time.Time](assert, td.Gte(y2019)), // check CreatedAt ≥ 2019/01/01 })) // Using JSON operator resp = GetResponse() td.Cmp(t, resp.Body, td.Smuggle(json.RawMessage{}, td.JSON(` { \"ID\": NotZero, \"Name\": \"Bob\", \"Age\": 28, \"CreatedAt\": Gte($1) }`, y2019))) } Try it in playground 🔗\nWhat about testing the response using my API? tdhttp helper is done for that!\nimport ( \"encoding/json\" \"net/http\" \"testing\" \"time\" \"github.com/maxatome/go-testdeep/helpers/tdhttp\" \"github.com/maxatome/go-testdeep/td\" ) type Person struct { ID uint64 Name string Age int CreatedAt time.Time } // MyApi defines our API. func MyAPI() *http.ServeMux { mux := http.NewServeMux() // GET /json mux.HandleFunc(\"/json\", func(w http.ResponseWriter, req *http.Request) { if req.Method != \"GET\" { http.NotFound(w, req) return } b, err := json.Marshal(Person{ ID: 42, Name: \"Bob\", Age: 28, CreatedAt: time.Now().UTC(), }) if err != nil { http.Error(w, \"Internal server error\", http.StatusInternalServerError) return } w.Header().Set(\"Content-Type\", \"application/json\") w.WriteHeader(http.StatusOK) w.Write(b) }) return mux } func TestMyApi(t *testing.T) { myAPI := MyAPI() y2008, _ := time.Parse(time.RFC3339, \"2008-01-01T00:00:00Z\") ta := tdhttp.NewTestAPI(t, myAPI) // ← ① ta.Get(\"/json\"). // ← ② Name(\"Testing GET /json\"). CmpStatus(http.StatusOK). // ← ③ CmpJSONBody(td.SStruct(\u0026Person{ // ← ④ Name: \"Bob\", Age: 28, }, td.StructFields{ \"ID\": td.NotZero(), // ← ⑤ \"CreatedAt\": td.Gte(y2008), // ← ⑥ })) // ta can be used to test another route… } Try it in playground 🔗\nthe API handler ready to be tested; the GET request; the expected HTTP status should be http.StatusOK; the expected body should match the SStruct operator; check the ID field is NotZero; check the CreatedAt field is greater or equal than y2008 variable (set just before tdhttp.NewTestAPI call). If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nArf, I use Gin Gonic, and so no net/http handlers It is exactly the same as for net/http handlers as *gin.Engine implements http.Handler interface! So keep using tdhttp helper:\nimport ( \"net/http\" \"testing\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/maxatome/go-testdeep/helpers/tdhttp\" \"github.com/maxatome/go-testdeep/td\" ) type Person struct { ID uint64 Name string Age int CreatedAt time.Time } // MyGinGonicApi defines our API. func MyGinGonicAPI() *gin.Engine { router := gin.Default() // or gin.New() or receive the router by param it doesn't matter router.GET(\"/json\", func(c *gin.Context) { c.JSON(http.StatusOK, Person{ ID: 42, Name: \"Bob\", Age: 28, CreatedAt: time.Now().UTC(), }) }) return router } func TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() y2008, _ := time.Parse(time.RFC3339, \"2008-01-01T00:00:00Z\") ta := tdhttp.NewTestAPI(t, myAPI) // ← ① ta.Get(\"/json\"). // ← ② Name(\"Testing GET /json\"). CmpStatus(http.StatusOK). // ← ③ CmpJSONBody(td.SStruct(\u0026Person{ // ← ④ Name: \"Bob\", Age: 28, }, td.StructFields{ \"ID\": td.NotZero(), // ← ⑤ \"CreatedAt\": td.Gte(y2008), // ← ⑥ })) // ta can be used to test another route… } Try it in playground 🔗\nthe API handler ready to be tested; the GET request; the expected HTTP status should be http.StatusOK; the expected body should match the SStruct operator; check the ID field is NotZero; check the CreatedAt field is greater or equal than y2008 variable (set just before tdhttp.NewTestAPI call). If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nFine, the request succeeds and the ID is not 0, but what is the ID real value? Stay with tdhttp helper!\nIn fact you can Catch the ID before comparing it to 0 (as well as CreatedAt in fact). Try:\nfunc TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() var id uint64 var createdAt time.Time y2008, _ := time.Parse(time.RFC3339, \"2008-01-01T00:00:00Z\") ta := tdhttp.NewTestAPI(t, myAPI) // ← ① ta.Get(\"/json\"). // ← ② Name(\"Testing GET /json\"). CmpStatus(http.StatusOK). // ← ③ CmpJSONBody(td.SStruct(\u0026Person{ // ← ④ Name: \"Bob\", Age: 28, }, td.StructFields{ \"ID\": td.Catch(\u0026id, td.NotZero()), // ← ⑤ \"CreatedAt\": td.Catch(\u0026createdAt, td.Gte(y2008)), // ← ⑥ })) if !ta.Failed() { t.Logf(\"The ID is %d and was created at %s\", id, createdAt) } // ta can be used to test another route… } Try it in playground 🔗\nthe API handler ready to be tested; the GET request; the expected HTTP status should be http.StatusOK; the expected body should match the SStruct operator; Catch the ID field: put it in id variable and check it is NotZero; Catch the CreatedAt field: put it in createdAt variable and check it is greater or equal than y2008 variable (set just before tdhttp.NewTestAPI call). If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nAnd what about other HTTP frameworks? tdhttp.NewTestAPI() function needs a http.Handler instance.\nLet’s see for each following framework how to get it:\nBeego home / sources\nIn single instance mode, web.BeeApp variable is a *web.HttpServer instance containing a Handlers field whose *ControllerRegister type implements http.Handler:\nta := tdhttp.NewTestAPI(t, web.BeeApp.Handlers) In multi instances mode, each instance is a *web.HttpServer so the same rule applies for each instance to test:\nta := tdhttp.NewTestAPI(t, instance.Handlers) echo home / sources\nStarting v3.0.0, echo.New() returns a *echo.Echo instance that implements http.Handler interface, so this instance can be fed as is to tdhttp.NewTestAPI:\ne := echo.New() // Add routes to e … ta := tdhttp.NewTestAPI(t, e) // e implements http.Handler Gin home / sources\ngin.Default() and gin.New() return both a *gin.Engine instance that implements http.Handler interface, so this instance can be fed as is to tdhttp.NewTestAPI:\nengine := gin.Default() // Add routes to engine … ta := tdhttp.NewTestAPI(t, engine) // engine implements http.Handler gorilla/mux home / sources\nmux.NewRouter() returns a *mux.Router instance that implements http.Handler interface, so this instance can be fed as is to tdhttp.NewTestAPI:\nr := mux.NewRouter() // Add routes to r … ta := tdhttp.NewTestAPI(t, r) // r implements http.Handler go-swagger home / sources\n2 cases here, the default generation and the Stratoscale template:\ndefault generation requires some tricks to retrieve the http.Handler instance: swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON) td.Require(t).CmpNoError(err, \"Swagger spec is loaded\") api := operations.NewXxxAPI(swaggerSpec) // Xxx is the name of your API server := restapi.NewServer(api) server.ConfigureAPI() hdl := server.GetHandler() // returns an http.Handler instance ta := tdhttp.NewTestAPI(t, hdl) with Stratoscale template, it is simpler: hdl, _, err := restapi.HandlerAPI(restapi.Config{ Tag1API: Tag1{}, Tag2API: Tag2{}, }) td.Require(t).CmpNoError(err, \"API correctly set up\") // hdl is an http.Handler instance ta := tdhttp.NewTestAPI(t, hdl) HttpRouter home / sources\nhttprouter.New() returns a *httprouter.Router instance that implements http.Handler interface, so this instance can be fed as is to tdhttp.NewTestAPI:\nr := httprouter.New() // Add routes to r … ta := tdhttp.NewTestAPI(t, r) // r implements http.Handler pat home / sources\npat.New() returns a *pat.Router instance that implements http.Handler interface, so this instance can be fed as is to tdhttp.NewTestAPI:\nrouter := pat.New() // Add routes to router … ta := tdhttp.NewTestAPI(t, router) // router implements http.Handler Another web framework not listed here? File an issue or open a PR to fix this!\nOK, but how to be sure the response content is well JSONified? Again, tdhttp helper is your friend!\nWith the help of JSON operator of course! See it below, used with Catch (note it can be used without), for a POST example:\ntype Person struct { ID uint64 `json:\"id\"` Name string `json:\"name\"` Age int `json:\"age\"` CreatedAt time.Time `json:\"created_at\"` } func TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() var id uint64 var createdAt time.Time ta := tdhttp.NewTestAPI(t, myAPI) // ← ① ta.PostJSON(\"/person\", Person{Name: \"Bob\", Age: 42}), // ← ② Name(\"Create a new Person\"). CmpStatus(http.StatusCreated). // ← ③ CmpJSONBody(td.JSON(` { \"id\": $id, \"name\": \"Bob\", \"age\": 42, \"created_at\": \"$createdAt\", }`, td.Tag(\"id\", td.Catch(\u0026id, td.NotZero())), // ← ④ td.Tag(\"createdAt\", td.All( // ← ⑤ td.HasSuffix(\"Z\"), // ← ⑥ td.Smuggle(func(s string) (time.Time, error) { // ← ⑦ return time.Parse(time.RFC3339Nano, s) }, td.Catch(\u0026createdAt, td.Gte(ta.SentAt()))), // ← ⑧ )), )) if !ta.Failed() { t.Logf(\"The new Person ID is %d and was created at %s\", id, createdAt) } // ta can be used to test another route… } the API handler ready to be tested; the POST request with automatic JSON marshalling; the expected HTTP status should be http.StatusCreated and the line just below, the body should match the JSON operator; for the $id placeholder, Catch its value: put it in id variable and check it is NotZero; for the $createdAt placeholder, use the All operator. It combines several operators like a AND; check that $createdAt date ends with “Z” using HasSuffix. As we expect a RFC3339 date, we require it in UTC time zone; convert $createdAt date into a time.Time using a custom function thanks to the Smuggle operator; then Catch the resulting value: put it in createdAt variable and check it is greater or equal than ta.SentAt() (the time just before the request is handled). If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nMy API uses XML not JSON! tdhttp helper provides the same functions and methods for XML it does for JSON.\nRTFM :)\nNote that the JSON operator have not its XML counterpart yet. But PRs are welcome!\nHow to assert for an UUIDv7? Combining Smuggle and Code, you can easily write a custom operator:\n// Uses uuid from github.com/gofrs/uuid/v5 func isUUIDv7() td.TestDeep { return td.Smuggle(uuid.FromString, td.Code(func(u uuid.UUID) error { if u.Version() != uuid.V7 { return fmt.Errorf(\"UUID v%x instead of v7\", u.Version()) } return nil })) } that you can then use, for example in a JSON match:\ntd.Cmp(t, jsonData, td.JSON(`{\"id\": $1}`, isUUIDv7())) Should I import github.com/maxatome/go-testdeep or github.com/maxatome/go-testdeep/td? Historically the main package of go-testdeep was testdeep as in:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep\" ) func TestMyFunc(t *testing.T) { testdeep.Cmp(t, GetPerson(), Person{Name: \"Bob\", Age: 42}) } As testdeep was boring to type, renaming it to td became a habit as in:\nimport ( \"testing\" td \"github.com/maxatome/go-testdeep\" ) func TestMyFunc(t *testing.T) { td.Cmp(t, GetPerson(), Person{Name: \"Bob\", Age: 42}) } Forcing the developer to systematically rename testdeep package to td in all its tests is not very friendly. That is why a decision was taken to create a new package github.com/maxatome/go-testdeep/td while keeping github.com/maxatome/go-testdeep working thanks to go type aliases.\nSo the previous examples (that are still working) can now be written as:\nimport ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(t *testing.T) { td.Cmp(t, GetPerson(), Person{Name: \"Bob\", Age: 42}) } There is no package renaming anymore. Switching to import github.com/maxatome/go-testdeep/td is advised for new code.\nWhat does the error undefined: testdeep.DefaultContextConfig mean? Since release v1.3.0, this variable moved to the new github.com/maxatome/go-testdeep/td package.\nIf you rename the testdeep package to td as in:\nimport td \"github.com/maxatome/go-testdeep\" … td.DefaultContextConfig = td.ContextConfig{…} then just change the import line to:\nimport \"github.com/maxatome/go-testdeep/td\" Otherwise, you have two choices:\neither add a new import line: import \"github.com/maxatome/go-testdeep/td\" then use td.DefaultContextConfig instead of testdeep.DefaultContextConfig, and continue to use testdeep package elsewhere. or replace the import line: import \"github.com/maxatome/go-testdeep\" by import \"github.com/maxatome/go-testdeep/td\" then rename all occurrences of testdeep package to td. go-testdeep dumps only 10 errors, how to have more (or less)? Using the environment variable TESTDEEP_MAX_ERRORS.\nTESTDEEP_MAX_ERRORS contains the maximum number of errors to report before stopping during one comparison (one Cmp execution for example). It defaults to 10.\nExample:\nTESTDEEP_MAX_ERRORS=30 go test Setting it to -1 means no limit:\nTESTDEEP_MAX_ERRORS=-1 go test How do I change these crappy colors? Using some environment variables:\nTESTDEEP_COLOR enable (on) or disable (off) the color output. It defaults to on; TESTDEEP_COLOR_TEST_NAME color of the test name. See below for color format, it defaults to yellow; TESTDEEP_COLOR_TITLE color of the test failure title. See below for color format, it defaults to cyan; TESTDEEP_COLOR_OK color of the test expected value. See below for color format, it defaults to green; TESTDEEP_COLOR_BAD color of the test got value. See below for color format, it defaults to red; Color format A color in TESTDEEP_COLOR_* environment variables has the following format:\nforeground_color # set foreground color, background one untouched foreground_color:background_color # set foreground AND background color :background_color # set background color, foreground one untouched foreground_color and background_color can be:\nblack red green yellow blue magenta cyan white gray For example:\nTESTDEEP_COLOR_OK=black:green \\ TESTDEEP_COLOR_BAD=white:red \\ TESTDEEP_COLOR_TITLE=yellow \\ go test play.golang.org does not handle colors, error output is nasty Just add this single line in playground:\nimport _ \"github.com/maxatome/go-testdeep/helpers/nocolor\" (since go-testdeep v1.10.0) or:\nfunc init() { os.Setenv(\"TESTDEEP_COLOR\", \"off\") } until playground supports ANSI color escape sequences.\nThe X testing framework allows to test/do Y while go-testdeep not The Code and Smuggle operators should allow to cover all cases not handled by other operators.\nIf you think this missing feature deserves a specific operator, because it is frequently or widely used, file an issue and let’s discuss about it.\nWe plan to add a new github.com/maxatome/go-testdeep/helpers/tdcombo helper package, bringing together all what we can call combo-operators. Combo-operators are operators using any number of already existing operators.\nAs an example of such combo-operators, the following one. It allows to check that a string contains a RFC3339 formatted time, in UTC time zone (“Z” suffix) and then to compare it as a time.Time against expectedValue (which can be another operator or, of course, a time.Time value).\nfunc RFC3339ZToTime(expectedValue any) td.TestDeep { return td.All( td.HasSuffix(\"Z\"), td.Smuggle(func(s string) (time.Time, error) { return time.Parse(time.RFC3339Nano, s) }, expectedValue), ) } It could be used as:\nbefore := time.Now() record := NewRecord() td.Cmp(t, record, td.SuperJSONOf(`{\"created_at\": $1}`, tdcombo.RFC3339ZToTime(td.Between(before, time.Now()), )), \"The JSONified record.created_at is UTC-RFC3339\", ) How to add a new operator? You want to add a new FooBar operator.\ncheck that another operator does not exist with the same meaning; add the operator definition in td_foo_bar.go file and fully document its usage: add a // summary(FooBar): small description line, before operator comment, add a // input(FooBar): … line, just after summary(FooBar) line. This one lists all inputs accepted by the operator; add operator tests in td_foo_bar_test.go file; in example_test.go file, add examples function(s) ExampleFooBar* in alphabetical order; should this operator be available in JSON, SubJSONOf and SuperJSONOf operators? If no, add FooBar to the forbiddenOpsInJSON map in td/td_json.go with a possible alternative text to help the user, If yes, does FooBar needs specific handling as N or Between does for example? automatically generate CmpFooBar \u0026 T.FooBar (+ examples) code: ./tools/gen_funcs.pl do not forget to run tests: go test ./... run golangci-lint as in .github/workflows/ci.yml; Each time you change example_test.go, re-run ./tools/gen_funcs.pl to update corresponding CmpFooBar \u0026 T.FooBar examples.\nTest coverage must be 100%.",
    "description": "How to mix strict requirements and simple assertions? import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestAssertionsAndRequirements(t *testing.T) { assert, require := td.AssertRequire(t) got := SomeFunction() require.Cmp(got, expected) // if it fails: report error + abort assert.Cmp(got, expected) // if it fails: report error + continue } Why nil is handled so specifically? var pn *int td.Cmp(t, pn, nil) fails with the error And, yes, it is normal. (TL;DR use CmpNil instead, safer, or use CmpLax, but be careful of edge cases.)",
    "tags": [],
    "title": "FAQ",
    "uri": "/faq/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "Of course we can test struct fields one by one, but with go-testdeep and the [td package], the whole struct can be compared with one Cmp call.\nWe can choose to ignore the non-guessable fields set by CreateRecord():\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026Record{ Name: \"Bob\", Age: 23, }), \"Newly created record\") } } Test in in playground: https://go.dev/play/p/X9mYj9UxgSf\nThe Struct operator, used here, ignores zero fields in its model parameter.\nBut it is better to check all fields:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }), \"Newly created record\") } } Test it in playground: https://play.golang.org/p/PGyi0d3ZXMa\nSee the use of the Struct operator. It is needed here to overcome the go static typing system and so use other go-testdeep operators for some fields, here NotZero for Id and Between for CreatedAt.\nNot only structs can be compared. A lot of operators can be found to cover most (all?) needed tests. See the operators list.\nSay CreateRecord() does not set correctly CreatedAt field, then:\ngo test -run=TestCreateRecord outputs for last td.Cmp call:\nIf CreateRecord() had not set correctly Id field, output would have been:\nIf CreateRecord() had set Name field to “Alice” value instead of expected “Bob”, output would have been:",
    "description": "Of course we can test struct fields one by one, but with go-testdeep and the [td package], the whole struct can be compared with one Cmp call.\nWe can choose to ignore the non-guessable fields set by CreateRecord():\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026Record{ Name: \"Bob\", Age: 23, }), \"Newly created record\") } } Test in in playground: https://go.dev/play/p/X9mYj9UxgSf\nThe Struct operator, used here, ignores zero fields in its model parameter.",
    "tags": [],
    "title": "Advanced go-testdeep technique",
    "uri": "/example/advanced-testdeep/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "The Cmp function is the keystone of this package, but to make the writing of tests even easier, the family of Cmp* functions are provided and act as shortcuts. Using CmpStruct function, the previous example can be written as:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.CmpStruct(t, record, \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }, \"Newly created record\") } } Test it in playground: https://play.golang.org/p/d2FxGASUa_B",
    "description": "The Cmp function is the keystone of this package, but to make the writing of tests even easier, the family of Cmp* functions are provided and act as shortcuts. Using CmpStruct function, the previous example can be written as:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if td.CmpNoError(t, err) { td.CmpStruct(t, record, \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }, \"Newly created record\") } } Test it in playground: https://play.golang.org/p/d2FxGASUa_B",
    "tags": [],
    "title": "go-testdeep Cmp shortcuts",
    "uri": "/example/td-cmp-shortcuts/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "testing.T can also be encapsulated in td.T type, simplifying again the test:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if t.CmpNoError(err) { t := t.RootName(\"RECORD\") // Use RECORD instead of DATA in failure reports // Using Struct shortcut method t.Struct(record, \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }, \"Newly created record\") // Or using Cmp method, it's a matter of taste t.Cmp(record, td.Struct( \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }), \"Newly created record\") } } Test it in playground: https://play.golang.org/p/sH4PRrVjqFM\nNote the use of RootName method, it allows to name what we are going to test, instead of the default “DATA”.\nIf CreateRecord() had set Name field to “Alice” value instead of expected “Bob”, output would have been (note “RECORD” replaced default “DATA”):",
    "description": "testing.T can also be encapsulated in td.T type, simplifying again the test:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if t.CmpNoError(err) { t := t.RootName(\"RECORD\") // Use RECORD instead of DATA in failure reports // Using Struct shortcut method t.Struct(record, \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }, \"Newly created record\") // Or using Cmp method, it's a matter of taste t.Cmp(record, td.Struct( \u0026Record{ Name: \"Bob\", Age: 23, }, td.StructFields{ \"Id\": td.NotZero(), \"CreatedAt\": td.Between(before, time.Now()), }), \"Newly created record\") } } Test it in playground: https://play.golang.org/p/sH4PRrVjqFM",
    "tags": [],
    "title": "td.T type",
    "uri": "/example/td-t/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "Operators can also directly be anchored in litterals, still using the td.T type, avoiding the use of the Struct operator:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if t.CmpNoError(err) { // Use RECORD instead of DATA in failure reports t.RootName(\"RECORD\"). Cmp(record, \u0026Record{ Name: \"Bob\", Age: 23, Id: t.Anchor(td.NotZero(), uint64(0)).(uint64), CreatedAt: t.Anchor(td.Between(before, time.Now())).(time.Time), }, \"Newly created record\") } } Test it in playground: https://play.golang.org/p/OzoW5CSNUP5\nSee the Anchor method documentation for details. Note that A method is also a synonym for Anchor.\nId: t.A(td.NotZero(), uint64(0)).(uint64), CreatedAt: t.A(td.Between(before, time.Now())).(time.Time), Thanks to generics, this can also be written as:\nId: td.Anchor[uint64](t, td.NotZero()), CreatedAt: td.Anchor[time.Time](t, td.Between(before, time.Now())), or\nId: td.A[uint64](t, td.NotZero()), CreatedAt: td.A[time.Time](t, td.Between(before, time.Now())),",
    "description": "Operators can also directly be anchored in litterals, still using the td.T type, avoiding the use of the Struct operator:\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if t.CmpNoError(err) { // Use RECORD instead of DATA in failure reports t.RootName(\"RECORD\"). Cmp(record, \u0026Record{ Name: \"Bob\", Age: 23, Id: t.Anchor(td.NotZero(), uint64(0)).(uint64), CreatedAt: t.Anchor(td.Between(before, time.Now())).(time.Time), }, \"Newly created record\") } } Test it in playground: https://play.golang.org/p/OzoW5CSNUP5\nSee the Anchor method documentation for details. Note that A method is also a synonym for Anchor.",
    "tags": [],
    "title": "Using anchoring",
    "uri": "/example/anchoring/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Tutorial",
    "content": "JSON is a first class citizen in go-testdeep world thanks to its specific operators: JSON, SubJSONOf, SuperJSONOf and JSONPointer.\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if t.CmpNoError(err) { t = t.RootName(\"RECORD\") // Use RECORD instead of DATA in failure reports t.Cmp(record, td.JSON(` { \"Name\": \"Bob\", \"Age\": 23, \"Id\": NotZero(), // comments and operators allowed! \"CreatedAt\": $1 }`, td.Between(before, time.Now()), ), \"Newly created record\") } } Test it in playground: https://play.golang.org/p/pUC-RMPWyhu",
    "description": "JSON is a first class citizen in go-testdeep world thanks to its specific operators: JSON, SubJSONOf, SuperJSONOf and JSONPointer.\nimport ( \"testing\" \"time\" \"github.com/maxatome/go-testdeep/td\" ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord(\"Bob\", 23) if t.CmpNoError(err) { t = t.RootName(\"RECORD\") // Use RECORD instead of DATA in failure reports t.Cmp(record, td.JSON(` { \"Name\": \"Bob\", \"Age\": 23, \"Id\": NotZero(), // comments and operators allowed! \"CreatedAt\": $1 }`, td.Between(before, time.Now()), ), \"Newly created record\") } } Test it in playground: https://play.golang.org/p/pUC-RMPWyhu",
    "tags": [],
    "title": "Using JSON",
    "uri": "/example/using-json/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "go-testdeep",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "breadcrumb": "go-testdeep \u003e Functions",
    "content": "Constructing *td.T import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), 12) } func NewT(t testing.TB, config ...ContextConfig) *T func Assert(t testing.TB, config ...ContextConfig) *T func Require(t testing.TB, config ...ContextConfig) *T func AssertRequire(t testing.TB, config ...ContextConfig) (assert, require *T) Configuring *td.T func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual().RootName(\"RECORD\") ... } func (t *T) BeLax(enable ...bool) *T func (t *T) FailureIsFatal(enable ...bool) *T func (t *T) IgnoreUnexported(types ...any) *T func (t *T) RootName(rootName string) *T func (t *T) UseEqual(types ...any) *T Main methods of *td.T import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual() // Compares MyFunc() result against a fixed value t.Cmp(MyFunc(), 128, \"MyFunc() result is 128\") // Compares MyFunc() result using the Between Testdeep operator t.Cmp(MyFunc(), td.Between(100, 199), \"MyFunc() result is between 100 and 199\") } func (t *T) Cmp(got, expected any, args ...any) bool func (t *T) CmpError(got error, args ...any) bool func (t *T) CmpLax(got, expected any, args ...any) bool (in fact the shortcut of Lax operator) func (t *T) CmpNoError(got error, args ...any) bool func (t *T) CmpNotPanic(fn func(), args ...any) bool func (t *T) CmpPanic(fn func(), expected any, args ...any) bool func (t *T) False(got any, args ...any) bool func (t *T) Not(got, notExpected any, args ...any) bool (in fact the shortcut of Not operator) func (t *T) Run(name string, f func(t *T)) bool func (t *T) RunAssertRequire(name string, f func(assert, require *T)) bool func (t *T) True(got any, args ...any) bool CmpDeeply() method is now replaced by Cmp(), but it is still available for backward compatibility purpose.\nAnchoring methods of *td.T func (t *T) A(operator TestDeep, model ...any) any func (t *T) Anchor(operator TestDeep, model ...any) any func (t *T) AnchorsPersistTemporarily() func() func (t *T) DoAnchorsPersist() bool func (t *T) ResetAnchors() func (t *T) SetAnchorsPersist(persist bool) Thanks to generics, one can also use:\nfunc A[X any](t *T, operator TestDeep) X func Anchor[X any](t *T, operator TestDeep) X Shortcut methods of *td.T import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual() t.Between(MyFunc(), 100, 199, td.BoundsInIn, \"MyFunc() result is between 100 and 199\") } For each of these methods, it is always a shortcut on T.Cmp() and the correponding Testdeep operator:\nT.HasPrefix(got, expected, …) ⇒ T.Cmp(t, got, HasPrefix(expected), …) ^-------^ ^-------^ +-------------------------------------------+ Excluding Lax operator for which the shortcut method stays CmpLax.\nEach shortcut method is described in the corresponding operator page. See operators list.\nComparison hooks func TestCmpHook(tt *testing.T) { t := td.NewT(tt) // Test time.Time via its Equal() method instead of default // field/field (note it bypasses the UseEqual flag) t = t.WithCmpHooks((time.Time).Equal) date, _ := time.Parse(time.RFC3339, \"2020-09-08T22:13:54+02:00\") t.Cmp(date, date.UTC()) // succeeds // Each encountered string is converted to int t = t.WithSmuggleHooks(strconv.Atoi) t.Cmp(\"123\", 123) // succeeds } func (t *T) WithCmpHooks(fns ...any) *T func (t *T) WithSmuggleHooks(fns ...any) *T",
    "description": "Constructing *td.T import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), 12) } func NewT(t testing.TB, config ...ContextConfig) *T func Assert(t testing.TB, config ...ContextConfig) *T func Require(t testing.TB, config ...ContextConfig) *T func AssertRequire(t testing.TB, config ...ContextConfig) (assert, require *T) Configuring *td.T func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual().RootName(\"RECORD\") ... } func (t *T) BeLax(enable ...bool) *T func (t *T) FailureIsFatal(enable ...bool) *T func (t *T) IgnoreUnexported(types ...any) *T func (t *T) RootName(rootName string) *T func (t *T) UseEqual(types ...any) *T Main methods of *td.T import ( \"testing\" \"github.com/maxatome/go-testdeep/td\" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual() // Compares MyFunc() result against a fixed value t.Cmp(MyFunc(), 128, \"MyFunc() result is 128\") // Compares MyFunc() result using the Between Testdeep operator t.Cmp(MyFunc(), td.Between(100, 199), \"MyFunc() result is between 100 and 199\") } func (t *T) Cmp(got, expected any, args ...any) bool func (t *T) CmpError(got error, args ...any) bool func (t *T) CmpLax(got, expected any, args ...any) bool (in fact the shortcut of Lax operator) func (t *T) CmpNoError(got error, args ...any) bool func (t *T) CmpNotPanic(fn func(), args ...any) bool func (t *T) CmpPanic(fn func(), expected any, args ...any) bool func (t *T) False(got any, args ...any) bool func (t *T) Not(got, notExpected any, args ...any) bool (in fact the shortcut of Not operator) func (t *T) Run(name string, f func(t *T)) bool func (t *T) RunAssertRequire(name string, f func(assert, require *T)) bool func (t *T) True(got any, args ...any) bool CmpDeeply() method is now replaced by Cmp(), but it is still available for backward compatibility purpose.",
    "tags": [],
    "title": "td.T",
    "uri": "/functions/td-t/index.html"
  }
]
