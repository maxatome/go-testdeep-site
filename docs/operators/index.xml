<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Operators :: go-testdeep</title><link>https://go-testdeep.zetta.rocks/operators/index.html</link><description>All operators All all expected values have to match Any at least one expected value have to match Array compares the contents of an array or a pointer on an array ArrayEach compares each array or slice item Bag compares the contents of an array or a slice without taking care of the order of items Between checks that a number, string or time.Time is between two bounds Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Code checks using a custom function Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key Delay delays the operator construction till first use Empty checks that an array, a channel, a map, a slice or a string is empty ErrorIs checks the data is an error and matches a wrapped error First find the first matching item of a slice or an array then compare its content Grep reduces a slice or an array before comparing its content Gt checks that a number, string or time.Time is greater than a value Gte checks that a number, string or time.Time is greater or equal than a value HasPrefix checks the prefix of a string, []byte, error or fmt.Stringer interfaces HasSuffix checks the suffix of a string, []byte, error or fmt.Stringer interfaces Ignore allows to ignore a comparison Isa checks the data type or whether data implements an interface or not JSON compares against JSON representation JSONPointer compares against JSON representation using a JSON pointer Keys checks keys of a map Last find the last matching item of a slice or an array then compare its content Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length List compares the contents of an array or a slice with taking care of the order of items Lt checks that a number, string or time.Time is lesser than a value Lte checks that a number, string or time.Time is lesser or equal than a value Map compares the contents of a map MapEach compares each map entry N compares a number with a tolerance value NaN checks a floating number is math.NaN Nil compares to nil None no values have to match Not value must not match NotAny compares the contents of an array or a slice, no values have to match NotEmpty checks that an array, a channel, a map, a slice or a string is not empty NotNaN checks a floating number is not math.NaN NotNil checks that data is not nil NotZero checks that data is not zero regarding its type PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Re allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups ReAll allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Recv checks the value read from a channel Set compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items Shallow compares pointers only, not their contents Slice compares the contents of a slice or a pointer on a slice Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Sort sorts a slice or an array before comparing its content Sorted checks a slice or an array is sorted SStruct strictly compares the contents of a struct or a pointer on a struct String checks a string, []byte, error or fmt.Stringer interfaces string contents Struct compares the contents of a struct or a pointer on a struct SubBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some exclusions SubJSONOf compares struct or map against JSON representation but with potentially some exclusions SubMapOf compares the contents of a map but with potentially some exclusions SubSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some exclusions SuperBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some extra items SuperJSONOf compares struct or map against JSON representation but with potentially extra entries SuperMapOf compares the contents of a map but with potentially some extra entries SuperSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some extra items SuperSliceOf compares the contents of a slice, a pointer on a slice, an array or a pointer on an array but with potentially some extra entries Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders TruncTime compares time.Time (or assignable) values after truncating them Values checks values of a map Zero checks data against its zero’ed conterpart Smuggler operators A smuggler operator is an operator able to transform the value (by changing its value or even its type) before comparing it.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 10 Sep 2025 22:50:18 +0200</lastBuildDate><atom:link href="https://go-testdeep.zetta.rocks/operators/index.xml" rel="self" type="application/rss+xml"/><item><title>Operators matrices</title><link>https://go-testdeep.zetta.rocks/operators/matrix/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/matrix/index.html</guid><description>Operator → go type matrix Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator All ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ All Any ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Any Array ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ptr on array ✓ ✗ ✗ Array ArrayEach ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ ArrayEach Bag ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Bag Between ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Between Cap ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ Cap Catch ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Catch Code ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Code Contains ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Contains Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator ContainsKey ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ ContainsKey Delay ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Delay Empty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ Empty ErrorIs ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ error ✗ ✗ ErrorIs First ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ First Grep ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Grep Gt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gt Gte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gte HasPrefix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasPrefix HasSuffix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasSuffix Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Ignore ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Ignore Isa ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Isa JSON ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSON JSONPointer ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSONPointer Keys ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Keys Last ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Last Lax ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Lax Len ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ ✓ ✗ Len List ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ List Lt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lt Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Lte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lte Map ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ Map MapEach ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ MapEach N ✗ ✗ ✗ ✓ ✓ todo ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ N NaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NaN Nil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Nil None ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ None Not ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Not NotAny ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ NotAny NotEmpty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ NotEmpty Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator NotNaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NotNaN NotNil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ NotNil NotZero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ NotZero PPtr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ PPtr Ptr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ Ptr Re ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Re ReAll ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ ReAll Recv ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ptr on chan ✓ ✓ ✗ Recv Set ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Set Shallow ✓ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Shallow Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator Slice ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ptr on slice ✓ ✗ ✗ Slice Smuggle ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Smuggle Sort ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Sort Sorted ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Sorted SStruct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ SStruct String ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ String Struct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ Struct SubBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubBagOf SubJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SubJSONOf SubMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SubMapOf Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator SubSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubSetOf SuperBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperBagOf SuperJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SuperJSONOf SuperMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SuperMapOf SuperSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSetOf SuperSliceOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSliceOf Tag ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Tag TruncTime ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ time.Time todo ✓ ✗ ✗ TruncTime Values ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Values Zero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Zero Legend:</description></item><item><title>All</title><link>https://go-testdeep.zetta.rocks/operators/all/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/all/index.html</guid><description>func All(expectedValues ...any) TestDeep All operator compares data against several expected values. During a match, all of them have to match to succeed. Consider it as a “AND” logical operator.
td.Cmp(t, "foobar", td.All( td.Len(6), td.HasPrefix("fo"), td.HasSuffix("ar"), )) // succeeds Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:
stringOps := td.Flatten([]td.TestDeep{td.HasPrefix("fo"), td.HasSuffix("ar")}) td.Cmp(t, "foobar", td.All( td.Len(6), stringOps, )) // succeeds One can do the same with All operator itself:</description></item><item><title>Any</title><link>https://go-testdeep.zetta.rocks/operators/any/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/any/index.html</guid><description>func Any(expectedValues ...any) TestDeep Any operator compares data against several expected values. During a match, at least one of them has to match to succeed. Consider it as a “OR” logical operator.
td.Cmp(t, "foo", td.Any("bar", "foo", "zip")) // succeeds td.Cmp(t, "foo", td.Any( td.Len(4), td.HasPrefix("f"), td.HasSuffix("z"), )) // succeeds coz "f" prefix Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:
stringOps := td.Flatten([]td.TestDeep{td.HasPrefix("f"), td.HasSuffix("z")}) td.Cmp(t, "foobar", td.All( td.Len(4), stringOps, )) // succeeds coz "f" prefix TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.</description></item><item><title>Array</title><link>https://go-testdeep.zetta.rocks/operators/array/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/array/index.html</guid><description>func Array(model any, expectedEntries ArrayEntries) TestDeep Array operator compares the contents of an array or a pointer on an array against the values of model and the values of expectedEntries. Entries with zero values of model are ignored if the same entry is present in expectedEntries, otherwise they are taken into account. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, all entries are checked. To check only some entries of an array, see SuperSliceOf operator.</description></item><item><title>ArrayEach</title><link>https://go-testdeep.zetta.rocks/operators/arrayeach/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/arrayeach/index.html</guid><description>func ArrayEach(expectedValue any) TestDeep ArrayEach operator has to be applied on arrays or slices or on pointers on array/slice. It compares each item of data array/slice against expectedValue. During a match, all items have to match to succeed.
got := [3]string{"foo", "bar", "biz"} td.Cmp(t, got, td.ArrayEach(td.Len(3))) // succeeds td.Cmp(t, got, td.ArrayEach(td.HasPrefix("b"))) // fails coz "foo" Works on slices as well:
got := []Person{ {Name: "Bob", Age: 42}, {Name: "Alice", Age: 24}, } td.Cmp(t, got, td.ArrayEach( td.Struct(Person{}, td.StructFields{ Age: td.Between(20, 45), })), ) // succeeds, each Person has Age field between 20 and 45 See also ArrayEach godoc.</description></item><item><title>Bag</title><link>https://go-testdeep.zetta.rocks/operators/bag/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/bag/index.html</guid><description>func Bag(expectedItems ...any) TestDeep Bag operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.
During a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.
td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(2, 1, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2)) // fails, one 1 is missing td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.Bag( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>Between</title><link>https://go-testdeep.zetta.rocks/operators/between/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/between/index.html</guid><description>func Between(from, to any, bounds ...BoundsKind) TestDeep Between operator checks that data is between from and to. from and to can be any numeric, string, time.Time (or assignable) value or implement at least one of the two following methods:
func (a T) Less(b T) bool // returns true if a &lt; b func (a T) Compare(b T) int // returns -1 if a &lt; b, 1 if a > b, 0 if a == b from and to must be the same type as the compared value, except if BeLax config flag is true. time.Duration type is accepted as to when from is time.Time or convertible. bounds allows to specify whether bounds are included or not:</description></item><item><title>Cap</title><link>https://go-testdeep.zetta.rocks/operators/cap/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/cap/index.html</guid><description>func Cap(expectedCap any) TestDeep Cap is a smuggler operator. It takes data, applies cap() function on it and compares its result to expectedCap. Of course, the compared value must be an array, a channel or a slice.
expectedCap can be an int value:
td.Cmp(t, gotSlice, td.Cap(12)) as well as an other operator:
td.Cmp(t, gotSlice, td.Cap(td.Between(3, 4))) See also Len.
See also Cap godoc.
Examples Base example t := &amp;testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(12), "checks %v capacity is 12", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(0), "checks %v capacity is 0", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Cap(0), "checks %v capacity is 0", got) fmt.Println(ok) // Output: // true // false // true Operator example t := &amp;testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(td.Between(10, 12)), "checks %v capacity is in [10 .. 12]", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(td.Gt(10)), "checks %v capacity is in [10 .. 12]", got) fmt.Println(ok) // Output: // true // true</description></item><item><title>Catch</title><link>https://go-testdeep.zetta.rocks/operators/catch/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/catch/index.html</guid><description>func Catch(target, expectedValue any) TestDeep Catch is a smuggler operator. It allows to copy data in target on the fly before comparing it as usual against expectedValue.
target must be a non-nil pointer and data should be assignable to its pointed type. If BeLax config flag is true or called under Lax (and so JSON) operator, data should be convertible to its pointer type.
var id int64 if td.Cmp(t, CreateRecord("test"), td.JSON(`{"id": $1, "name": "test"}`, td.Catch(&amp;id, td.NotZero()))) { t.Logf("Created record ID is %d", id) } It is really useful when used with JSON operator and/or tdhttp helper.</description></item><item><title>Code</title><link>https://go-testdeep.zetta.rocks/operators/code/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/code/index.html</guid><description>func Code(fn any) TestDeep Code operator allows to check data using a custom function. So fn is a function that must take one parameter whose type must be the same as the type of the compared value.
fn can return a single bool kind value, telling that yes or no the custom test is successful:
td.Cmp(t, gotTime, td.Code(func(date time.Time) bool { return date.Year() == 2018 })) or two values (bool, string) kinds. The bool value has the same meaning as above, and the string value is used to describe the test when it fails:</description></item><item><title>Contains</title><link>https://go-testdeep.zetta.rocks/operators/contains/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/contains/index.html</guid><description>func Contains(expectedValue any) TestDeep Contains is a smuggler operator to check if something is contained in another thing. Contains has to be applied on arrays, slices, maps or strings. It tries to be as smarter as possible.
If expectedValue is a TestDeep operator, each item of data array/slice/map/string (rune for strings) is compared to it. The use of a TestDeep operator as expectedValue works only in this way: item per item.
If data is a slice, and expectedValue has the same type, then expectedValue is searched as a sub-slice, otherwise expectedValue is compared to each slice value.</description></item><item><title>ContainsKey</title><link>https://go-testdeep.zetta.rocks/operators/containskey/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/containskey/index.html</guid><description>func ContainsKey(expectedValue any) TestDeep ContainsKey is a smuggler operator and works on maps only. It compares each key of map against expectedValue.
hash := map[string]int{"foo": 12, "bar": 34, "zip": 28} td.Cmp(t, hash, td.ContainsKey("foo")) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix("z"))) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix("x"))) // fails hnum := map[int]string{1: "foo", 42: "bar"} td.Cmp(t, hash, td.ContainsKey(42)) // succeeds td.Cmp(t, hash, td.ContainsKey(td.Between(40, 45))) // succeeds When ContainsKey(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the map key type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):</description></item><item><title>Delay</title><link>https://go-testdeep.zetta.rocks/operators/delay/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/delay/index.html</guid><description>func Delay(delayed func() TestDeep) TestDeep Delay operator allows to delay the construction of an operator to the time it is used for the first time. Most of the time, it is used with helpers. See the example for a very simple use case.
See also Delay godoc.
Example Base example t := &amp;testing.T{} cmpNow := func(expected td.TestDeep) bool { time.Sleep(time.Microsecond) // imagine a DB insert returning a CreatedAt return td.Cmp(t, time.Now(), expected) } before := time.Now() ok := cmpNow(td.Between(before, time.Now())) fmt.Println("Between called before compare:", ok) ok = cmpNow(td.Delay(func() td.TestDeep { return td.Between(before, time.Now()) })) fmt.Println("Between delayed until compare:", ok) // Output: // Between called before compare: false // Between delayed until compare: true</description></item><item><title>Empty</title><link>https://go-testdeep.zetta.rocks/operators/empty/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/empty/index.html</guid><description>func Empty() TestDeep Empty operator checks that an array, a channel, a map, a slice or a string is empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.
Note that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.
td.Cmp(t, "", td.Empty()) // succeeds td.Cmp(t, map[string]bool{}, td.Empty()) // succeeds td.Cmp(t, []string{"foo"}, td.Empty()) // fails See also Empty godoc.</description></item><item><title>ErrorIs</title><link>https://go-testdeep.zetta.rocks/operators/erroris/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/erroris/index.html</guid><description>func ErrorIs(expectedError any) TestDeep ErrorIs is a smuggler operator. It reports whether any error in an error’s chain matches expectedError.
_, err := os.Open("/unknown/file") td.Cmp(t, err, os.ErrNotExist) // fails td.Cmp(t, err, td.ErrorIs(os.ErrNotExist)) // succeeds err1 := fmt.Errorf("failure1") err2 := fmt.Errorf("failure2: %w", err1) err3 := fmt.Errorf("failure3: %w", err2) err := fmt.Errorf("failure4: %w", err3) td.Cmp(t, err, td.ErrorIs(err)) // succeeds td.Cmp(t, err, td.ErrorIs(err1)) // succeeds td.Cmp(t, err1, td.ErrorIs(err)) // fails var cerr myError td.Cmp(t, err, td.ErrorIs(td.Catch(&amp;cerr, td.String("my error...")))) td.Cmp(t, err, td.ErrorIs(td.All( td.Isa(myError{}), td.String("my error..."), ))) Behind the scene it uses errors.Is function if expectedError is an error and errors.As function if expectedError is a TestDeep operator.
Note that like errors.Is, expectedError can be nil: in this case the comparison succeeds only when got is nil too.</description></item><item><title>First</title><link>https://go-testdeep.zetta.rocks/operators/first/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/first/index.html</guid><description>func First(filter, expectedValue any) TestDeep First is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool. It takes the first item for which the filter matched and compares it to expectedValue. The filter matches when it is a:
TestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can of course be a TestDeep operator.</description></item><item><title>Grep</title><link>https://go-testdeep.zetta.rocks/operators/grep/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/grep/index.html</guid><description>func Grep(filter, expectedValue any) TestDeep Grep is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool, and produces a slice consisting of those items for which the filter matched and compares it to expectedValue. The filter matches when it is a:
TestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can be a TestDeep operator or a slice (but never an array nor a pointer on a slice/array nor any other kind).</description></item><item><title>Gt</title><link>https://go-testdeep.zetta.rocks/operators/gt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/gt/index.html</guid><description>func Gt(minExpectedValue any) TestDeep Gt operator checks that data is greater than minExpectedValue. minExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:
func (a T) Less(b T) bool // returns true if a &lt; b func (a T) Compare(b T) int // returns -1 if a &lt; b, 1 if a > b, 0 if a == b minExpectedValue must be the same type as the compared value, except if BeLax config flag is true.</description></item><item><title>Gte</title><link>https://go-testdeep.zetta.rocks/operators/gte/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/gte/index.html</guid><description>func Gte(minExpectedValue any) TestDeep Gte operator checks that data is greater or equal than minExpectedValue. minExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:
func (a T) Less(b T) bool // returns true if a &lt; b func (a T) Compare(b T) int // returns -1 if a &lt; b, 1 if a > b, 0 if a == b minExpectedValue must be the same type as the compared value, except if BeLax config flag is true.</description></item><item><title>HasPrefix</title><link>https://go-testdeep.zetta.rocks/operators/hasprefix/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/hasprefix/index.html</guid><description>func HasPrefix(expected string) TestDeep HasPrefix operator allows to compare the prefix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).
td.Cmp(t, []byte("foobar"), td.HasPrefix("foo")) // succeeds type Foobar string td.Cmp(t, Foobar("foobar"), td.HasPrefix("foo")) // succeeds err := errors.New("error!") td.Cmp(t, err, td.HasPrefix("err")) // succeeds bstr := bytes.NewBufferString("fmt.Stringer!") td.Cmp(t, bstr, td.HasPrefix("fmt")) // succeeds See also Contains, HasSuffix, Re, ReAll and String.
See also HasPrefix godoc.
Examples Base example t := &amp;testing.T{} got := "foobar" ok := td.Cmp(t, got, td.HasPrefix("foo"), "checks %s", got) fmt.Println("using string:", ok) ok = td.Cmp(t, []byte(got), td.HasPrefix("foo"), "checks %s", got) fmt.Println("using []byte:", ok) // Output: // using string: true // using []byte: true Stringer example t := &amp;testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString("foobar") ok := td.Cmp(t, got, td.HasPrefix("foo"), "checks %s", got) fmt.Println(ok) // Output: // true Error example t := &amp;testing.T{} got := errors.New("foobar") ok := td.Cmp(t, got, td.HasPrefix("foo"), "checks %s", got) fmt.Println(ok) // Output: // true</description></item><item><title>HasSuffix</title><link>https://go-testdeep.zetta.rocks/operators/hassuffix/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/hassuffix/index.html</guid><description>func HasSuffix(expected string) TestDeep HasSuffix operator allows to compare the suffix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).
td.Cmp(t, []byte("foobar"), td.HasSuffix("bar")) // succeeds type Foobar string td.Cmp(t, Foobar("foobar"), td.HasSuffix("bar")) // succeeds err := errors.New("error!") td.Cmp(t, err, td.HasSuffix("!")) // succeeds bstr := bytes.NewBufferString("fmt.Stringer!") td.Cmp(t, bstr, td.HasSuffix("!")) // succeeds See also Contains, HasPrefix, Re, ReAll and String.
See also HasSuffix godoc.
Examples Base example t := &amp;testing.T{} got := "foobar" ok := td.Cmp(t, got, td.HasSuffix("bar"), "checks %s", got) fmt.Println("using string:", ok) ok = td.Cmp(t, []byte(got), td.HasSuffix("bar"), "checks %s", got) fmt.Println("using []byte:", ok) // Output: // using string: true // using []byte: true Stringer example t := &amp;testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString("foobar") ok := td.Cmp(t, got, td.HasSuffix("bar"), "checks %s", got) fmt.Println(ok) // Output: // true Error example t := &amp;testing.T{} got := errors.New("foobar") ok := td.Cmp(t, got, td.HasSuffix("bar"), "checks %s", got) fmt.Println(ok) // Output: // true</description></item><item><title>Ignore</title><link>https://go-testdeep.zetta.rocks/operators/ignore/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/ignore/index.html</guid><description>func Ignore() TestDeep Ignore operator is always true, whatever data is. It is useful when comparing a slice with Slice and wanting to ignore some indexes, for example (if you don’t want to use SuperSliceOf). Or comparing a struct with SStruct and wanting to ignore some fields:
td.Cmp(t, got, td.SStruct( Person{ Name: "John Doe", }, td.StructFields{ Age: td.Between(40, 45), Children: td.Ignore(), }), ) See also Ignore godoc.
Example Base example t := &amp;testing.T{} ok := td.Cmp(t, []int{1, 2, 3}, td.Slice([]int{}, td.ArrayEntries{ 0: 1, 1: td.Ignore(), // do not care about this entry 2: 3, })) fmt.Println(ok) // Output: // true</description></item><item><title>Isa</title><link>https://go-testdeep.zetta.rocks/operators/isa/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/isa/index.html</guid><description>func Isa(model any) TestDeep Isa operator checks the data type or whether data implements an interface or not.
Typical type checks:
td.Cmp(t, time.Now(), td.Isa(time.Time{})) // succeeds td.Cmp(t, time.Now(), td.Isa(&amp;time.Time{})) // fails, as not a *time.Time td.Cmp(t, got, td.Isa(map[string]time.Time{})) For interfaces, it is a bit more complicated, as:
fmt.Stringer(nil) is not an interface, but just nil… To bypass this golang limitation, Isa accepts pointers on interfaces. So checking that data implements fmt.Stringer interface should be written as:
td.Cmp(t, bytes.Buffer{}, td.Isa((*fmt.Stringer)(nil))) // succeeds Of course, in the latter case, if checked data type is *fmt.Stringer, Isa will match too (in fact before checking whether it implements fmt.Stringer or not).</description></item><item><title>JSON</title><link>https://go-testdeep.zetta.rocks/operators/json/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/json/index.html</guid><description>func JSON(expectedJSON any, params ...any) TestDeep JSON operator allows to compare the JSON representation of data against expectedJSON. expectedJSON can be a:
string containing JSON data like {"fullname":"Bob","age":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.</description></item><item><title>JSONPointer</title><link>https://go-testdeep.zetta.rocks/operators/jsonpointer/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/jsonpointer/index.html</guid><description>func JSONPointer(ptr string, expectedValue any) TestDeep JSONPointer is a smuggler operator. It takes the JSON representation of data, gets the value corresponding to the JSON pointer ptr (as RFC 6901 specifies it) and compares it to expectedValue.
Lax mode is automatically enabled to simplify numeric tests.
JSONPointer does its best to convert back the JSON pointed data to the type of expectedValue or to the type behind the expectedValue operator, if it is an operator. Allowing to do things like:</description></item><item><title>Keys</title><link>https://go-testdeep.zetta.rocks/operators/keys/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/keys/index.html</guid><description>func Keys(val any) TestDeep Keys is a smuggler operator. It takes a map and compares its ordered keys to val.
val can be a slice of items of the same type as the map keys:
got := map[string]bool{"c": true, "a": false, "b": true} td.Cmp(t, got, td.Keys([]string{"a", "b", "c"})) // succeeds, keys sorted td.Cmp(t, got, td.Keys([]string{"c", "a", "b"})) // fails as not sorted as well as an other operator as Bag, for example, to test keys in an unsorted manner:
got := map[string]bool{"c": true, "a": false, "b": true} td.Cmp(t, got, td.Keys(td.Bag("c", "a", "b"))) // succeeds See also Values and ContainsKey.
See also Keys godoc.</description></item><item><title>Last</title><link>https://go-testdeep.zetta.rocks/operators/last/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/last/index.html</guid><description>func Last(filter, expectedValue any) TestDeep Last is a smuggler operator. It takes an array, a slice or a pointer on array/slice. For each item it applies filter, a TestDeep operator or a function returning a bool. It takes the last item for which the filter matched and compares it to expectedValue. The filter matches when it is a:
TestDeep operator and it matches for the item; function receiving the item and it returns true. expectedValue can of course be a TestDeep operator.</description></item><item><title>Lax</title><link>https://go-testdeep.zetta.rocks/operators/lax/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/lax/index.html</guid><description>func Lax(expectedValue any) TestDeep Lax is a smuggler operator, it temporarily enables the BeLax config flag before letting the comparison process continue its course.
It is more commonly used as CmpLax function than as an operator. It could be used when, for example, an operator is constructed once but applied to different, but compatible types as in:
bw := td.Between(20, 30) intValue := 21 floatValue := 21.89 td.Cmp(t, intValue, bw) // no need to be lax here: same int types td.Cmp(t, floatValue, td.Lax(bw)) // be lax please, as float64 ≠ int Note that in the latter case, CmpLax could be used as well:</description></item><item><title>Len</title><link>https://go-testdeep.zetta.rocks/operators/len/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/len/index.html</guid><description>func Len(expectedLen any) TestDeep Len is a smuggler operator. It takes data, applies len() function on it and compares its result to expectedLen. Of course, the compared value must be an array, a channel, a map, a slice or a string.
expectedLen can be an int value:
td.Cmp(t, gotSlice, td.Len(12)) as well as an other operator:
td.Cmp(t, gotSlice, td.Len(td.Between(3, 4))) See also Cap.
See also Len godoc.
Examples Slice example t := &amp;testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(3), "checks %v len is 3", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), "checks %v len is 0", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), "checks %v len is 0", got) fmt.Println(ok) // Output: // true // false // true Map example t := &amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(3), "checks %v len is 3", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), "checks %v len is 0", got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), "checks %v len is 0", got) fmt.Println(ok) // Output: // true // false // true OperatorSlice example t := &amp;testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), "checks %v len is in [3 .. 8]", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Lt(5)), "checks %v len is &lt; 5", got) fmt.Println(ok) // Output: // true // true OperatorMap example t := &amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), "checks %v len is in [3 .. 8]", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Gte(3)), "checks %v len is ≥ 3", got) fmt.Println(ok) // Output: // true // true</description></item><item><title>List</title><link>https://go-testdeep.zetta.rocks/operators/list/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/list/index.html</guid><description>func List(expectedValues ...any) TestDeep List operator compares the contents of an array or a slice (or a pointer on array/slice) with taking care of the order of items.
Array and Slice need to specify the type of array/slice being compared then to index all expected items. List does not. It acts as comparing a literal array/slice, but without having to specify the type and allowing to easily use TestDeep operators:
td.Cmp(t, []int{1, 9, 5}, td.List(1, 9, 5)) // succeeds td.Cmp(t, []int{1, 9, 5}, td.List(td.Gt(0), td.Between(8, 9), td.Lt(5))) // succeeds td.Cmp(t, []int{1, 9, 5}, td.List(1, 9)) // fails, 5 is extra td.Cmp(t, []int{1, 9, 5}, td.List(1, 9, 5, 4)) // fails, 4 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.List( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>Lt</title><link>https://go-testdeep.zetta.rocks/operators/lt/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/lt/index.html</guid><description>func Lt(maxExpectedValue any) TestDeep Lt operator checks that data is lesser than maxExpectedValue. maxExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:
func (a T) Less(b T) bool // returns true if a &lt; b func (a T) Compare(b T) int // returns -1 if a &lt; b, 1 if a > b, 0 if a == b maxExpectedValue must be the same type as the compared value, except if BeLax config flag is true.</description></item><item><title>Lte</title><link>https://go-testdeep.zetta.rocks/operators/lte/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/lte/index.html</guid><description>func Lte(maxExpectedValue any) TestDeep Lte operator checks that data is lesser or equal than maxExpectedValue. maxExpectedValue can be any numeric, string, time.Time (or assignable) value or implements at least one of the two following methods:
func (a T) Less(b T) bool // returns true if a &lt; b func (a T) Compare(b T) int // returns -1 if a &lt; b, 1 if a > b, 0 if a == b maxExpectedValue must be the same type as the compared value, except if BeLax config flag is true.</description></item><item><title>Map</title><link>https://go-testdeep.zetta.rocks/operators/map/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/map/index.html</guid><description>func Map(model any, expectedEntries MapEntries) TestDeep Map operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.
model must be the same type as compared data.
expectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.
During a match, all expected entries must be found and all data entries must be expected to succeed.
got := map[string]string{ "foo": "test", "bar": "wizz", "zip": "buzz", } td.Cmp(t, got, td.Map( map[string]string{ "foo": "test", "bar": "wizz", }, td.MapEntries{ "zip": td.HasSuffix("zz"), }), ) // succeeds TypeBehind method returns the reflect.Type of model.</description></item><item><title>MapEach</title><link>https://go-testdeep.zetta.rocks/operators/mapeach/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/mapeach/index.html</guid><description>func MapEach(expectedValue any) TestDeep MapEach operator has to be applied on maps. It compares each value of data map against expectedValue. During a match, all values have to match to succeed.
got := map[string]string{"test": "foo", "buzz": "bar"} td.Cmp(t, got, td.MapEach("bar")) // fails, coz "foo" ≠ "bar" td.Cmp(t, got, td.MapEach(td.Len(3))) // succeeds as values are 3 chars long See also MapEach godoc.
Examples Map example t := &amp;testing.T{} got := map[string]int{"foo": 12, "bar": 42, "zip": 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), "checks each value of map %v is in [10 .. 90]", got) fmt.Println(ok) // Output: // true TypedMap example t := &amp;testing.T{} type MyMap map[string]int got := MyMap{"foo": 12, "bar": 42, "zip": 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), "checks each value of typed map %v is in [10 .. 90]", got) fmt.Println(ok) ok = td.Cmp(t, &amp;got, td.MapEach(td.Between(10, 90)), "checks each value of typed map pointer %v is in [10 .. 90]", got) fmt.Println(ok) // Output: // true // true</description></item><item><title>N</title><link>https://go-testdeep.zetta.rocks/operators/n/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/n/index.html</guid><description>func N(num any, tolerance ...any) TestDeep N operator compares a numeric data against num ± tolerance. If tolerance is missing, it defaults to 0. num and tolerance must be the same type as the compared value, except if BeLax config flag is true.
td.Cmp(t, 12.2, td.N(12., 0.3)) // succeeds td.Cmp(t, 12.2, td.N(12., 0.1)) // fails TypeBehind method returns the reflect.Type of num.
See also N godoc.
Example Base example t := &amp;testing.T{} got := 1.12345 ok := td.Cmp(t, got, td.N(1.1234, 0.00006), "checks %v = 1.1234 ± 0.00006", got) fmt.Println(ok) // Output: // true CmpN shortcut func CmpN(t TestingT, got, num , tolerance any, args ...any) bool CmpN is a shortcut for:</description></item><item><title>NaN</title><link>https://go-testdeep.zetta.rocks/operators/nan/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/nan/index.html</guid><description>func NaN() TestDeep NaN operator checks that data is a float and is not-a-number.
got := math.NaN() td.Cmp(t, got, td.NaN()) // succeeds td.Cmp(t, 4.2, td.NaN()) // fails See also NotNaN.
See also NaN godoc.
Examples Float32 example t := &amp;testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NaN(), "checks %v is not-a-number", got) fmt.Println("float32(math.NaN()) is float32 not-a-number:", ok) got = 12 ok = td.Cmp(t, got, td.NaN(), "checks %v is not-a-number", got) fmt.Println("float32(12) is float32 not-a-number:", ok) // Output: // float32(math.NaN()) is float32 not-a-number: true // float32(12) is float32 not-a-number: false Float64 example t := &amp;testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NaN(), "checks %v is not-a-number", got) fmt.Println("math.NaN() is not-a-number:", ok) got = 12 ok = td.Cmp(t, got, td.NaN(), "checks %v is not-a-number", got) fmt.Println("float64(12) is not-a-number:", ok) // Output: // math.NaN() is not-a-number: true // float64(12) is not-a-number: false</description></item><item><title>Nil</title><link>https://go-testdeep.zetta.rocks/operators/nil/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/nil/index.html</guid><description>func Nil() TestDeep Nil operator checks that data is nil (or is a non-nil interface, but containing a nil pointer.)
var got *int td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails as (*int)(nil) ≠ untyped nil td.Cmp(t, got, (*int)(nil)) // succeeds but:
var got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails, as the interface is not nil got = nil td.Cmp(t, got, nil) // succeeds See also Empty, NotNil and Zero.
See also Nil godoc.
Example Base example t := &amp;testing.T{} var got fmt.Stringer // interface // nil value can be compared directly with nil, no need of Nil() here ok := td.Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway ok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing // with nil fails, as the interface is not nil ok = td.Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed ok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) // Output: // true // true // false // true CmpNil shortcut func CmpNil(t TestingT, got any, args ...any) bool CmpNil is a shortcut for:</description></item><item><title>None</title><link>https://go-testdeep.zetta.rocks/operators/none/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/none/index.html</guid><description>func None(notExpectedValues ...any) TestDeep None operator compares data against several not expected values. During a match, none of them have to match to succeed.
td.Cmp(t, 12, td.None(8, 10, 14)) // succeeds td.Cmp(t, 12, td.None(8, 10, 12, 14)) // fails Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:
prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) td.Cmp(t, 9, td.None(prime, even)) // succeeds See also All, Any and Not.
See also None godoc.
Example Base example t := &amp;testing.T{} got := 18 ok := td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), "checks %v is non-null, and ≠ 10, 20 &amp; 30, and not in [100-199]", got) fmt.Println(ok) got = 20 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), "checks %v is non-null, and ≠ 10, 20 &amp; 30, and not in [100-199]", got) fmt.Println(ok) got = 142 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), "checks %v is non-null, and ≠ 10, 20 &amp; 30, and not in [100-199]", got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = td.Cmp(t, got, td.None(prime, even, td.Gt(14)), "checks %v is not prime number, nor an even number and not > 14") fmt.Printf("%d → %t\n", got, ok) } // Output: // true // false // false // 9 → true // 3 → false // 8 → false // 15 → false CmpNone shortcut func CmpNone(t TestingT, got any, notExpectedValues []any, args ...any) bool CmpNone is a shortcut for:</description></item><item><title>Not</title><link>https://go-testdeep.zetta.rocks/operators/not/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/not/index.html</guid><description>func Not(notExpected any) TestDeep Not operator compares data against the not expected value. During a match, it must not match to succeed.
Not is the same operator as None with only one argument. It is provided as a more readable function when only one argument is needed.
td.Cmp(t, 12, td.Not(10)) // succeeds td.Cmp(t, 12, td.Not(12)) // fails See also None.
See also Not godoc.
Example Base example t := &amp;testing.T{} got := 42 ok := td.Cmp(t, got, td.Not(0), "checks %v is non-null", got) fmt.Println(ok) ok = td.Cmp(t, got, td.Not(td.Between(10, 30)), "checks %v is not in [10 .. 30]", got) fmt.Println(ok) got = 0 ok = td.Cmp(t, got, td.Not(0), "checks %v is non-null", got) fmt.Println(ok) // Output: // true // true // false CmpNot shortcut func CmpNot(t TestingT, got, notExpected any, args ...any) bool CmpNot is a shortcut for:</description></item><item><title>NotAny</title><link>https://go-testdeep.zetta.rocks/operators/notany/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/notany/index.html</guid><description>func NotAny(notExpectedItems ...any) TestDeep NotAny operator checks that the contents of an array or a slice (or a pointer on array/slice) does not contain any of “notExpectedItems”.
td.Cmp(t, []int{1}, td.NotAny(1, 2, 3)) // fails td.Cmp(t, []int{5}, td.NotAny(1, 2, 3)) // succeeds // works with slices/arrays of any type td.Cmp(t, personSlice, td.NotAny( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:
notExpected := []int{2, 1} td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(td.Flatten(notExpected))) // succeeds // = td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(2, 1)) notExp1 := []int{2, 1} notExp2 := []int{5, 8} td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(td.Flatten(notExp1), 3, td.Flatten(notExp2))) // succeeds // = td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(2, 1, 3, 5, 8)) Beware that NotAny(…) is not equivalent to Not(Any(…)) but is like Not(SuperSet(…)).</description></item><item><title>NotEmpty</title><link>https://go-testdeep.zetta.rocks/operators/notempty/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/notempty/index.html</guid><description>func NotEmpty() TestDeep NotEmpty operator checks that an array, a channel, a map, a slice or a string is not empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.
Note that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.
td.Cmp(t, "", td.NotEmpty()) // fails td.Cmp(t, map[string]bool{}, td.NotEmpty()) // fails td.Cmp(t, []string{"foo"}, td.NotEmpty()) // succeeds See also NotEmpty godoc.</description></item><item><title>NotNaN</title><link>https://go-testdeep.zetta.rocks/operators/notnan/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/notnan/index.html</guid><description>func NotNaN() TestDeep NotNaN operator checks that data is a float and is not not-a-number.
got := math.NaN() td.Cmp(t, got, td.NotNaN()) // fails td.Cmp(t, 4.2, td.NotNaN()) // succeeds td.Cmp(t, 4, td.NotNaN()) // fails, as 4 is not a float See also NaN.
See also NotNaN godoc.
Examples Float32 example t := &amp;testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NotNaN(), "checks %v is not-a-number", got) fmt.Println("float32(math.NaN()) is NOT float32 not-a-number:", ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), "checks %v is not-a-number", got) fmt.Println("float32(12) is NOT float32 not-a-number:", ok) // Output: // float32(math.NaN()) is NOT float32 not-a-number: false // float32(12) is NOT float32 not-a-number: true Float64 example t := &amp;testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NotNaN(), "checks %v is NOT not-a-number", got) fmt.Println("math.NaN() is NOT not-a-number:", ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), "checks %v is NOT not-a-number", got) fmt.Println("float64(12) is NOT not-a-number:", ok) // Output: // math.NaN() is NOT not-a-number: false // float64(12) is NOT not-a-number: true</description></item><item><title>NotNil</title><link>https://go-testdeep.zetta.rocks/operators/notnil/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/notnil/index.html</guid><description>func NotNil() TestDeep NotNil operator checks that data is not nil (or is a non-nil interface, containing a non-nil pointer.)
got := &amp;Person{} td.Cmp(t, got, td.NotNil()) // succeeds td.Cmp(t, got, td.Not(nil)) // succeeds too, but be careful it is first // because of got type *Person ≠ untyped nil so prefer NotNil() but:
var got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.NotNil()) // fails td.Cmp(t, got, td.Not(nil)) // succeeds, as the interface is not nil See also Nil, NotEmpty and NotZero.
See also NotNil godoc.</description></item><item><title>NotZero</title><link>https://go-testdeep.zetta.rocks/operators/notzero/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/notzero/index.html</guid><description>func NotZero() TestDeep NotZero operator checks that data is not zero regarding its type.
nil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; "" is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized. Beware that:
td.Cmp(t, AnyStruct{}, td.NotZero()) // is false td.Cmp(t, &amp;AnyStruct{}, td.NotZero()) // is true, coz pointer ≠ nil td.Cmp(t, &amp;AnyStruct{}, td.Ptr(td.NotZero())) // is false See also NotEmpty, NotNil and Zero.</description></item><item><title>PPtr</title><link>https://go-testdeep.zetta.rocks/operators/pptr/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/pptr/index.html</guid><description>func PPtr(val any) TestDeep PPtr is a smuggler operator. It takes the address of the address of data and compares it to val.
val depends on data type. For example, if the compared data is an **int, one can have:
num := 12 pnum = &amp;num td.Cmp(t, &amp;pnum, td.PPtr(12)) // succeeds as well as an other operator:
num := 3 pnum = &amp;num td.Cmp(t, &amp;pnum, td.PPtr(td.Between(3, 4))) // succeeds It is more efficient and shorter to write than:
td.Cmp(t, &amp;pnum, td.Ptr(td.Ptr(val))) // succeeds too TypeBehind method returns the reflect.Type of a pointer on a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on a pointer on the returned value (if non-nil of course).</description></item><item><title>Ptr</title><link>https://go-testdeep.zetta.rocks/operators/ptr/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/ptr/index.html</guid><description>func Ptr(val any) TestDeep Ptr is a smuggler operator. It takes the address of data and compares it to val.
val depends on data type. For example, if the compared data is an *int, one can have:
num := 12 td.Cmp(t, &amp;num, td.Ptr(12)) // succeeds as well as an other operator:
num := 3 td.Cmp(t, &amp;num, td.Ptr(td.Between(3, 4))) TypeBehind method returns the reflect.Type of a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on the returned value (if non-nil of course).</description></item><item><title>Re</title><link>https://go-testdeep.zetta.rocks/operators/re/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/re/index.html</guid><description>func Re(reg any, capture ...any) TestDeep Re operator allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)
reg is the regexp. It can be a string that is automatically compiled using regexp.Compile, or a *regexp.Regexp.
Optional capture parameter can be used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.</description></item><item><title>ReAll</title><link>https://go-testdeep.zetta.rocks/operators/reall/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/reall/index.html</guid><description>func ReAll(reg, capture any) TestDeep ReAll operator allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer) and to match its groups contents.
reg is the regexp. It can be a string that is automatically compiled using regexp.Compile, or a *regexp.Regexp.
capture is used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.</description></item><item><title>Recv</title><link>https://go-testdeep.zetta.rocks/operators/recv/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/recv/index.html</guid><description>func Recv(expectedValue any, timeout ...time.Duration) TestDeep Recv is a smuggler operator. It reads from a channel or a pointer to a channel and compares the read value to expectedValue.
expectedValue can be any value including a TestDeep operator. It can also be RecvNothing to test nothing can be read from the channel or RecvClosed to check the channel is closed.
If timeout is passed it should be only one item. It means: try to read the channel during this duration to get a value before giving up. If timeout is missing or ≤ 0, it defaults to 0 meaning Recv does not wait for a value but gives up instantly if no value is available on the channel.</description></item><item><title>Set</title><link>https://go-testdeep.zetta.rocks/operators/set/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/set/index.html</guid><description>func Set(expectedItems ...any) TestDeep Set operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.
During a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.
td.Cmp(t, []int{1, 1, 2}, td.Set(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(1, 2, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.Set( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>Shallow</title><link>https://go-testdeep.zetta.rocks/operators/shallow/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/shallow/index.html</guid><description>func Shallow(expectedPtr any) TestDeep Shallow operator compares pointers only, not their contents. It applies on channels, functions (with some restrictions), maps, pointers, slices and strings.
During a match, the compared data must be the same as expectedPtr to succeed.
a, b := 123, 123 td.Cmp(t, &amp;a, td.Shallow(&amp;a)) // succeeds td.Cmp(t, &amp;a, td.Shallow(&amp;b)) // fails even if a == b as &amp;a != &amp;b back := "foobarfoobar" a, b := back[:6], back[6:] // a == b but... td.Cmp(t, &amp;a, td.Shallow(&amp;b)) // fails Be careful for slices and strings! Shallow can succeed but the slices/strings not be identical because of their different lengths. For example:</description></item><item><title>Slice</title><link>https://go-testdeep.zetta.rocks/operators/slice/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/slice/index.html</guid><description>func Slice(model any, expectedEntries ArrayEntries) TestDeep Slice operator compares the contents of a slice or a pointer on a slice against the values of model and the values of expectedEntries. Entries with zero values of model are ignored if the same entry is present in expectedEntries, otherwise they are taken into account. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, all entries are checked. To check only some entries of a slice, see SuperSliceOf operator.</description></item><item><title>Smuggle</title><link>https://go-testdeep.zetta.rocks/operators/smuggle/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/smuggle/index.html</guid><description>func Smuggle(fn, expectedValue any) TestDeep Smuggle operator allows to change data contents or mutate it into another type before stepping down in favor of generic comparison process. Of course it is a smuggler operator. So fn is a function that must take one parameter whose type must be convertible to the type of the compared value.
As convenient shortcuts, fn can be a string specifying a fields-path through structs, maps &amp; slices, or any other type, in this case a simple cast is done (see below for details).</description></item><item><title>Sort</title><link>https://go-testdeep.zetta.rocks/operators/sort/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/sort/index.html</guid><description>func Sort(how any, expectedValue any) TestDeep Sort is a smuggler operator. It takes an array, a slice or a pointer on array/slice, it sorts it using how and compares the sorted result to expectedValue. It can be seen as an alternative to Bag.
how can be:
nil or a float64/int >= 0 for a generic ascending order; a float64/int &lt; 0 for a generic descending order; a string specifying a fields-path (optionally prefixed by “+” or “-” for respectively an ascending or a descending order, defaulting to ascending one); a []string containing a list of fields-paths (as above), second and next fields-paths are checked when the previous ones are equal; a function matching func(a, b T) bool signature and returning true if a is before b. A fields-path, also used by Smuggle and Sorted operators, allows to access nested structs fields and maps &amp; slices items. See Smuggle for details on fields-path possibilities.</description></item><item><title>Sorted</title><link>https://go-testdeep.zetta.rocks/operators/sorted/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/sorted/index.html</guid><description>func Sorted(how ...any) TestDeep Sorted operator checks that data is an array, a slice or a pointer on array/slice, and it is well sorted as how tells it should be.
how… can be:
empty to check a generic ascending order; nil or a float64/int >= 0 to check a generic ascending order; a float64/int &lt; 0 to check a generic descending order; strings specifying fields-paths (each optionally prefixed by “+” or “-” for respectively checking an ascending or a descending order, defaulting to ascending one); a function matching func(a, b T) bool signature and returning true if a is before b. A fields-path, also used by Smuggle and Sort operators, allows to access nested structs fields and maps &amp; slices items. See Smuggle for details on fields-path possibilities.</description></item><item><title>SStruct</title><link>https://go-testdeep.zetta.rocks/operators/sstruct/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/sstruct/index.html</guid><description>func SStruct(model any, expectedFields ...StructFields) TestDeep SStruct operator (aka strict-Struct) compares the contents of a struct or a pointer on a struct against values of model (if any) and the values of expectedFields. The zero values are compared too even if they are omitted from expectedFields: that is the difference with Struct operator.
model must be the same type as compared data. If the expected type is private or anonymous, model can be nil. In this case it is considered lazy and determined each time the operator is involved in a match, see below.</description></item><item><title>String</title><link>https://go-testdeep.zetta.rocks/operators/string/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/string/index.html</guid><description>func String(expected string) TestDeep String operator allows to compare a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).
err := errors.New("error!") td.Cmp(t, err, td.String("error!")) // succeeds bstr := bytes.NewBufferString("fmt.Stringer!") td.Cmp(t, bstr, td.String("fmt.Stringer!")) // succeeds See also Contains, HasPrefix, HasSuffix, Re and ReAll.
See also String godoc.
Examples Base example t := &amp;testing.T{} got := "foobar" ok := td.Cmp(t, got, td.String("foobar"), "checks %s", got) fmt.Println("using string:", ok) ok = td.Cmp(t, []byte(got), td.String("foobar"), "checks %s", got) fmt.Println("using []byte:", ok) // Output: // using string: true // using []byte: true Stringer example t := &amp;testing.T{} // bytes.Buffer implements fmt.Stringer got := bytes.NewBufferString("foobar") ok := td.Cmp(t, got, td.String("foobar"), "checks %s", got) fmt.Println(ok) // Output: // true Error example t := &amp;testing.T{} got := errors.New("foobar") ok := td.Cmp(t, got, td.String("foobar"), "checks %s", got) fmt.Println(ok) // Output: // true</description></item><item><title>Struct</title><link>https://go-testdeep.zetta.rocks/operators/struct/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/struct/index.html</guid><description>func Struct(model any, expectedFields ...StructFields) TestDeep Struct operator compares the contents of a struct or a pointer on a struct against the non-zero values of model (if any) and the values of expectedFields. See SStruct to compares against zero fields without specifying them in expectedFields.
model must be the same type as compared data. If the expected type is anonymous or private, model can be nil. In this case it is considered lazy and determined each time the operator is involved in a match, see below.</description></item><item><title>SubBagOf</title><link>https://go-testdeep.zetta.rocks/operators/subbagof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/subbagof/index.html</guid><description>func SubBagOf(expectedItems ...any) TestDeep SubBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.
During a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.
td.Cmp(t, []int{1}, td.SubBagOf(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 1}, td.SubBagOf(1, 1, 2)) // fails, one 1 is an extra item // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubBagOf( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>SubJSONOf</title><link>https://go-testdeep.zetta.rocks/operators/subjsonof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/subjsonof/index.html</guid><description>func SubJSONOf(expectedJSON any, params ...any) TestDeep SubJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshaled data must be a JSON object/map (aka {…}). expectedJSON can be a:
string containing JSON data like {"fullname":"Bob","age":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some expected entries can be missing from the compared map.</description></item><item><title>SubMapOf</title><link>https://go-testdeep.zetta.rocks/operators/submapof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/submapof/index.html</guid><description>func SubMapOf(model any, expectedEntries MapEntries) TestDeep SubMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.
model must be the same type as compared data.
expectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.
During a match, each map entry should be matched by an expected entry to succeed. But some expected entries can be missing from the compared map.</description></item><item><title>SubSetOf</title><link>https://go-testdeep.zetta.rocks/operators/subsetof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/subsetof/index.html</guid><description>func SubSetOf(expectedItems ...any) TestDeep SubSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.
During a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.
td.Cmp(t, []int{1, 1}, td.SubSetOf(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SubSetOf(1, 3)) // fails, 2 is an extra item // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubSetOf( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>SuperBagOf</title><link>https://go-testdeep.zetta.rocks/operators/superbagof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/superbagof/index.html</guid><description>func SuperBagOf(expectedItems ...any) TestDeep SuperBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.
During a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.
td.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1, 1, 1)) // fails, one 1 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperBagOf( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>SuperJSONOf</title><link>https://go-testdeep.zetta.rocks/operators/superjsonof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/superjsonof/index.html</guid><description>func SuperJSONOf(expectedJSON any, params ...any) TestDeep SuperJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshaled data must be a JSON object/map (aka {…}). expectedJSON can be a:
string containing JSON data like {"fullname":"Bob","age":42} string containing a JSON filename, ending with “.json” (its content is os.ReadFile before unmarshaling) []byte containing JSON data encoding/json.RawMessage containing JSON data io.Reader stream containing JSON data (is io.ReadAll before unmarshaling) JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.</description></item><item><title>SuperMapOf</title><link>https://go-testdeep.zetta.rocks/operators/supermapof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/supermapof/index.html</guid><description>func SuperMapOf(model any, expectedEntries MapEntries) TestDeep SuperMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.
model must be the same type as compared data.
expectedEntries can be nil, if no zero entries are expected and no TestDeep operators are involved.
During a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.</description></item><item><title>SuperSetOf</title><link>https://go-testdeep.zetta.rocks/operators/supersetof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/supersetof/index.html</guid><description>func SuperSetOf(expectedItems ...any) TestDeep SuperSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.
During a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.
td.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1, 3)) // fails, 3 is missing // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperSetOf( Person{Name: "Bob", Age: 32}, Person{Name: "Alice", Age: 26}, )) To flatten a non-[]any slice/array, use Flatten function and so avoid boring and inefficient copies:</description></item><item><title>SuperSliceOf</title><link>https://go-testdeep.zetta.rocks/operators/supersliceof/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/supersliceof/index.html</guid><description>func SuperSliceOf(model any, expectedEntries ArrayEntries) TestDeep SuperSliceOf operator compares the contents of an array, a pointer on an array, a slice or a pointer on a slice against the non-zero values of model (if any) and the values of expectedEntries. So entries with zero value of model are always ignored. If a zero value check is needed, this zero value has to be set in expectedEntries. An entry cannot be present in both model and expectedEntries, except if it is a zero-value in model. At the end, only entries present in expectedEntries and non-zero ones present in model are checked. To check all entries of an array see Array operator. To check all entries of a slice see Slice operator.</description></item><item><title>Tag</title><link>https://go-testdeep.zetta.rocks/operators/tag/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/tag/index.html</guid><description>func Tag(tag string, expectedValue any) TestDeep Tag is a smuggler operator. It only allows to name expectedValue, which can be an operator or a value. The data is then compared against expectedValue as if Tag was never called. It is only useful as JSON operator parameter, to name placeholders. See JSON operator for more details.
td.Cmp(t, gotValue, td.JSON(`{"fullname": $name, "age": $age, "gender": $gender}`, td.Tag("name", td.HasPrefix("Foo")), // matches $name td.Tag("age", td.Between(41, 43)), // matches $age td.Tag("gender", "male"))) // matches $gender TypeBehind method is delegated to expectedValue one if expectedValue is a TestDeep operator, otherwise it returns the type of expectedValue (or nil if it is originally untyped nil).</description></item><item><title>TruncTime</title><link>https://go-testdeep.zetta.rocks/operators/trunctime/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/trunctime/index.html</guid><description>func TruncTime(expectedTime any, trunc ...time.Duration) TestDeep TruncTime operator compares time.Time (or assignable) values after truncating them to the optional trunc duration. See time.Time.Truncate for details about the truncation.
If trunc is missing, it defaults to 0.
During comparison, location does not matter as time.Time.Equal method is used behind the scenes: a time instant in two different locations is the same time instant.
Whatever the trunc value is, the monotonic clock is stripped before the comparison against expectedTime.</description></item><item><title>Values</title><link>https://go-testdeep.zetta.rocks/operators/values/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/values/index.html</guid><description>func Values(val any) TestDeep Values is a smuggler operator. It takes a map and compares its ordered values to val.
val can be a slice of items of the same type as the map values:
got := map[int]string{3: "c", 1: "a", 2: "b"} td.Cmp(t, got, td.Values([]string{"a", "b", "c"})) // succeeds, values sorted td.Cmp(t, got, td.Values([]string{"c", "a", "b"})) // fails as not sorted as well as an other operator as Bag, for example, to test values in an unsorted manner:
got := map[int]string{3: "c", 1: "a", 2: "b"} td.Cmp(t, got, td.Values(td.Bag("c", "a", "b"))) // succeeds See also Keys.
See also Values godoc.</description></item><item><title>Zero</title><link>https://go-testdeep.zetta.rocks/operators/zero/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/operators/zero/index.html</guid><description>func Zero() TestDeep Zero operator checks that data is zero regarding its type.
nil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; "" is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized. Beware that:
td.Cmp(t, AnyStruct{}, td.Zero()) // is true td.Cmp(t, &amp;AnyStruct{}, td.Zero()) // is false, coz pointer ≠ nil td.Cmp(t, &amp;AnyStruct{}, td.Ptr(td.Zero())) // is true See also Empty, Nil and NotZero.</description></item></channel></rss>