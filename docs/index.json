[{"uri":"https://go-testdeep.zetta.rocks/operators/matrix/","title":"Operators matrices","tags":[],"description":"","content":"Operator → go type matrix    Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     All ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ All   Any ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Any   Array ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ptr on array ✓ ✗ ✗ Array   ArrayEach ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ ArrayEach   Bag ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Bag   Between ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Between   Cap ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ✗ ✓ ✓ ✗ Cap   Catch ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Catch   Code ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Code   Contains ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Contains       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     ContainsKey ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ ContainsKey   Delay ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Delay   Empty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ Empty   Gt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gt   Gte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Gte   HasPrefix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasPrefix   HasSuffix ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ HasSuffix   Ignore ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Ignore   Isa ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Isa   JSON ✓ ✓ ✓ ✓ ✓ ✗ ✓ ✓ ✓ ✓ ✓ ✓ ✗ ✗ JSON       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     Keys ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Keys   Lax ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Lax   Len ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ✗ ✓ ✓ ✗ Len   Lt ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lt   Lte ✗ ✗ ✓ ✓ ✓ todo ✗ ✗ ✗ time.Time ✗ ✓ ✗ ✗ Lte   Map ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ Map   MapEach ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ MapEach   N ✗ ✗ ✗ ✓ ✓ todo ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ N   NaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NaN   Nil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Nil       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     None ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ None   Not ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Not   NotAny ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ NotAny   NotEmpty ✗ ✗ ✓ ✗ ✗ ✗ ✓ ✓ ✓ ✗ ptr on array/slice/map/string ✓ ✓ ✗ NotEmpty   NotNaN ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ NotNaN   NotNil ✓ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ NotNil   NotZero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ NotZero   PPtr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ PPtr   Ptr ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ Ptr   Re ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ Re       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     ReAll ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ ReAll   Set ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ Set   Shallow ✓ ✗ ✓ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✓ ✓ ✓ ✓ Shallow   Slice ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ptr on slice ✓ ✗ ✗ Slice   Smuggle ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Smuggle   SStruct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ SStruct   String ✗ ✗ ✓ ✗ ✗ ✗ ✗ []byte ✗ ✗ ✗ ✓ + fmt.Stringer/error ✗ ✗ String   Struct ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ptr on struct ✓ ✗ ✗ Struct   SubBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubBagOf   SubJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SubJSONOf       Operator vs go type nil bool string {u,}int* float* complex* array slice map struct pointer interface¹ chan func operator     SubMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SubMapOf   SubSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SubSetOf   SuperBagOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperBagOf   SuperJSONOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ptr on map/struct ✓ ✗ ✗ SuperJSONOf   SuperMapOf ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ptr on map ✓ ✗ ✗ SuperMapOf   SuperSetOf ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✓ ✗ ✗ ptr on array/slice ✓ ✗ ✗ SuperSetOf   Tag ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Tag   TruncTime ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ time.Time todo ✓ ✗ ✗ TruncTime   Values ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✗ ✓ ✗ ✗ ✓ ✗ ✗ Values   Zero ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ ✓ Zero    Legend:\n ✗ means using this operator with a value type of this kind will always fail ✓ means using this operator with a value type of this kind can succeed []byte, time.Time, ptr on X, fmt.Stringer, error means using this operator with this go type can succeed todo means should be implemented in future (PRs welcome :) ) ¹ + ✓ means using this operator with the data behind the interface can succeed  go type → operator matrix Operators likely to succeed for each go type:\nUntyped nil value  All Any Catch Code Delay Ignore JSON Lax Nil None Not NotNil NotZero Shallow Smuggle Tag Zero  bool values (or any type based on bool)  All Any Catch Code Delay Ignore Isa JSON Lax None Not NotZero Smuggle Tag Zero  string values (or any type based on string)  All Any Between Catch Code Contains Delay Empty Gt Gte HasPrefix HasSuffix Ignore Isa JSON Lax Lt Lte None Not NotEmpty NotZero Re ReAll Shallow Smuggle String Tag Zero  Integer values (uint*, int* or any type based on them)  All Any Between Catch Code Delay Gt Gte Ignore Isa JSON Lax Lt Lte N None Not NotZero Smuggle Tag Zero  Float values (float32, float64 or any type based on them)  All Any Between Catch Code Delay Gt Gte Ignore Isa JSON Lax Lt Lte N NaN None Not NotNaN NotZero Smuggle Tag Zero  Complex values (complex64, complex128 or any type based on them)  All Any Catch Code Delay Ignore Isa Lax None Not NotZero Smuggle Tag Zero  Arrays  All Any Array ArrayEach Bag Cap Catch Code Contains Delay Empty Ignore Isa JSON Lax Len None Not NotAny NotEmpty NotZero Set Smuggle SubBagOf SubSetOf SuperBagOf SuperSetOf Tag Zero  Slices  All Any ArrayEach Bag Cap Catch Code Contains Delay Empty HasPrefix only []byte HasSuffix only []byte Ignore Isa JSON Lax Len Nil None Not NotAny NotEmpty NotNil NotZero Re only []byte ReAll only []byte Set Shallow Slice Smuggle String only []byte SubBagOf SubSetOf SuperBagOf SuperSetOf Tag Zero  Maps  All Any Catch Code Contains ContainsKey Delay Empty Ignore Isa JSON Keys Lax Len Map MapEach Nil None Not NotEmpty NotNil NotZero Shallow Smuggle SubJSONOf SubMapOf SuperJSONOf SuperMapOf Tag Values Zero  Structs  All Any Between only time.Time Catch Code Delay Gt only time.Time Gte only time.Time Ignore Isa JSON Lax Lt only time.Time Lte only time.Time None Not NotZero SStruct Smuggle Struct SubJSONOf SuperJSONOf Tag TruncTime only time.Time Zero  Interface values As all operators accept interface values, only specific interfaces are listed below:\n Contains → fmt.Stringer/error HasPrefix → fmt.Stringer/error HasSuffix → fmt.Stringer/error Re → fmt.Stringer/error ReAll → fmt.Stringer/error String → fmt.Stringer/error  Any pointer  All Any Array only ptr on array ArrayEach only ptr on array/slice Bag only ptr on array/slice Catch Code Delay Empty only ptr on array/slice/map/string Ignore Isa JSON Lax Map only ptr on map MapEach only ptr on map Nil None Not NotAny only ptr on array/slice NotEmpty only ptr on array/slice/map/string NotNil NotZero PPtr Ptr SStruct only ptr on struct Set only ptr on array/slice Shallow Slice only ptr on slice Smuggle Struct only ptr on struct SubBagOf only ptr on array/slice SubJSONOf only ptr on map/struct SubMapOf only ptr on map SubSetOf only ptr on array/slice SuperBagOf only ptr on array/slice SuperJSONOf only ptr on map/struct SuperMapOf only ptr on map SuperSetOf only ptr on array/slice Tag Zero  Channels  All Any Cap Catch Code Delay Empty Ignore Isa Lax Len Nil None Not NotEmpty NotNil NotZero Shallow Smuggle Tag Zero  Functions  All Any Catch Code Delay Ignore Isa Lax Nil None Not NotNil NotZero Shallow Smuggle Tag Zero  "},{"uri":"https://go-testdeep.zetta.rocks/","title":"go-testdeep","tags":[],"description":"","content":"go-testdeep go-testdeep, via the td package and its helpers, allows golang extremely flexible deep comparison. It is built for testing.\n← use the right menu to navigate. A good starting point is the introduction "},{"uri":"https://go-testdeep.zetta.rocks/introduction/","title":"Introduction","tags":[],"description":"","content":"Synopsis Make golang tests easy, from simplest usage:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), \u0026amp;Info{Name: \u0026#34;Alice\u0026#34;, Age: 42}) } To a bit more complex one, allowing flexible comparisons using TestDeep operators:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), td.Struct( \u0026amp;Info{Name: \u0026#34;Alice\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 45), }, )) } Or anchoring operators directly in literals, as in:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), \u0026amp;Info{ Name: \u0026#34;Alice\u0026#34;, Age: t.Anchor(td.Between(40, 45)).(int), }) } To most complex one, allowing to easily test HTTP API routes, using flexible operators and the tdhttp helper:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/helpers/tdhttp\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) type Person struct { ID uint64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` } func TestMyApi(t *testing.T) { var id uint64 var createdAt time.Time testAPI := tdhttp.NewTestAPI(t, myAPI) // ← ①  testAPI.PostJSON(\u0026#34;/person\u0026#34;, Person{Name: \u0026#34;Bob\u0026#34;, Age: 42}). // ← ②  Name(\u0026#34;Create a new Person\u0026#34;). CmpStatus(http.StatusCreated). // ← ③  CmpJSONBody(td.JSON(` // Note that comments are allowed { \u0026#34;id\u0026#34;: $id, // set by the API/DB \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42, \u0026#34;created_at\u0026#34;: \u0026#34;$createdAt\u0026#34;, // set by the API/DB }`, td.Tag(\u0026#34;id\u0026#34;, td.Catch(\u0026amp;id, td.NotZero())), // ← ④  td.Tag(\u0026#34;created_at\u0026#34;, td.All( // ← ⑤  td.HasSuffix(\u0026#34;Z\u0026#34;), // ← ⑥  td.Smuggle(func(s string) (time.Time, error) { // ← ⑦  return time.Parse(time.RFC3339Nano, s) }, td.Catch(\u0026amp;createdAt, td.Between(testAPI.SentAt(), time.Now()))), // ← ⑧  )), )) if !testAPI.Failed() { t.Logf(\u0026#34;The new Person ID is %d and was created at %s\u0026#34;, id, createdAt) } }  the API handler ready to be tested; the POST request with automatic JSON marshalling; the expected response HTTP status should be http.StatusCreated and the line just below, the body should match the JSON operator; for the $id placeholder, Catch its value: put it in id variable and check it is NotZero; for the $created_at placeholder, use the All operator. It combines several operators like a AND; check that $created_at date ends with \u0026ldquo;Z\u0026rdquo; using HasSuffix. As we expect a RFC3339 date, we require it in UTC time zone; convert $created_at date into a time.Time using a custom function thanks to the Smuggle operator; then Catch the resulting value: put it in createdAt variable and check it is greater or equal than testAPI.SentAt() (the time just before the request is handled) and lesser or equal than time.Now().  Example of produced error in case of mismatch:\nDescription go-testdeep is a go rewrite and adaptation of wonderful Test::Deep perl.\nIn golang, comparing data structure is usually done using reflect.DeepEqual or using a package that uses this function behind the scene.\nThis function works very well, but it is not flexible. Both compared structures must match exactly and when a difference is returned, it is up to the caller to display it. Not easy when comparing big data structures.\nThe purpose of go-testdeep, via td package and its helpers, is to do its best to introduce this missing flexibility using \u0026ldquo;operators\u0026rdquo;, when the expected value (or one of its component) cannot be matched exactly, mixed with some useful comparison functions.\n"},{"uri":"https://go-testdeep.zetta.rocks/operators/all/","title":"All","tags":[],"description":"","content":"func All(expectedValues ...interface{}) TestDeep All operator compares data against several expected values. During a match, all of them have to match to succeed. Consider it as a \u0026ldquo;AND\u0026rdquo; logical operator.\ntd.Cmp(t, \u0026#34;foobar\u0026#34;, td.All( td.Len(6), td.HasPrefix(\u0026#34;fo\u0026#34;), td.HasSuffix(\u0026#34;ar\u0026#34;), )) // succeeds Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nstringOps := td.Flatten([]td.TestDeep{td.HasPrefix(\u0026#34;fo\u0026#34;), td.HasSuffix(\u0026#34;ar\u0026#34;)}) td.Cmp(t, \u0026#34;foobar\u0026#34;, td.All( td.Len(6), stringOps, )) // succeeds One can do the same with All operator itself:\nstringOps := td.All(td.HasPrefix(\u0026#34;fo\u0026#34;), td.HasSuffix(\u0026#34;ar\u0026#34;)) td.Cmp(t, \u0026#34;foobar\u0026#34;, td.All( td.Len(6), stringOps, )) // succeeds but if an error occurs in the nested All, the report is a bit more complex to read due to the nested level. Flatten does not create a new level, its slice is just flattened in the All parameters.\nTypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\n See also All godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;foo/bar\u0026#34; string \tok := td.Cmp(t, got, td.All(td.Re(\u0026#34;o/b\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;foo/bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;fooX/Ybar\u0026#34; string \tok = td.Cmp(t, got, td.All(td.Re(\u0026#34;o/b\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;fooX/Ybar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // When some operators or values have to be reused and mixed between \t// several calls, Flatten can be used to avoid boring and \t// inefficient []interface{} copies: \tregOps := td.Flatten([]td.TestDeep{td.Re(\u0026#34;o/b\u0026#34;), td.Re(`^fo`), td.Re(`ar$`)}) ok = td.Cmp(t, got, td.All(td.HasPrefix(\u0026#34;foo\u0026#34;), regOps, td.HasSuffix(\u0026#34;bar\u0026#34;)), \u0026#34;checks all operators against value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     CmpAll shortcut func CmpAll(t TestingT, got interface{}, expectedValues []interface{}, args ...interface{}) bool CmpAll is a shortcut for:\ntd.Cmp(t, got, td.All(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpAll godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;foo/bar\u0026#34; string \tok := td.CmpAll(t, got, []interface{}{td.Re(\u0026#34;o/b\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;foo/bar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;fooX/Ybar\u0026#34; string \tok = td.CmpAll(t, got, []interface{}{td.Re(\u0026#34;o/b\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;fooX/Ybar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // When some operators or values have to be reused and mixed between \t// several calls, Flatten can be used to avoid boring and \t// inefficient []interface{} copies: \tregOps := td.Flatten([]td.TestDeep{td.Re(\u0026#34;o/b\u0026#34;), td.Re(`^fo`), td.Re(`ar$`)}) ok = td.CmpAll(t, got, []interface{}{td.HasPrefix(\u0026#34;foo\u0026#34;), regOps, td.HasSuffix(\u0026#34;bar\u0026#34;)}, \u0026#34;checks all operators against value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     T.All shortcut func (t *T) All(got interface{}, expectedValues []interface{}, args ...interface{}) bool All is a shortcut for:\nt.Cmp(got, td.All(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.All godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;foo/bar\u0026#34; string \tok := t.All(got, []interface{}{td.Re(\u0026#34;o/b\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;foo/bar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;o/b\u0026#34; regexp *AND* \u0026#34;bar\u0026#34; suffix *AND* exact \u0026#34;fooX/Ybar\u0026#34; string \tok = t.All(got, []interface{}{td.Re(\u0026#34;o/b\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;fooX/Ybar\u0026#34;}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // When some operators or values have to be reused and mixed between \t// several calls, Flatten can be used to avoid boring and \t// inefficient []interface{} copies: \tregOps := td.Flatten([]td.TestDeep{td.Re(\u0026#34;o/b\u0026#34;), td.Re(`^fo`), td.Re(`ar$`)}) ok = t.All(got, []interface{}{td.HasPrefix(\u0026#34;foo\u0026#34;), regOps, td.HasSuffix(\u0026#34;bar\u0026#34;)}, \u0026#34;checks all operators against value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/any/","title":"Any","tags":[],"description":"","content":"func Any(expectedValues ...interface{}) TestDeep Any operator compares data against several expected values. During a match, at least one of them has to match to succeed. Consider it as a \u0026ldquo;OR\u0026rdquo; logical operator.\ntd.Cmp(t, \u0026#34;foo\u0026#34;, td.Any(\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;)) // succeeds td.Cmp(t, \u0026#34;foo\u0026#34;, td.Any( td.Len(4), td.HasPrefix(\u0026#34;f\u0026#34;), td.HasSuffix(\u0026#34;z\u0026#34;), )) // succeeds coz \u0026#34;f\u0026#34; prefix Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nstringOps := td.Flatten([]td.TestDeep{td.HasPrefix(\u0026#34;f\u0026#34;), td.HasSuffix(\u0026#34;z\u0026#34;)}) td.Cmp(t, \u0026#34;foobar\u0026#34;, td.All( td.Len(4), stringOps, )) // succeeds coz \u0026#34;f\u0026#34; prefix TypeBehind method can return a non-nil reflect.Type if all items known non-interface types are equal, or if only interface types are found (mostly issued from Isa()) and they are equal.\n See also Any godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;bar\u0026#34; suffix \tok := td.Cmp(t, got, td.Any(td.Re(\u0026#34;zip\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;foo\u0026#34; suffix \tok = td.Cmp(t, got, td.Any(td.Re(\u0026#34;zip\u0026#34;), td.HasSuffix(\u0026#34;foo\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // When some operators or values have to be reused and mixed between \t// several calls, Flatten can be used to avoid boring and \t// inefficient []interface{} copies: \tregOps := td.Flatten([]td.TestDeep{td.Re(\u0026#34;a/c\u0026#34;), td.Re(`^xx`), td.Re(`ar$`)}) ok = td.Cmp(t, got, td.Any(td.HasPrefix(\u0026#34;xxx\u0026#34;), regOps, td.HasSuffix(\u0026#34;zip\u0026#34;)), \u0026#34;check at least one operator matches value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     CmpAny shortcut func CmpAny(t TestingT, got interface{}, expectedValues []interface{}, args ...interface{}) bool CmpAny is a shortcut for:\ntd.Cmp(t, got, td.Any(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpAny godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;bar\u0026#34; suffix \tok := td.CmpAny(t, got, []interface{}{td.Re(\u0026#34;zip\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;foo\u0026#34; suffix \tok = td.CmpAny(t, got, []interface{}{td.Re(\u0026#34;zip\u0026#34;), td.HasSuffix(\u0026#34;foo\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // When some operators or values have to be reused and mixed between \t// several calls, Flatten can be used to avoid boring and \t// inefficient []interface{} copies: \tregOps := td.Flatten([]td.TestDeep{td.Re(\u0026#34;a/c\u0026#34;), td.Re(`^xx`), td.Re(`ar$`)}) ok = td.CmpAny(t, got, []interface{}{td.HasPrefix(\u0026#34;xxx\u0026#34;), regOps, td.HasSuffix(\u0026#34;zip\u0026#34;)}, \u0026#34;check at least one operator matches value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     T.Any shortcut func (t *T) Any(got interface{}, expectedValues []interface{}, args ...interface{}) bool Any is a shortcut for:\nt.Cmp(got, td.Any(expectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Any godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foo/bar\u0026#34; // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;bar\u0026#34; suffix \tok := t.Any(got, []interface{}{td.Re(\u0026#34;zip\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Checks got string against: \t// \u0026#34;zip\u0026#34; regexp *OR* \u0026#34;foo\u0026#34; suffix \tok = t.Any(got, []interface{}{td.Re(\u0026#34;zip\u0026#34;), td.HasSuffix(\u0026#34;foo\u0026#34;)}, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // When some operators or values have to be reused and mixed between \t// several calls, Flatten can be used to avoid boring and \t// inefficient []interface{} copies: \tregOps := td.Flatten([]td.TestDeep{td.Re(\u0026#34;a/c\u0026#34;), td.Re(`^xx`), td.Re(`ar$`)}) ok = t.Any(got, []interface{}{td.HasPrefix(\u0026#34;xxx\u0026#34;), regOps, td.HasSuffix(\u0026#34;zip\u0026#34;)}, \u0026#34;check at least one operator matches value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/array/","title":"Array","tags":[],"description":"","content":"func Array(model interface{}, expectedEntries ArrayEntries) TestDeep Array operator compares the contents of an array or a pointer on an array against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\ngot := [3]int{12, 14, 17} td.Cmp(t, got, td.Array([3]int{0, 14}, td.ArrayEntries{0: 12, 2: 17})) // succeeds td.Cmp(t, got, td.Array([3]int{0, 14}, td.ArrayEntries{0: td.Gt(10), 2: td.Gt(15)})) // succeeds TypeBehind method returns the reflect.Type of model.\n See also Array godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := td.Cmp(t, got, td.Array([3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \u0026#34;checks array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.Cmp(t, got, td.Array(MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \u0026#34;checks typed array %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Array(\u0026amp;MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Array(\u0026amp;MyArray{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Array((*MyArray)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \nCmpArray shortcut func CmpArray(t TestingT, got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool CmpArray is a shortcut for:\ntd.Cmp(t, got, td.Array(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpArray godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := td.CmpArray(t, got, [3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.CmpArray(t, got, MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks typed array %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpArray(t, \u0026amp;got, \u0026amp;MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpArray(t, \u0026amp;got, \u0026amp;MyArray{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpArray(t, \u0026amp;got, (*MyArray)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \nT.Array shortcut func (t *T) Array(got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool Array is a shortcut for:\nt.Cmp(got, td.Array(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Array godoc.\n Examples    Array example   t := td.NewT(\u0026amp;testing.T{}) got := [3]int{42, 58, 26} ok := t.Array(got, [3]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedArray example   t := td.NewT(\u0026amp;testing.T{}) type MyArray [3]int got := MyArray{42, 58, 26} ok := t.Array(got, MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks typed array %v\u0026#34;, got) fmt.Println(ok) ok = t.Array(\u0026amp;got, \u0026amp;MyArray{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = t.Array(\u0026amp;got, \u0026amp;MyArray{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) ok = t.Array(\u0026amp;got, (*MyArray)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed array %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/arrayeach/","title":"ArrayEach","tags":[],"description":"","content":"func ArrayEach(expectedValue interface{}) TestDeep ArrayEach operator has to be applied on arrays or slices or on pointers on array/slice. It compares each item of data array/slice against expectedValue. During a match, all items have to match to succeed.\ngot := [3]string{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;biz\u0026#34;} td.Cmp(t, got, td.ArrayEach(td.Len(3))) // succeeds td.Cmp(t, got, td.ArrayEach(td.HasPrefix(\u0026#34;b\u0026#34;))) // fails coz \u0026#34;foo\u0026#34; Works on slices as well:\ngot := []Person{ {Name: \u0026#34;Bob\u0026#34;, Age: 42}, {Name: \u0026#34;Alice\u0026#34;, Age: 24}, } td.Cmp(t, got, td.ArrayEach( td.Struct(Person{}, td.StructFields{ Age: td.Between(20, 45), })), ) // succeeds, each Person has Age field between 20 and 45  See also ArrayEach godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \u0026#34;checks each item of array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \u0026#34;checks each item of typed array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.ArrayEach(td.Between(25, 60)), \u0026#34;checks each item of typed array pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true       Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \u0026#34;checks each item of slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.Cmp(t, got, td.ArrayEach(td.Between(25, 60)), \u0026#34;checks each item of typed slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.ArrayEach(td.Between(25, 60)), \u0026#34;checks each item of typed slice pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nCmpArrayEach shortcut func CmpArrayEach(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpArrayEach is a shortcut for:\ntd.Cmp(t, got, td.ArrayEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpArrayEach godoc.\n Examples    Array example   t := \u0026amp;testing.T{} got := [3]int{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \u0026#34;checks each item of array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedArray example   t := \u0026amp;testing.T{} type MyArray [3]int got := MyArray{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \u0026#34;checks each item of typed array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = td.CmpArrayEach(t, \u0026amp;got, td.Between(25, 60), \u0026#34;checks each item of typed array pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true       Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \u0026#34;checks each item of slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.CmpArrayEach(t, got, td.Between(25, 60), \u0026#34;checks each item of typed slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = td.CmpArrayEach(t, \u0026amp;got, td.Between(25, 60), \u0026#34;checks each item of typed slice pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nT.ArrayEach shortcut func (t *T) ArrayEach(got interface{}, expectedValue interface{}, args ...interface{}) bool ArrayEach is a shortcut for:\nt.Cmp(got, td.ArrayEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.ArrayEach godoc.\n Examples    Array example   t := td.NewT(\u0026amp;testing.T{}) got := [3]int{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \u0026#34;checks each item of array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedArray example   t := td.NewT(\u0026amp;testing.T{}) type MyArray [3]int got := MyArray{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \u0026#34;checks each item of typed array %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = t.ArrayEach(\u0026amp;got, td.Between(25, 60), \u0026#34;checks each item of typed array pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true       Slice example   t := td.NewT(\u0026amp;testing.T{}) got := []int{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \u0026#34;checks each item of slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedSlice example   t := td.NewT(\u0026amp;testing.T{}) type MySlice []int got := MySlice{42, 58, 26} ok := t.ArrayEach(got, td.Between(25, 60), \u0026#34;checks each item of typed slice %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) ok = t.ArrayEach(\u0026amp;got, td.Between(25, 60), \u0026#34;checks each item of typed slice pointer %v is in [25 .. 60]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/bag/","title":"Bag","tags":[],"description":"","content":"func Bag(expectedItems ...interface{}) TestDeep Bag operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\ntd.Cmp(t, []int{1, 1, 2}, td.Bag(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(2, 1, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2)) // fails, one 1 is missing td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1, 3)) // fails, 3 is missing  // works with slices/arrays of any type td.Cmp(t, personSlice, td.Bag( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{1, 2, 1} td.Cmp(t, []int{1, 1, 2}, td.Bag(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1, 2}, td.Bag(1, 2, 1))  exp1 := []int{5, 1, 1} exp2 := []int{8, 42, 3} td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.Bag(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.Bag(5, 1, 1, 3, 8, 42, 3))  See also Bag godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present \tok := td.Cmp(t, got, td.Bag(1, 1, 2, 3, 5, 8, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these \t// duplicates are not expected \tok = td.Cmp(t, got, td.Bag(1, 2, 3, 5, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got \tok = td.Cmp(t, got, td.Bag(1, 1, 2, 3, 5, 8, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Matches as all items are present \tok = td.Cmp(t, got, td.Bag(1, 2, 3, 5, td.Gt(7)), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5} ok = td.Cmp(t, got, td.Bag(td.Flatten(expected), td.Gt(7)), \u0026#34;checks all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// false \t// true \t// true     CmpBag shortcut func CmpBag(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpBag is a shortcut for:\ntd.Cmp(t, got, td.Bag(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpBag godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present \tok := td.CmpBag(t, got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these \t// duplicates are not expected \tok = td.CmpBag(t, got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got \tok = td.CmpBag(t, got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Matches as all items are present \tok = td.CmpBag(t, got, []interface{}{1, 2, 3, 5, td.Gt(7)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5} ok = td.CmpBag(t, got, []interface{}{td.Flatten(expected), td.Gt(7)}, \u0026#34;checks all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// false \t// true \t// true     T.Bag shortcut func (t *T) Bag(got interface{}, expectedItems []interface{}, args ...interface{}) bool Bag is a shortcut for:\nt.Cmp(got, td.Bag(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Bag godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present \tok := t.Bag(got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Does not match as got contains 2 times 1 and 8, and these \t// duplicates are not expected \tok = t.Bag(got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 8, 2} // Duplicates of 1 and 8 are expected but not present in got \tok = t.Bag(got, []interface{}{1, 1, 2, 3, 5, 8, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Matches as all items are present \tok = t.Bag(got, []interface{}{1, 2, 3, 5, td.Gt(7)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5} ok = t.Bag(got, []interface{}{td.Flatten(expected), td.Gt(7)}, \u0026#34;checks all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// false \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/between/","title":"Between","tags":[],"description":"","content":"func Between(from interface{}, to interface{}, bounds ...BoundsKind) TestDeep Between operator checks that data is between from and to. from and to can be any numeric, string or time.Time (or assignable) value. from and to must be the same kind as the compared value if numeric, and the same type if string or time.Time (or assignable). bounds allows to specify whether bounds are included or not:\n BoundsInIn (default): between from and to both included BoundsInOut: between from included and to excluded BoundsOutIn: between from excluded and to included BoundsOutOut: between from and to both excluded  If bounds is missing, it defaults to BoundsInIn.\ntc.Cmp(t, 17, td.Between(17, 20)) // succeeds, BoundsInIn by default tc.Cmp(t, 17, td.Between(10, 17, BoundsInOut)) // fails tc.Cmp(t, 17, td.Between(10, 17, BoundsOutIn)) // succeeds tc.Cmp(t, 17, td.Between(17, 20, BoundsOutOut)) // fails TypeBehind method returns the reflect.Type of from (same as the to one.)\n See also Between godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.Cmp(t, got, td.Between(154, 156), \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) // BoundsInIn is implicit \tok = td.Cmp(t, got, td.Between(154, 156, td.BoundsInIn), \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsInOut), \u0026#34;checks %v is in [154 .. 156[\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsOutIn), \u0026#34;checks %v is in ]154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(154, 156, td.BoundsOutOut), \u0026#34;checks %v is in ]154 .. 156[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.Cmp(t, got, td.Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) // BoundsInIn is implicit \tok = td.Cmp(t, got, td.Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInIn), `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInOut), `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsOutIn), `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Between(\u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsOutOut), `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false    \nCmpBetween shortcut func CmpBetween(t TestingT, got interface{}, from interface{}, to interface{}, bounds BoundsKind, args ...interface{}) bool CmpBetween is a shortcut for:\ntd.Cmp(t, got, td.Between(from, to, bounds), args...) See above for details.\nBetween() optional parameter bounds is here mandatory. td.BoundsInIn value should be passed to mimic its absence in original Between() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpBetween godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.CmpBetween(t, got, 154, 156, td.BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) // BoundsInIn is implicit \tok = td.CmpBetween(t, got, 154, 156, td.BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = td.CmpBetween(t, got, 154, 156, td.BoundsInOut, \u0026#34;checks %v is in [154 .. 156[\u0026#34;, got) fmt.Println(ok) ok = td.CmpBetween(t, got, 154, 156, td.BoundsOutIn, \u0026#34;checks %v is in ]154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = td.CmpBetween(t, got, 154, 156, td.BoundsOutOut, \u0026#34;checks %v is in ]154 .. 156[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) // BoundsInIn is implicit \tok = td.CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = td.CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInOut, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) ok = td.CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsOutIn, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = td.CmpBetween(t, got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsOutOut, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false    \nT.Between shortcut func (t *T) Between(got interface{}, from interface{}, to interface{}, bounds BoundsKind, args ...interface{}) bool Between is a shortcut for:\nt.Cmp(got, td.Between(from, to, bounds), args...) See above for details.\nBetween() optional parameter bounds is here mandatory. td.BoundsInIn value should be passed to mimic its absence in original Between() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Between godoc.\n Examples    Int example   t := td.NewT(\u0026amp;testing.T{}) got := 156 ok := t.Between(got, 154, 156, td.BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) // BoundsInIn is implicit \tok = t.Between(got, 154, 156, td.BoundsInIn, \u0026#34;checks %v is in [154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = t.Between(got, 154, 156, td.BoundsInOut, \u0026#34;checks %v is in [154 .. 156[\u0026#34;, got) fmt.Println(ok) ok = t.Between(got, 154, 156, td.BoundsOutIn, \u0026#34;checks %v is in ]154 .. 156]\u0026#34;, got) fmt.Println(ok) ok = t.Between(got, 154, 156, td.BoundsOutOut, \u0026#34;checks %v is in ]154 .. 156[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false       String example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) // BoundsInIn is implicit \tok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInIn, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsInOut, `checks \u0026#34;%v\u0026#34; is in [\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) ok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsOutIn, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;]`, got) fmt.Println(ok) ok = t.Between(got, \u0026#34;aaa\u0026#34;, \u0026#34;abc\u0026#34;, td.BoundsOutOut, `checks \u0026#34;%v\u0026#34; is in ]\u0026#34;aaa\u0026#34; .. \u0026#34;abc\u0026#34;[`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/cap/","title":"Cap","tags":[],"description":"","content":"func Cap(expectedCap interface{}) TestDeep Cap is a smuggler operator. It takes data, applies cap() function on it and compares its result to expectedCap. Of course, the compared value must be an array, a channel or a slice.\nexpectedCap can be an int value:\ntd.Cmp(t, gotSlice, td.Cap(12)) as well as an other operator:\ntd.Cmp(t, gotSlice, td.Cap(td.Between(3, 4)))  See also Cap godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(12), \u0026#34;checks %v capacity is 12\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(0), \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Cap(0), \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       Operator example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := td.Cmp(t, got, td.Cap(td.Between(10, 12)), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Cap(td.Gt(10)), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nCmpCap shortcut func CmpCap(t TestingT, got interface{}, expectedCap interface{}, args ...interface{}) bool CmpCap is a shortcut for:\ntd.Cmp(t, got, td.Cap(expectedCap), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpCap godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := td.CmpCap(t, got, 12, \u0026#34;checks %v capacity is 12\u0026#34;, got) fmt.Println(ok) ok = td.CmpCap(t, got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = td.CmpCap(t, got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       Operator example   t := \u0026amp;testing.T{} got := make([]int, 0, 12) ok := td.CmpCap(t, got, td.Between(10, 12), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) ok = td.CmpCap(t, got, td.Gt(10), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nT.Cap shortcut func (t *T) Cap(got interface{}, expectedCap interface{}, args ...interface{}) bool Cap is a shortcut for:\nt.Cmp(got, td.Cap(expectedCap), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Cap godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) got := make([]int, 0, 12) ok := t.Cap(got, 12, \u0026#34;checks %v capacity is 12\u0026#34;, got) fmt.Println(ok) ok = t.Cap(got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = t.Cap(got, 0, \u0026#34;checks %v capacity is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       Operator example   t := td.NewT(\u0026amp;testing.T{}) got := make([]int, 0, 12) ok := t.Cap(got, td.Between(10, 12), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) ok = t.Cap(got, td.Gt(10), \u0026#34;checks %v capacity is in [10 .. 12]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/catch/","title":"Catch","tags":[],"description":"","content":"func Catch(target interface{}, expectedValue interface{}) TestDeep Catch is a smuggler operator. It allows to copy data in target on the fly before comparing it as usual against expectedValue.\ntarget must be a non-nil pointer and data should be assignable to its pointed type. If BeLax config flag is true or called under Lax (and so JSON) operator, data should be convertible to its pointer type.\nvar id int64 if td.Cmp(t, CreateRecord(\u0026#34;test\u0026#34;), td.JSON(`{\u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;}`, td.Catch(\u0026amp;id, td.NotZero()))) { t.Logf(\u0026#34;Created record ID is %d\u0026#34;, id) } It is really useful when used with JSON operator and/or tdhttp helper.\nvar id int64 ta := tdhttp.NewTestAPI(t, api.Handler). PostJSON(\u0026#34;/item\u0026#34;, `{\u0026#34;name\u0026#34;:\u0026#34;foo\u0026#34;}`). CmpStatus(http.StatusCreated). CmpJSONBody(td.JSON(`{\u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;}`, td.Catch(\u0026amp;id, td.Gt(0)))) if !ta.Failed() { t.Logf(\u0026#34;Created record ID is %d\u0026#34;, id) } If you need to only catch data without comparing it, use Ignore operator as expectedValue as in:\nvar id int64 if td.Cmp(t, CreateRecord(\u0026#34;test\u0026#34;), td.JSON(`{\u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;}`, td.Catch(\u0026amp;id, td.Ignore()))) { t.Logf(\u0026#34;Created record ID is %d\u0026#34;, id) }  See also Catch godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } var age int ok := td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;:$1,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, td.Catch(\u0026amp;age, td.Between(40, 45)))) fmt.Println(\u0026#34;check got age+fullname:\u0026#34;, ok) fmt.Println(\u0026#34;caught age:\u0026#34;, age) // Output: \t// check got age+fullname: true \t// caught age: 42     "},{"uri":"https://go-testdeep.zetta.rocks/operators/code/","title":"Code","tags":[],"description":"","content":"func Code(fn interface{}) TestDeep Code operator allows to check data using a custom function. So fn is a function that must take one parameter whose type must be the same as the type of the compared value.\nfn can return a single bool kind value, telling that yes or no the custom test is successful:\ntd.Cmp(t, gotTime, td.Code(func(date time.Time) bool { return date.Year() == 2018 })) or two values (bool, string) kinds. The bool value has the same meaning as above, and the string value is used to describe the test when it fails:\ntd.Cmp(t, gotTime, td.Code(func(date time.Time) (bool, string) { if date.Year() == 2018 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;year must be 2018\u0026#34; })) or a single error value. If the returned error is nil, the test succeeded, else the error contains the reason of failure:\ntd.Cmp(t, gotJsonRawMesg, td.Code(func(b json.RawMessage) error { var c map[string]int err := json.Unmarshal(b, \u0026amp;c) if err != nil { return err } if c[\u0026#34;test\u0026#34;] != 42 { return fmt.Errorf(`key \u0026#34;test\u0026#34; does not match 42`) } return nil })) This operator allows to handle any specific comparison not handled by standard operators.\nIt is not recommended to call Cmp (or any other Cmp* functions or *T methods) inside the body of *fn*, because of confusion produced by output in case of failure. When the data needs to be transformed before being compared again, Smuggle operator should be used instead.\nTypeBehind method returns the reflect.Type of only parameter of fn.\n See also Code godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026#34;12\u0026#34; ok := td.Cmp(t, got, td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }), \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason \tok = td.Cmp(t, got, td.Code(func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \u0026#34;not a number\u0026#34; } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;not in ]10 .. 100[\u0026#34; }), \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason thanks to error \tok = td.Cmp(t, got, td.Code(func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return nil } return fmt.Errorf(\u0026#34;%d not in ]10 .. 100[\u0026#34;, n) }), \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     CmpCode shortcut func CmpCode(t TestingT, got interface{}, fn interface{}, args ...interface{}) bool CmpCode is a shortcut for:\ntd.Cmp(t, got, td.Code(fn), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpCode godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := \u0026#34;12\u0026#34; ok := td.CmpCode(t, got, func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason \tok = td.CmpCode(t, got, func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \u0026#34;not a number\u0026#34; } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;not in ]10 .. 100[\u0026#34; }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason thanks to error \tok = td.CmpCode(t, got, func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return nil } return fmt.Errorf(\u0026#34;%d not in ]10 .. 100[\u0026#34;, n) }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     T.Code shortcut func (t *T) Code(got interface{}, fn interface{}, args ...interface{}) bool Code is a shortcut for:\nt.Cmp(got, td.Code(fn), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Code godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;12\u0026#34; ok := t.Code(got, func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason \tok = t.Code(got, func(num string) (bool, string) { n, err := strconv.Atoi(num) if err != nil { return false, \u0026#34;not a number\u0026#34; } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return true, \u0026#34;\u0026#34; } return false, \u0026#34;not in ]10 .. 100[\u0026#34; }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Same with failure reason thanks to error \tok = t.Code(got, func(num string) error { n, err := strconv.Atoi(num) if err != nil { return err } if n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 { return nil } return fmt.Errorf(\u0026#34;%d not in ]10 .. 100[\u0026#34;, n) }, \u0026#34;checks string `%s` contains a number and this number is in ]10 .. 100[\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/contains/","title":"Contains","tags":[],"description":"","content":"func Contains(expectedValue interface{}) TestDeep Contains is a smuggler operator to check if something is contained in another thing. Contains has to be applied on arrays, slices, maps or strings. It tries to be as smarter as possible.\nIf expectedValue is a TestDeep operator, each item of data array/slice/map/string (rune for strings) is compared to it. The use of a TestDeep operator as expectedValue works only in this way: item per item.\nIf data is a slice, and expectedValue has the same type, then expectedValue is searched as a sub-slice, otherwise expectedValue is compared to each slice value.\nlist := []int{12, 34, 28} td.Cmp(t, list, td.Contains(34)) // succeeds td.Cmp(t, list, td.Contains(td.Between(30, 35))) // succeeds too td.Cmp(t, list, td.Contains(35)) // fails td.Cmp(t, list, td.Contains([]int{34, 28})) // succeeds If data is an array or a map, each value is compared to expectedValue. Map keys are not checked: see ContainsKey to check map keys existence.\nhash := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 34, \u0026#34;zip\u0026#34;: 28} td.Cmp(t, hash, td.Contains(34)) // succeeds td.Cmp(t, hash, td.Contains(td.Between(30, 35))) // succeeds too td.Cmp(t, hash, td.Contains(35)) // fails  array := [...]int{12, 34, 28} td.Cmp(t, array, td.Contains(34)) // succeeds td.Cmp(t, array, td.Contains(td.Between(30, 35))) // succeeds too td.Cmp(t, array, td.Contains(35)) // fails If data is a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer), expectedValue can be a string, a []byte, a rune or a byte. In this case, it tests if the got string contains this expected string, []byte, rune or byte.\ngot := \u0026#34;foo bar\u0026#34; td.Cmp(t, got, td.Contains(\u0026#39;o\u0026#39;)) // succeeds td.Cmp(t, got, td.Contains(rune(\u0026#39;o\u0026#39;))) // succeeds td.Cmp(t, got, td.Contains(td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;))) // succeeds td.Cmp(t, got, td.Contains(\u0026#34;bar\u0026#34;)) // succeeds td.Cmp(t, got, td.Contains([]byte(\u0026#34;bar\u0026#34;))) // succeeds  td.Cmp(t, []byte(\u0026#34;foobar\u0026#34;), td.Contains(\u0026#34;ooba\u0026#34;)) // succeeds  type Foobar string td.Cmp(t, Foobar(\u0026#34;foobar\u0026#34;), td.Contains(\u0026#34;ooba\u0026#34;)) // succeeds  err := errors.New(\u0026#34;error!\u0026#34;) td.Cmp(t, err, td.Contains(\u0026#34;ror\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) td.Cmp(t, bstr, td.Contains(\u0026#34;String\u0026#34;)) // succeeds Pitfall: if you want to check if 2 words are contained in got, don\u0026rsquo;t do:\ntd.Cmp(t, \u0026#34;foobar\u0026#34;, td.Contains(td.All(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;))) // Bad! as TestDeep operator All in Contains operates on each rune, so it does not work as expected, but do::\ntd.Cmp(t, \u0026#34;foobar\u0026#34;, td.All(td.Contains(\u0026#34;foo\u0026#34;), td.Contains(\u0026#34;bar\u0026#34;))) When Contains(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the array/slice/map item type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):\nnum := 123 list := []*int{\u0026amp;num, nil} td.Cmp(t, list, td.Contains(nil)) // succeeds → (*int)(nil) td.Cmp(t, list, td.Contains((*int)(nil))) // succeeds td.Cmp(t, list, td.Contains(td.Nil())) // succeeds // But... td.Cmp(t, list, td.Contains((*byte)(nil))) // fails: (*byte)(nil) ≠ (*int)(nil) As well as these ones:\nhash := map[string]*int{\u0026#34;foo\u0026#34;: nil, \u0026#34;bar\u0026#34;: \u0026amp;num} td.Cmp(t, hash, td.Contains(nil)) // succeeds → (*int)(nil) td.Cmp(t, hash, td.Contains((*int)(nil))) // succeeds td.Cmp(t, hash, td.Contains(td.Nil())) // succeeds  See also Contains godoc.\n Examples    ArraySlice example   t := \u0026amp;testing.T{} ok := td.Cmp(t, [...]int{11, 22, 33, 44}, td.Contains(22)) fmt.Println(\u0026#34;array contains 22:\u0026#34;, ok) ok = td.Cmp(t, [...]int{11, 22, 33, 44}, td.Contains(td.Between(20, 25))) fmt.Println(\u0026#34;array contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = td.Cmp(t, []int{11, 22, 33, 44}, td.Contains(22)) fmt.Println(\u0026#34;slice contains 22:\u0026#34;, ok) ok = td.Cmp(t, []int{11, 22, 33, 44}, td.Contains(td.Between(20, 25))) fmt.Println(\u0026#34;slice contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = td.Cmp(t, []int{11, 22, 33, 44}, td.Contains([]int{22, 33})) fmt.Println(\u0026#34;slice contains the sub-slice [22, 33]:\u0026#34;, ok) // Output: \t// array contains 22: true \t// array contains at least one item in [20 .. 25]: true \t// slice contains 22: true \t// slice contains at least one item in [20 .. 25]: true \t// slice contains the sub-slice [22, 33]: true       Nil example   t := \u0026amp;testing.T{} num := 123 got := [...]*int{\u0026amp;num, nil} ok := td.Cmp(t, got, td.Contains(nil)) fmt.Println(\u0026#34;array contains untyped nil:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains((*int)(nil))) fmt.Println(\u0026#34;array contains *int nil:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(td.Nil())) fmt.Println(\u0026#34;array contains Nil():\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains((*byte)(nil))) fmt.Println(\u0026#34;array contains *byte nil:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// array contains untyped nil: true \t// array contains *int nil: true \t// array contains Nil(): true \t// array contains *byte nil: false       Map example   t := \u0026amp;testing.T{} ok := td.Cmp(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.Contains(22)) fmt.Println(\u0026#34;map contains value 22:\u0026#34;, ok) ok = td.Cmp(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.Contains(td.Between(20, 25))) fmt.Println(\u0026#34;map contains at least one value in [20 .. 25]:\u0026#34;, ok) // Output: \t// map contains value 22: true \t// map contains at least one value in [20 .. 25]: true       String example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.Cmp(t, got, td.Contains(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains([]byte(\u0026#34;oob\u0026#34;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` []byte:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(\u0026#39;b\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(byte(\u0026#39;a\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains `oob` []byte: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.Contains(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(\u0026#39;b\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(byte(\u0026#39;a\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.Contains(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(\u0026#39;b\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(byte(\u0026#39;a\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = td.Cmp(t, got, td.Contains(td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;)), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true    \nCmpContains shortcut func CmpContains(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpContains is a shortcut for:\ntd.Cmp(t, got, td.Contains(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpContains godoc.\n Examples    ArraySlice example   t := \u0026amp;testing.T{} ok := td.CmpContains(t, [...]int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;array contains 22:\u0026#34;, ok) ok = td.CmpContains(t, [...]int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\u0026#34;array contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = td.CmpContains(t, []int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;slice contains 22:\u0026#34;, ok) ok = td.CmpContains(t, []int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\u0026#34;slice contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = td.CmpContains(t, []int{11, 22, 33, 44}, []int{22, 33}) fmt.Println(\u0026#34;slice contains the sub-slice [22, 33]:\u0026#34;, ok) // Output: \t// array contains 22: true \t// array contains at least one item in [20 .. 25]: true \t// slice contains 22: true \t// slice contains at least one item in [20 .. 25]: true \t// slice contains the sub-slice [22, 33]: true       Nil example   t := \u0026amp;testing.T{} num := 123 got := [...]*int{\u0026amp;num, nil} ok := td.CmpContains(t, got, nil) fmt.Println(\u0026#34;array contains untyped nil:\u0026#34;, ok) ok = td.CmpContains(t, got, (*int)(nil)) fmt.Println(\u0026#34;array contains *int nil:\u0026#34;, ok) ok = td.CmpContains(t, got, td.Nil()) fmt.Println(\u0026#34;array contains Nil():\u0026#34;, ok) ok = td.CmpContains(t, got, (*byte)(nil)) fmt.Println(\u0026#34;array contains *byte nil:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// array contains untyped nil: true \t// array contains *int nil: true \t// array contains Nil(): true \t// array contains *byte nil: false       Map example   t := \u0026amp;testing.T{} ok := td.CmpContains(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, 22) fmt.Println(\u0026#34;map contains value 22:\u0026#34;, ok) ok = td.CmpContains(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.Between(20, 25)) fmt.Println(\u0026#34;map contains at least one value in [20 .. 25]:\u0026#34;, ok) // Output: \t// map contains value 22: true \t// map contains at least one value in [20 .. 25]: true       String example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.CmpContains(t, got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = td.CmpContains(t, got, []byte(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` []byte:\u0026#34;, ok) ok = td.CmpContains(t, got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = td.CmpContains(t, got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = td.CmpContains(t, got, td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains `oob` []byte: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.CmpContains(t, got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = td.CmpContains(t, got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = td.CmpContains(t, got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = td.CmpContains(t, got, td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.CmpContains(t, got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = td.CmpContains(t, got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = td.CmpContains(t, got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = td.CmpContains(t, got, td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true    \nT.Contains shortcut func (t *T) Contains(got interface{}, expectedValue interface{}, args ...interface{}) bool Contains is a shortcut for:\nt.Cmp(got, td.Contains(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Contains godoc.\n Examples    ArraySlice example   t := td.NewT(\u0026amp;testing.T{}) ok := t.Contains([...]int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;array contains 22:\u0026#34;, ok) ok = t.Contains([...]int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\u0026#34;array contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = t.Contains([]int{11, 22, 33, 44}, 22) fmt.Println(\u0026#34;slice contains 22:\u0026#34;, ok) ok = t.Contains([]int{11, 22, 33, 44}, td.Between(20, 25)) fmt.Println(\u0026#34;slice contains at least one item in [20 .. 25]:\u0026#34;, ok) ok = t.Contains([]int{11, 22, 33, 44}, []int{22, 33}) fmt.Println(\u0026#34;slice contains the sub-slice [22, 33]:\u0026#34;, ok) // Output: \t// array contains 22: true \t// array contains at least one item in [20 .. 25]: true \t// slice contains 22: true \t// slice contains at least one item in [20 .. 25]: true \t// slice contains the sub-slice [22, 33]: true       Nil example   t := td.NewT(\u0026amp;testing.T{}) num := 123 got := [...]*int{\u0026amp;num, nil} ok := t.Contains(got, nil) fmt.Println(\u0026#34;array contains untyped nil:\u0026#34;, ok) ok = t.Contains(got, (*int)(nil)) fmt.Println(\u0026#34;array contains *int nil:\u0026#34;, ok) ok = t.Contains(got, td.Nil()) fmt.Println(\u0026#34;array contains Nil():\u0026#34;, ok) ok = t.Contains(got, (*byte)(nil)) fmt.Println(\u0026#34;array contains *byte nil:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// array contains untyped nil: true \t// array contains *int nil: true \t// array contains Nil(): true \t// array contains *byte nil: false       Map example   t := td.NewT(\u0026amp;testing.T{}) ok := t.Contains(map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, 22) fmt.Println(\u0026#34;map contains value 22:\u0026#34;, ok) ok = t.Contains(map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.Between(20, 25)) fmt.Println(\u0026#34;map contains at least one value in [20 .. 25]:\u0026#34;, ok) // Output: \t// map contains value 22: true \t// map contains at least one value in [20 .. 25]: true       String example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.Contains(got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = t.Contains(got, []byte(\u0026#34;oob\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` []byte:\u0026#34;, ok) ok = t.Contains(got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = t.Contains(got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = t.Contains(got, td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains `oob` []byte: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true       Stringer example   t := td.NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.Contains(got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = t.Contains(got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = t.Contains(got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = t.Contains(got, td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true       Error example   t := td.NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.Contains(got, \u0026#34;oob\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains `oob` string:\u0026#34;, ok) ok = t.Contains(got, \u0026#39;b\u0026#39;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;b\u0026#39; rune:\u0026#34;, ok) ok = t.Contains(got, byte(\u0026#39;a\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains \u0026#39;a\u0026#39; byte:\u0026#34;, ok) ok = t.Contains(got, td.Between(\u0026#39;n\u0026#39;, \u0026#39;p\u0026#39;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]:\u0026#34;, ok) // Output: \t// contains `oob` string: true \t// contains \u0026#39;b\u0026#39; rune: true \t// contains \u0026#39;a\u0026#39; byte: true \t// contains at least one character [\u0026#39;n\u0026#39; .. \u0026#39;p\u0026#39;]: true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/containskey/","title":"ContainsKey","tags":[],"description":"","content":"func ContainsKey(expectedValue interface{}) TestDeep ContainsKey is a smuggler operator and works on maps only. It compares each key of map against expectedValue.\nhash := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 34, \u0026#34;zip\u0026#34;: 28} td.Cmp(t, hash, td.ContainsKey(\u0026#34;foo\u0026#34;)) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix(\u0026#34;z\u0026#34;))) // succeeds td.Cmp(t, hash, td.ContainsKey(td.HasPrefix(\u0026#34;x\u0026#34;))) // fails  hnum := map[int]string{1: \u0026#34;foo\u0026#34;, 42: \u0026#34;bar\u0026#34;} td.Cmp(t, hash, td.ContainsKey(42)) // succeeds td.Cmp(t, hash, td.ContainsKey(td.Between(40, 45))) // succeeds When ContainsKey(nil) is used, nil is automatically converted to a typed nil on the fly to avoid confusion (if the map key type allows it of course.) So all following Cmp calls are equivalent (except the (*byte)(nil) one):\nnum := 123 hnum := map[*int]bool{\u0026amp;num: true, nil: true} td.Cmp(t, hnum, td.ContainsKey(nil)) // succeeds → (*int)(nil) td.Cmp(t, hnum, td.ContainsKey((*int)(nil))) // succeeds td.Cmp(t, hnum, td.ContainsKey(td.Nil())) // succeeds // But... td.Cmp(t, hnum, td.ContainsKey((*byte)(nil))) // fails: (*byte)(nil) ≠ (*int)(nil)  See also ContainsKey godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := td.Cmp(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.ContainsKey(\u0026#34;foo\u0026#34;)) fmt.Println(`map contains key \u0026#34;foo\u0026#34;:`, ok) ok = td.Cmp(t, map[int]bool{12: true, 24: false, 42: true, 51: false}, td.ContainsKey(td.Between(40, 50))) fmt.Println(\u0026#34;map contains at least a key in [40 .. 50]:\u0026#34;, ok) ok = td.Cmp(t, map[string]int{\u0026#34;FOO\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.ContainsKey(td.Smuggle(strings.ToLower, \u0026#34;foo\u0026#34;))) fmt.Println(`map contains key \u0026#34;foo\u0026#34; without taking case into account:`, ok) // Output: \t// map contains key \u0026#34;foo\u0026#34;: true \t// map contains at least a key in [40 .. 50]: true \t// map contains key \u0026#34;foo\u0026#34; without taking case into account: true       Nil example   t := \u0026amp;testing.T{} num := 1234 got := map[*int]bool{\u0026amp;num: false, nil: true} ok := td.Cmp(t, got, td.ContainsKey(nil)) fmt.Println(\u0026#34;map contains untyped nil key:\u0026#34;, ok) ok = td.Cmp(t, got, td.ContainsKey((*int)(nil))) fmt.Println(\u0026#34;map contains *int nil key:\u0026#34;, ok) ok = td.Cmp(t, got, td.ContainsKey(td.Nil())) fmt.Println(\u0026#34;map contains Nil() key:\u0026#34;, ok) ok = td.Cmp(t, got, td.ContainsKey((*byte)(nil))) fmt.Println(\u0026#34;map contains *byte nil key:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// map contains untyped nil key: true \t// map contains *int nil key: true \t// map contains Nil() key: true \t// map contains *byte nil key: false    \nCmpContainsKey shortcut func CmpContainsKey(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpContainsKey is a shortcut for:\ntd.Cmp(t, got, td.ContainsKey(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpContainsKey godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := td.CmpContainsKey(t, map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, \u0026#34;foo\u0026#34;) fmt.Println(`map contains key \u0026#34;foo\u0026#34;:`, ok) ok = td.CmpContainsKey(t, map[int]bool{12: true, 24: false, 42: true, 51: false}, td.Between(40, 50)) fmt.Println(\u0026#34;map contains at least a key in [40 .. 50]:\u0026#34;, ok) ok = td.CmpContainsKey(t, map[string]int{\u0026#34;FOO\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.Smuggle(strings.ToLower, \u0026#34;foo\u0026#34;)) fmt.Println(`map contains key \u0026#34;foo\u0026#34; without taking case into account:`, ok) // Output: \t// map contains key \u0026#34;foo\u0026#34;: true \t// map contains at least a key in [40 .. 50]: true \t// map contains key \u0026#34;foo\u0026#34; without taking case into account: true       Nil example   t := \u0026amp;testing.T{} num := 1234 got := map[*int]bool{\u0026amp;num: false, nil: true} ok := td.CmpContainsKey(t, got, nil) fmt.Println(\u0026#34;map contains untyped nil key:\u0026#34;, ok) ok = td.CmpContainsKey(t, got, (*int)(nil)) fmt.Println(\u0026#34;map contains *int nil key:\u0026#34;, ok) ok = td.CmpContainsKey(t, got, td.Nil()) fmt.Println(\u0026#34;map contains Nil() key:\u0026#34;, ok) ok = td.CmpContainsKey(t, got, (*byte)(nil)) fmt.Println(\u0026#34;map contains *byte nil key:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// map contains untyped nil key: true \t// map contains *int nil key: true \t// map contains Nil() key: true \t// map contains *byte nil key: false    \nT.ContainsKey shortcut func (t *T) ContainsKey(got interface{}, expectedValue interface{}, args ...interface{}) bool ContainsKey is a shortcut for:\nt.Cmp(got, td.ContainsKey(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.ContainsKey godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) ok := t.ContainsKey(map[string]int{\u0026#34;foo\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, \u0026#34;foo\u0026#34;) fmt.Println(`map contains key \u0026#34;foo\u0026#34;:`, ok) ok = t.ContainsKey(map[int]bool{12: true, 24: false, 42: true, 51: false}, td.Between(40, 50)) fmt.Println(\u0026#34;map contains at least a key in [40 .. 50]:\u0026#34;, ok) ok = t.ContainsKey(map[string]int{\u0026#34;FOO\u0026#34;: 11, \u0026#34;bar\u0026#34;: 22, \u0026#34;zip\u0026#34;: 33}, td.Smuggle(strings.ToLower, \u0026#34;foo\u0026#34;)) fmt.Println(`map contains key \u0026#34;foo\u0026#34; without taking case into account:`, ok) // Output: \t// map contains key \u0026#34;foo\u0026#34;: true \t// map contains at least a key in [40 .. 50]: true \t// map contains key \u0026#34;foo\u0026#34; without taking case into account: true       Nil example   t := td.NewT(\u0026amp;testing.T{}) num := 1234 got := map[*int]bool{\u0026amp;num: false, nil: true} ok := t.ContainsKey(got, nil) fmt.Println(\u0026#34;map contains untyped nil key:\u0026#34;, ok) ok = t.ContainsKey(got, (*int)(nil)) fmt.Println(\u0026#34;map contains *int nil key:\u0026#34;, ok) ok = t.ContainsKey(got, td.Nil()) fmt.Println(\u0026#34;map contains Nil() key:\u0026#34;, ok) ok = t.ContainsKey(got, (*byte)(nil)) fmt.Println(\u0026#34;map contains *byte nil key:\u0026#34;, ok) // types differ: *byte ≠ *int  // Output: \t// map contains untyped nil key: true \t// map contains *int nil key: true \t// map contains Nil() key: true \t// map contains *byte nil key: false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/delay/","title":"Delay","tags":[],"description":"","content":"func Delay(delayed func() TestDeep) TestDeep Delay operator allows to delay the construction of an operator to the time it is used for the first time. Most of the time, it is used with helpers. See the example for a very simple use case.\n See also Delay godoc.\n Example   Base example   t := \u0026amp;testing.T{} cmpNow := func(expected td.TestDeep) bool { time.Sleep(time.Microsecond) // imagine a DB insert returning a CreatedAt \treturn td.Cmp(t, time.Now(), expected) } before := time.Now() ok := cmpNow(td.Between(before, time.Now())) fmt.Println(\u0026#34;Between called before compare:\u0026#34;, ok) ok = cmpNow(td.Delay(func() td.TestDeep { return td.Between(before, time.Now()) })) fmt.Println(\u0026#34;Between delayed until compare:\u0026#34;, ok) // Output: \t// Between called before compare: false \t// Between delayed until compare: true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/empty/","title":"Empty","tags":[],"description":"","content":"func Empty() TestDeep Empty operator checks that an array, a channel, a map, a slice or a string is empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\ntd.Cmp(t, \u0026#34;\u0026#34;, td.Empty()) // succeeds td.Cmp(t, map[string]bool{}, td.Empty()) // succeeds td.Cmp(t, []string{\u0026#34;foo\u0026#34;}, td.Empty()) // fails  See also Empty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := td.Cmp(t, nil, td.Empty()) // special case: nil is considered empty \tfmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or \t// pointers on array, channel, map slice and strings) \tok = td.Cmp(t, (*int)(nil), td.Empty()) fmt.Println(ok) ok = td.Cmp(t, \u0026#34;\u0026#34;, td.Empty()) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead \tok = td.Cmp(t, 0, td.Empty()) fmt.Println(ok) ok = td.Cmp(t, (map[string]int)(nil), td.Empty()) fmt.Println(ok) ok = td.Cmp(t, map[string]int{}, td.Empty()) fmt.Println(ok) ok = td.Cmp(t, ([]int)(nil), td.Empty()) fmt.Println(ok) ok = td.Cmp(t, []int{}, td.Empty()) fmt.Println(ok) ok = td.Cmp(t, []int{3}, td.Empty()) // fails, as not empty \tfmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.Empty()) // fails, Empty() is not Zero()! \tfmt.Println(ok) // Output: \t// true \t// false \t// true \t// false \t// true \t// true \t// true \t// true \t// false \t// false       Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := td.Cmp(t, MySlice{}, td.Empty()) // Ptr() not needed \tfmt.Println(ok) ok = td.Cmp(t, \u0026amp;MySlice{}, td.Empty()) fmt.Println(ok) l1 := \u0026amp;MySlice{} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = td.Cmp(t, \u0026amp;l3, td.Empty()) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = td.Cmp(t, \u0026amp;MyStruct{}, td.Empty()) // fails, use Zero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false    \nCmpEmpty shortcut func CmpEmpty(t TestingT, got interface{}, args ...interface{}) bool CmpEmpty is a shortcut for:\ntd.Cmp(t, got, td.Empty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpEmpty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := td.CmpEmpty(t, nil) // special case: nil is considered empty \tfmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or \t// pointers on array, channel, map slice and strings) \tok = td.CmpEmpty(t, (*int)(nil)) fmt.Println(ok) ok = td.CmpEmpty(t, \u0026#34;\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead \tok = td.CmpEmpty(t, 0) fmt.Println(ok) ok = td.CmpEmpty(t, (map[string]int)(nil)) fmt.Println(ok) ok = td.CmpEmpty(t, map[string]int{}) fmt.Println(ok) ok = td.CmpEmpty(t, ([]int)(nil)) fmt.Println(ok) ok = td.CmpEmpty(t, []int{}) fmt.Println(ok) ok = td.CmpEmpty(t, []int{3}) // fails, as not empty \tfmt.Println(ok) ok = td.CmpEmpty(t, [3]int{}) // fails, Empty() is not Zero()! \tfmt.Println(ok) // Output: \t// true \t// false \t// true \t// false \t// true \t// true \t// true \t// true \t// false \t// false       Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := td.CmpEmpty(t, MySlice{}) // Ptr() not needed \tfmt.Println(ok) ok = td.CmpEmpty(t, \u0026amp;MySlice{}) fmt.Println(ok) l1 := \u0026amp;MySlice{} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = td.CmpEmpty(t, \u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = td.CmpEmpty(t, \u0026amp;MyStruct{}) // fails, use Zero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false    \nT.Empty shortcut func (t *T) Empty(got interface{}, args ...interface{}) bool Empty is a shortcut for:\nt.Cmp(got, td.Empty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Empty godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) ok := t.Empty(nil) // special case: nil is considered empty \tfmt.Println(ok) // fails, typed nil is not empty (expect for channel, map, slice or \t// pointers on array, channel, map slice and strings) \tok = t.Empty((*int)(nil)) fmt.Println(ok) ok = t.Empty(\u0026#34;\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use Zero() instead \tok = t.Empty(0) fmt.Println(ok) ok = t.Empty((map[string]int)(nil)) fmt.Println(ok) ok = t.Empty(map[string]int{}) fmt.Println(ok) ok = t.Empty(([]int)(nil)) fmt.Println(ok) ok = t.Empty([]int{}) fmt.Println(ok) ok = t.Empty([]int{3}) // fails, as not empty \tfmt.Println(ok) ok = t.Empty([3]int{}) // fails, Empty() is not Zero()! \tfmt.Println(ok) // Output: \t// true \t// false \t// true \t// false \t// true \t// true \t// true \t// true \t// false \t// false       Pointers example   t := td.NewT(\u0026amp;testing.T{}) type MySlice []int ok := t.Empty(MySlice{}) // Ptr() not needed \tfmt.Println(ok) ok = t.Empty(\u0026amp;MySlice{}) fmt.Println(ok) l1 := \u0026amp;MySlice{} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = t.Empty(\u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = t.Empty(\u0026amp;MyStruct{}) // fails, use Zero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/gt/","title":"Gt","tags":[],"description":"","content":"func Gt(minExpectedValue interface{}) TestDeep Gt operator checks that data is greater than minExpectedValue. minExpectedValue can be any numeric or time.Time (or assignable) value. minExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\ntd.Cmp(t, 17, td.Gt(15)) before := time.Now() td.Cmp(t, time.Now(), td.Gt(before)) TypeBehind method returns the reflect.Type of minExpectedValue.\n See also Gt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.Cmp(t, got, td.Gt(155), \u0026#34;checks %v is \u0026gt; 155\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gt(156), \u0026#34;checks %v is \u0026gt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.Cmp(t, got, td.Gt(\u0026#34;abb\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gt(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false    \nCmpGt shortcut func CmpGt(t TestingT, got interface{}, minExpectedValue interface{}, args ...interface{}) bool CmpGt is a shortcut for:\ntd.Cmp(t, got, td.Gt(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpGt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.CmpGt(t, got, 155, \u0026#34;checks %v is \u0026gt; 155\u0026#34;, got) fmt.Println(ok) ok = td.CmpGt(t, got, 156, \u0026#34;checks %v is \u0026gt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.CmpGt(t, got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = td.CmpGt(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false    \nT.Gt shortcut func (t *T) Gt(got interface{}, minExpectedValue interface{}, args ...interface{}) bool Gt is a shortcut for:\nt.Cmp(got, td.Gt(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Gt godoc.\n Examples    Int example   t := td.NewT(\u0026amp;testing.T{}) got := 156 ok := t.Gt(got, 155, \u0026#34;checks %v is \u0026gt; 155\u0026#34;, got) fmt.Println(ok) ok = t.Gt(got, 156, \u0026#34;checks %v is \u0026gt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       String example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Gt(got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = t.Gt(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026gt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/gte/","title":"Gte","tags":[],"description":"","content":"func Gte(minExpectedValue interface{}) TestDeep Gte operator checks that data is greater or equal than minExpectedValue. minExpectedValue can be any numeric or time.Time (or assignable) value. minExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\ntd.Cmp(t, 17, td.Gte(17)) before := time.Now() td.Cmp(t, time.Now(), td.Gte(before)) TypeBehind method returns the reflect.Type of minExpectedValue.\n See also Gte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.Cmp(t, got, td.Gte(156), \u0026#34;checks %v is ≥ 156\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(155), \u0026#34;checks %v is ≥ 155\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(157), \u0026#34;checks %v is ≥ 157\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.Cmp(t, got, td.Gte(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(\u0026#34;abb\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Gte(\u0026#34;abd\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false    \nCmpGte shortcut func CmpGte(t TestingT, got interface{}, minExpectedValue interface{}, args ...interface{}) bool CmpGte is a shortcut for:\ntd.Cmp(t, got, td.Gte(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpGte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.CmpGte(t, got, 156, \u0026#34;checks %v is ≥ 156\u0026#34;, got) fmt.Println(ok) ok = td.CmpGte(t, got, 155, \u0026#34;checks %v is ≥ 155\u0026#34;, got) fmt.Println(ok) ok = td.CmpGte(t, got, 157, \u0026#34;checks %v is ≥ 157\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.CmpGte(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = td.CmpGte(t, got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = td.CmpGte(t, got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false    \nT.Gte shortcut func (t *T) Gte(got interface{}, minExpectedValue interface{}, args ...interface{}) bool Gte is a shortcut for:\nt.Cmp(got, td.Gte(minExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Gte godoc.\n Examples    Int example   t := td.NewT(\u0026amp;testing.T{}) got := 156 ok := t.Gte(got, 156, \u0026#34;checks %v is ≥ 156\u0026#34;, got) fmt.Println(ok) ok = t.Gte(got, 155, \u0026#34;checks %v is ≥ 155\u0026#34;, got) fmt.Println(ok) ok = t.Gte(got, 157, \u0026#34;checks %v is ≥ 157\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false       String example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Gte(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = t.Gte(got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) ok = t.Gte(got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≥ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/hasprefix/","title":"HasPrefix","tags":[],"description":"","content":"func HasPrefix(expected string) TestDeep HasPrefix operator allows to compare the prefix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\ntd.Cmp(t, []byte(\u0026#34;foobar\u0026#34;), td.HasPrefix(\u0026#34;foo\u0026#34;)) // succeeds  type Foobar string td.Cmp(t, Foobar(\u0026#34;foobar\u0026#34;), td.HasPrefix(\u0026#34;foo\u0026#34;)) // succeeds  err := errors.New(\u0026#34;error!\u0026#34;) td.Cmp(t, err, td.HasPrefix(\u0026#34;err\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) td.Cmp(t, bstr, td.HasPrefix(\u0026#34;fmt\u0026#34;)) // succeeds  See also HasPrefix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.Cmp(t, got, td.HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = td.Cmp(t, []byte(got), td.HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \nCmpHasPrefix shortcut func CmpHasPrefix(t TestingT, got interface{}, expected string, args ...interface{}) bool CmpHasPrefix is a shortcut for:\ntd.Cmp(t, got, td.HasPrefix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpHasPrefix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.CmpHasPrefix(t, got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = td.Cmp(t, []byte(got), td.HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.CmpHasPrefix(t, got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.CmpHasPrefix(t, got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \nT.HasPrefix shortcut func (t *T) HasPrefix(got interface{}, expected string, args ...interface{}) bool HasPrefix is a shortcut for:\nt.Cmp(got, td.HasPrefix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.HasPrefix godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.HasPrefix(got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = t.Cmp([]byte(got), td.HasPrefix(\u0026#34;foo\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := td.NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.HasPrefix(got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := td.NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.HasPrefix(got, \u0026#34;foo\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/hassuffix/","title":"HasSuffix","tags":[],"description":"","content":"func HasSuffix(expected string) TestDeep HasSuffix operator allows to compare the suffix of a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\ntd.Cmp(t, []byte(\u0026#34;foobar\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;)) // succeeds  type Foobar string td.Cmp(t, Foobar(\u0026#34;foobar\u0026#34;), td.HasSuffix(\u0026#34;bar\u0026#34;)) // succeeds  err := errors.New(\u0026#34;error!\u0026#34;) td.Cmp(t, err, td.HasSuffix(\u0026#34;!\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) td.Cmp(t, bstr, td.HasSuffix(\u0026#34;!\u0026#34;)) // succeeds  See also HasSuffix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.Cmp(t, got, td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = td.Cmp(t, []byte(got), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \nCmpHasSuffix shortcut func CmpHasSuffix(t TestingT, got interface{}, expected string, args ...interface{}) bool CmpHasSuffix is a shortcut for:\ntd.Cmp(t, got, td.HasSuffix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpHasSuffix godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.CmpHasSuffix(t, got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = td.Cmp(t, []byte(got), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.CmpHasSuffix(t, got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.CmpHasSuffix(t, got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \nT.HasSuffix shortcut func (t *T) HasSuffix(got interface{}, expected string, args ...interface{}) bool HasSuffix is a shortcut for:\nt.Cmp(got, td.HasSuffix(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.HasSuffix godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.HasSuffix(got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = t.Cmp([]byte(got), td.HasSuffix(\u0026#34;bar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := td.NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.HasSuffix(got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := td.NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.HasSuffix(got, \u0026#34;bar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/ignore/","title":"Ignore","tags":[],"description":"","content":"func Ignore() TestDeep Ignore operator is always true, whatever data is. It is useful when comparing a slice with Slice and wanting to ignore some indexes, for example. Or comparing a struct with SStruct and wanting to ignore some fields:\ntd.Cmp(t, td.SStruct( Person{ Name: \u0026#34;John Doe\u0026#34;, }, td.StructFields{ Age: td.Between(40, 45), Children: td.Ignore(), }), )  See also Ignore godoc.\n Example   Base example   t := \u0026amp;testing.T{} ok := td.Cmp(t, []int{1, 2, 3}, td.Slice([]int{}, td.ArrayEntries{ 0: 1, 1: td.Ignore(), // do not care about this entry \t2: 3, })) fmt.Println(ok) // Output: \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/isa/","title":"Isa","tags":[],"description":"","content":"func Isa(model interface{}) TestDeep Isa operator checks the data type or whether data implements an interface or not.\nTypical type checks:\ntd.Cmp(t, time.Now(), td.Isa(time.Time{})) // succeeds td.Cmp(t, time.Now(), td.Isa(\u0026amp;time.Time{})) // fails, as not a *time.Time td.Cmp(t, got, td.Isa(map[string]time.Time{})) For interfaces, it is a bit more complicated, as:\nfmt.Stringer(nil) is not an interface, but just nil… To bypass this golang limitation, Isa accepts pointers on interfaces. So checking that data implements fmt.Stringer interface should be written as:\ntd.Cmp(t, bytes.Buffer{}, td.Isa((*fmt.Stringer)(nil))) // succeeds Of course, in the latter case, if checked data type is *fmt.Stringer, Isa will match too (in fact before checking whether it implements fmt.Stringer or not).\nTypeBehind method returns the reflect.Type of model.\n See also Isa godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := td.Cmp(t, got, td.Isa(TstStruct{}), \u0026#34;checks got is a TstStruct\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, got, td.Isa(\u0026amp;TstStruct{}), \u0026#34;checks got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Isa(\u0026amp;TstStruct{}), \u0026#34;checks \u0026amp;got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true       Interface example   t := \u0026amp;testing.T{} got := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.Isa((*fmt.Stringer)(nil)), \u0026#34;checks got implements fmt.Stringer interface\u0026#34;) fmt.Println(ok) errGot := fmt.Errorf(\u0026#34;An error #%d occurred\u0026#34;, 123) ok = td.Cmp(t, errGot, td.Isa((*error)(nil)), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // As nil, is passed below, it is not an interface but nil… So it \t// does not match \terrGot = nil ok = td.Cmp(t, errGot, td.Isa((*error)(nil)), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match \tok = td.Cmp(t, \u0026amp;errGot, td.Isa((*error)(nil)), \u0026#34;checks \u0026amp;errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true    \nCmpIsa shortcut func CmpIsa(t TestingT, got interface{}, model interface{}, args ...interface{}) bool CmpIsa is a shortcut for:\ntd.Cmp(t, got, td.Isa(model), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpIsa godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := td.CmpIsa(t, got, TstStruct{}, \u0026#34;checks got is a TstStruct\u0026#34;) fmt.Println(ok) ok = td.CmpIsa(t, got, \u0026amp;TstStruct{}, \u0026#34;checks got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) ok = td.CmpIsa(t, \u0026amp;got, \u0026amp;TstStruct{}, \u0026#34;checks \u0026amp;got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true       Interface example   t := \u0026amp;testing.T{} got := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.CmpIsa(t, got, (*fmt.Stringer)(nil), \u0026#34;checks got implements fmt.Stringer interface\u0026#34;) fmt.Println(ok) errGot := fmt.Errorf(\u0026#34;An error #%d occurred\u0026#34;, 123) ok = td.CmpIsa(t, errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // As nil, is passed below, it is not an interface but nil… So it \t// does not match \terrGot = nil ok = td.CmpIsa(t, errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match \tok = td.CmpIsa(t, \u0026amp;errGot, (*error)(nil), \u0026#34;checks \u0026amp;errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true    \nT.Isa shortcut func (t *T) Isa(got interface{}, model interface{}, args ...interface{}) bool Isa is a shortcut for:\nt.Cmp(got, td.Isa(model), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Isa godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) type TstStruct struct { Field int } got := TstStruct{Field: 1} ok := t.Isa(got, TstStruct{}, \u0026#34;checks got is a TstStruct\u0026#34;) fmt.Println(ok) ok = t.Isa(got, \u0026amp;TstStruct{}, \u0026#34;checks got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) ok = t.Isa(\u0026amp;got, \u0026amp;TstStruct{}, \u0026#34;checks \u0026amp;got is a pointer on a TstStruct\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true       Interface example   t := td.NewT(\u0026amp;testing.T{}) got := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.Isa(got, (*fmt.Stringer)(nil), \u0026#34;checks got implements fmt.Stringer interface\u0026#34;) fmt.Println(ok) errGot := fmt.Errorf(\u0026#34;An error #%d occurred\u0026#34;, 123) ok = t.Isa(errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // As nil, is passed below, it is not an interface but nil… So it \t// does not match \terrGot = nil ok = t.Isa(errGot, (*error)(nil), \u0026#34;checks errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // BUT if its address is passed, now it is OK as the types match \tok = t.Isa(\u0026amp;errGot, (*error)(nil), \u0026#34;checks \u0026amp;errGot is a *error or implements error interface\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/json/","title":"JSON","tags":[],"description":"","content":"func JSON(expectedJSON interface{}, params ...interface{}) TestDeep JSON operator allows to compare the JSON representation of data against expectedJSON. expectedJSON can be a:\n string containing JSON data like {\u0026quot;fullname\u0026quot;:\u0026quot;Bob\u0026quot;,\u0026quot;age\u0026quot;:42} string containing a JSON filename, ending with \u0026ldquo;.json\u0026rdquo; (its content is ioutil.ReadFile before unmarshaling) []byte containing JSON data io.Reader stream containing JSON data (is ioutil.ReadAll before unmarshaling)  expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n\u0026rsquo;th \u0026ldquo;operators\u0026rdquo; item (starting at 1). Named placeholders are used with Tag operator as follows:\ntd.Cmp(t, gotValue, td.JSON(`{\u0026#34;fullname\u0026#34;: $name, \u0026#34;age\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 Note that placeholders can be double-quoted as in:\ntd.Cmp(t, gotValue, td.JSON(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a \u0026ldquo;.json\u0026rdquo; file.\nNote expectedJSON can be a []byte, JSON filename or io.Reader:\ntd.Cmp(t, gotValue, td.JSON(\u0026#34;file.json\u0026#34;, td.Between(12, 34))) td.Cmp(t, gotValue, td.JSON([]byte(`[1, $1, 3]`), td.Between(12, 34))) td.Cmp(t, gotValue, td.JSON(osFile, td.Between(12, 34))) A JSON filename ends with \u0026ldquo;.json\u0026rdquo;.\nTo avoid a legit \u0026ldquo;$\u0026rdquo; string prefix causes a bad placeholder error, just double it to escape it. Note it is only needed when the \u0026ldquo;$\u0026rdquo; is the first character of a string:\ntd.Cmp(t, gotValue, td.JSON(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, \u0026#34;age\u0026#34;: $2}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43))) // matches only $2 For the \u0026ldquo;details\u0026rdquo; key, the raw value \u0026ldquo;$info\u0026rdquo; is expected, no placeholders are involved here.\nNote that Lax mode is automatically enabled by JSON operator to simplify numeric tests.\nComments can be embedded in JSON data:\ntd.Cmp(t, gotValue, td.JSON(` { // A guy properties: \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, // The full name of the guy \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, // Literally \u0026#34;$info\u0026#34;, thanks to \u0026#34;$\u0026#34; escape \u0026#34;age\u0026#34;: $2 /* The age of the guy: - placeholder unquoted, but could be without any change - to demonstrate a multi-lines comment */ }`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43))) // matches only $2 Comments, like in go, have 2 forms. To quote the Go language specification:\n line comments start with the character sequence // and stop at the end of the line. multi-lines comments start with the character sequence /* and stop with the first subsequent character sequence */.  Last but not least, simple operators can be directly embedded in JSON data without requiring any placeholder but using directly $^OperatorName. They are operator shortcuts:\ntd.Cmp(t, gotValue, td.JSON(`{\u0026#34;id\u0026#34;: $1}`, td.NotZero())) can be written as:\ntd.Cmp(t, gotValue, td.JSON(`{\u0026#34;id\u0026#34;: $^NotZero}`)) Unfortunately, only simple operators (in fact those which take no parameters) have shortcuts. They follow:\n Empty → $^Empty Ignore → $^Ignore NaN → $^NaN Nil → $^Nil NotEmpty → $^NotEmpty NotNaN → $^NotNaN NotNil → $^NotNil NotZero → $^NotZero Zero → $^Zero  TypeBehind method returns the reflect.Type of the expectedJSON json.Unmarshal\u0026lsquo;ed. So it can be bool, string, float64, []interface{}, map[string]interface{} or interface{} in case expectedJSON is \u0026ldquo;null\u0026rdquo;.\n See also JSON godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`)) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42}`)) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42 /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ }`)) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got with gender field:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`)) fmt.Println(\u0026#34;check got with fullname only:\u0026#34;, ok) ok = td.Cmp(t, true, td.JSON(`true`)) fmt.Println(\u0026#34;check boolean got is true:\u0026#34;, ok) ok = td.Cmp(t, 42, td.JSON(`42`)) fmt.Println(\u0026#34;check numeric got is 42:\u0026#34;, ok) got = nil ok = td.Cmp(t, got, td.JSON(`null`)) fmt.Println(\u0026#34;check nil got is null:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got with gender field: false \t// check got with fullname only: false \t// check boolean got is true: true \t// check numeric got is 42: true \t// check nil got is null: true       Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, 42, \u0026#34;Bob Foobar\u0026#34;)) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;))) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;}`, td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;))) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name}`, td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)))) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.JSON(`{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty}`)) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := td.Cmp(t, got, td.JSON(filename, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.Cmp(t, got, td.JSON(file, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \nCmpJSON shortcut func CmpJSON(t TestingT, got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool CmpJSON is a shortcut for:\ntd.Cmp(t, got, td.JSON(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpJSON godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := td.CmpJSON(t, got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = td.CmpJSON(t, got, ` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42 /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ }`, nil) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with gender field:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname only:\u0026#34;, ok) ok = td.CmpJSON(t, true, `true`, nil) fmt.Println(\u0026#34;check boolean got is true:\u0026#34;, ok) ok = td.CmpJSON(t, 42, `42`, nil) fmt.Println(\u0026#34;check numeric got is 42:\u0026#34;, ok) got = nil ok = td.CmpJSON(t, got, `null`, nil) fmt.Println(\u0026#34;check nil got is null:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got with gender field: false \t// check got with fullname only: false \t// check boolean got is true: true \t// check numeric got is 42: true \t// check nil got is null: true       Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := td.CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name}`, []interface{}{td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;))}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = td.CmpJSON(t, got, `{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty}`, nil) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := td.CmpJSON(t, got, filename, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.CmpJSON(t, got, file, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \nT.JSON shortcut func (t *T) JSON(got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool JSON is a shortcut for:\nt.Cmp(got, td.JSON(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.JSON godoc.\n Examples    Basic example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := t.JSON(got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = t.JSON(got, ` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42 /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ }`, nil) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with gender field:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname only:\u0026#34;, ok) ok = t.JSON(true, `true`, nil) fmt.Println(\u0026#34;check boolean got is true:\u0026#34;, ok) ok = t.JSON(42, `42`, nil) fmt.Println(\u0026#34;check numeric got is 42:\u0026#34;, ok) got = nil ok = t.JSON(got, `null`, nil) fmt.Println(\u0026#34;check nil got is null:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got with gender field: false \t// check got with fullname only: false \t// check boolean got is true: true \t// check numeric got is 42: true \t// check nil got is null: true       Placeholders example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := t.JSON(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;)}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name}`, []interface{}{td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;))}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = t.JSON(got, `{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty}`, nil) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := t.JSON(got, filename, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.JSON(got, file, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/keys/","title":"Keys","tags":[],"description":"","content":"func Keys(val interface{}) TestDeep Keys is a smuggler operator. It takes a map and compares its ordered keys to val.\nval can be a slice of items of the same type as the map keys:\ngot := map[string]bool{\u0026#34;c\u0026#34;: true, \u0026#34;a\u0026#34;: false, \u0026#34;b\u0026#34;: true} td.Cmp(t, got, td.Keys([]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;})) // succeeds, keys sorted td.Cmp(t, got, td.Keys([]string{\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;})) // fails as not sorted as well as an other operator as Bag, for example, to test keys in an unsorted manner:\ngot := map[string]bool{\u0026#34;c\u0026#34;: true, \u0026#34;a\u0026#34;: false, \u0026#34;b\u0026#34;: true} td.Cmp(t, got, td.Keys(td.Bag(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;))) // succeeds  See also Keys godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Keys tests keys in an ordered manner \tok := td.Cmp(t, got, td.Keys([]string{\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;})) fmt.Println(\u0026#34;All sorted keys are found:\u0026#34;, ok) // If the expected keys are not ordered, it fails \tok = td.Cmp(t, got, td.Keys([]string{\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;})) fmt.Println(\u0026#34;All unsorted keys are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = td.Cmp(t, got, td.Keys(td.Bag(\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;))) fmt.Println(\u0026#34;All unsorted keys are found, with the help of Bag operator:\u0026#34;, ok) // Check that each key is 3 bytes long \tok = td.Cmp(t, got, td.Keys(td.ArrayEach(td.Len(3)))) fmt.Println(\u0026#34;Each key is 3 bytes long:\u0026#34;, ok) // Output: \t// All sorted keys are found: true \t// All unsorted keys are found: false \t// All unsorted keys are found, with the help of Bag operator: true \t// Each key is 3 bytes long: true     CmpKeys shortcut func CmpKeys(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpKeys is a shortcut for:\ntd.Cmp(t, got, td.Keys(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpKeys godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Keys tests keys in an ordered manner \tok := td.CmpKeys(t, got, []string{\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;}) fmt.Println(\u0026#34;All sorted keys are found:\u0026#34;, ok) // If the expected keys are not ordered, it fails \tok = td.CmpKeys(t, got, []string{\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;}) fmt.Println(\u0026#34;All unsorted keys are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = td.CmpKeys(t, got, td.Bag(\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;)) fmt.Println(\u0026#34;All unsorted keys are found, with the help of Bag operator:\u0026#34;, ok) // Check that each key is 3 bytes long \tok = td.CmpKeys(t, got, td.ArrayEach(td.Len(3))) fmt.Println(\u0026#34;Each key is 3 bytes long:\u0026#34;, ok) // Output: \t// All sorted keys are found: true \t// All unsorted keys are found: false \t// All unsorted keys are found, with the help of Bag operator: true \t// Each key is 3 bytes long: true     T.Keys shortcut func (t *T) Keys(got interface{}, val interface{}, args ...interface{}) bool Keys is a shortcut for:\nt.Cmp(got, td.Keys(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Keys godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Keys tests keys in an ordered manner \tok := t.Keys(got, []string{\u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;zip\u0026#34;}) fmt.Println(\u0026#34;All sorted keys are found:\u0026#34;, ok) // If the expected keys are not ordered, it fails \tok = t.Keys(got, []string{\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;}) fmt.Println(\u0026#34;All unsorted keys are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = t.Keys(got, td.Bag(\u0026#34;zip\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;foo\u0026#34;)) fmt.Println(\u0026#34;All unsorted keys are found, with the help of Bag operator:\u0026#34;, ok) // Check that each key is 3 bytes long \tok = t.Keys(got, td.ArrayEach(td.Len(3))) fmt.Println(\u0026#34;Each key is 3 bytes long:\u0026#34;, ok) // Output: \t// All sorted keys are found: true \t// All unsorted keys are found: false \t// All unsorted keys are found, with the help of Bag operator: true \t// Each key is 3 bytes long: true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/lax/","title":"Lax","tags":[],"description":"","content":"func Lax(expectedValue interface{}) TestDeep Lax is a smuggler operator, it temporarily enables the BeLax config flag before letting the comparison process continue its course.\nIt is more commonly used as CmpLax function than as an operator. It could be used when, for example, an operator is constructed once but applied to different, but compatible types as in:\nbw := td.Between(20, 30) intValue := 21 floatValue := 21.89 td.Cmp(t, intValue, bw) // no need to be lax here: same int types td.Cmp(t, floatValue, td.Lax(bw)) // be lax please, as float64 ≠ int Note that in the latter case, CmpLax() could be used as well:\ntd.CmpLax(t, floatValue, bw) TypeBehind method returns the greatest convertible or more common reflect.Type of expectedValue if it is a base type (bool, int*, uint*, float*, complex*, string), the reflect.Type of expectedValue otherwise, except if expectedValue is a TestDeep operator. In this case, it delegates TypeBehind() to the operator.\n See also Lax godoc.\n Example   Base example   t := \u0026amp;testing.T{} gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := td.Between(1230, 1240) // int type here  ok := td.Cmp(t, gotInt64, td.Lax(expected)) fmt.Println(\u0026#34;int64 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = td.Cmp(t, gotInt32, td.Lax(expected)) fmt.Println(\u0026#34;int32 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = td.Cmp(t, gotMyInt, td.Lax(expected)) fmt.Println(\u0026#34;myInt got between ints [1230 .. 1240]:\u0026#34;, ok) // Output: \t// int64 got between ints [1230 .. 1240]: true \t// int32 got between ints [1230 .. 1240]: true \t// myInt got between ints [1230 .. 1240]: true     CmpLax shortcut func CmpLax(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpLax is a shortcut for:\ntd.Cmp(t, got, td.Lax(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpLax godoc.\n Example   Base example   t := \u0026amp;testing.T{} gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := td.Between(1230, 1240) // int type here  ok := td.CmpLax(t, gotInt64, expected) fmt.Println(\u0026#34;int64 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = td.CmpLax(t, gotInt32, expected) fmt.Println(\u0026#34;int32 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = td.CmpLax(t, gotMyInt, expected) fmt.Println(\u0026#34;myInt got between ints [1230 .. 1240]:\u0026#34;, ok) // Output: \t// int64 got between ints [1230 .. 1240]: true \t// int32 got between ints [1230 .. 1240]: true \t// myInt got between ints [1230 .. 1240]: true     T.CmpLax shortcut func (t *T) CmpLax(got interface{}, expectedValue interface{}, args ...interface{}) bool CmpLax is a shortcut for:\nt.Cmp(got, td.Lax(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.CmpLax godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) gotInt64 := int64(1234) gotInt32 := int32(1235) type myInt uint16 gotMyInt := myInt(1236) expected := td.Between(1230, 1240) // int type here  ok := t.CmpLax(gotInt64, expected) fmt.Println(\u0026#34;int64 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = t.CmpLax(gotInt32, expected) fmt.Println(\u0026#34;int32 got between ints [1230 .. 1240]:\u0026#34;, ok) ok = t.CmpLax(gotMyInt, expected) fmt.Println(\u0026#34;myInt got between ints [1230 .. 1240]:\u0026#34;, ok) // Output: \t// int64 got between ints [1230 .. 1240]: true \t// int32 got between ints [1230 .. 1240]: true \t// myInt got between ints [1230 .. 1240]: true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/len/","title":"Len","tags":[],"description":"","content":"func Len(expectedLen interface{}) TestDeep Len is a smuggler operator. It takes data, applies len() function on it and compares its result to expectedLen. Of course, the compared value must be an array, a channel, a map, a slice or a string.\nexpectedLen can be an int value:\ntd.Cmp(t, gotSlice, td.Len(12)) as well as an other operator:\ntd.Cmp(t, gotSlice, td.Len(td.Between(3, 4)))  See also Len godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(3), \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       Map example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(3), \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = td.Cmp(t, got, td.Len(0), \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       OperatorSlice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Lt(5)), \u0026#34;checks %v len is \u0026lt; 5\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true       OperatorMap example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.Cmp(t, got, td.Len(td.Between(3, 8)), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Len(td.Gte(3)), \u0026#34;checks %v len is ≥ 3\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nCmpLen shortcut func CmpLen(t TestingT, got interface{}, expectedLen interface{}, args ...interface{}) bool CmpLen is a shortcut for:\ntd.Cmp(t, got, td.Len(expectedLen), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpLen godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := td.CmpLen(t, got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = td.CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = td.CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       Map example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.CmpLen(t, got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = td.CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = td.CmpLen(t, got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       OperatorSlice example   t := \u0026amp;testing.T{} got := []int{11, 22, 33} ok := td.CmpLen(t, got, td.Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = td.CmpLen(t, got, td.Lt(5), \u0026#34;checks %v len is \u0026lt; 5\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true       OperatorMap example   t := \u0026amp;testing.T{} got := map[int]bool{11: true, 22: false, 33: false} ok := td.CmpLen(t, got, td.Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = td.CmpLen(t, got, td.Gte(3), \u0026#34;checks %v len is ≥ 3\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nT.Len shortcut func (t *T) Len(got interface{}, expectedLen interface{}, args ...interface{}) bool Len is a shortcut for:\nt.Cmp(got, td.Len(expectedLen), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Len godoc.\n Examples    Slice example   t := td.NewT(\u0026amp;testing.T{}) got := []int{11, 22, 33} ok := t.Len(got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       Map example   t := td.NewT(\u0026amp;testing.T{}) got := map[int]bool{11: true, 22: false, 33: false} ok := t.Len(got, 3, \u0026#34;checks %v len is 3\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) got = nil ok = t.Len(got, 0, \u0026#34;checks %v len is 0\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true       OperatorSlice example   t := td.NewT(\u0026amp;testing.T{}) got := []int{11, 22, 33} ok := t.Len(got, td.Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, td.Lt(5), \u0026#34;checks %v len is \u0026lt; 5\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true       OperatorMap example   t := td.NewT(\u0026amp;testing.T{}) got := map[int]bool{11: true, 22: false, 33: false} ok := t.Len(got, td.Between(3, 8), \u0026#34;checks %v len is in [3 .. 8]\u0026#34;, got) fmt.Println(ok) ok = t.Len(got, td.Gte(3), \u0026#34;checks %v len is ≥ 3\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/lt/","title":"Lt","tags":[],"description":"","content":"func Lt(maxExpectedValue interface{}) TestDeep Lt operator checks that data is lesser than maxExpectedValue. maxExpectedValue can be any numeric or time.Time (or assignable) value. maxExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\ntd.Cmp(t, 17, td.Lt(19)) before := time.Now() td.Cmp(t, before, td.Lt(time.Now())) TypeBehind method returns the reflect.Type of maxExpectedValue.\n See also Lt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.Cmp(t, got, td.Lt(157), \u0026#34;checks %v is \u0026lt; 157\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lt(156), \u0026#34;checks %v is \u0026lt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.Cmp(t, got, td.Lt(\u0026#34;abd\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lt(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false    \nCmpLt shortcut func CmpLt(t TestingT, got interface{}, maxExpectedValue interface{}, args ...interface{}) bool CmpLt is a shortcut for:\ntd.Cmp(t, got, td.Lt(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpLt godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.CmpLt(t, got, 157, \u0026#34;checks %v is \u0026lt; 157\u0026#34;, got) fmt.Println(ok) ok = td.CmpLt(t, got, 156, \u0026#34;checks %v is \u0026lt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.CmpLt(t, got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = td.CmpLt(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false    \nT.Lt shortcut func (t *T) Lt(got interface{}, maxExpectedValue interface{}, args ...interface{}) bool Lt is a shortcut for:\nt.Cmp(got, td.Lt(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Lt godoc.\n Examples    Int example   t := td.NewT(\u0026amp;testing.T{}) got := 156 ok := t.Lt(got, 157, \u0026#34;checks %v is \u0026lt; 157\u0026#34;, got) fmt.Println(ok) ok = t.Lt(got, 156, \u0026#34;checks %v is \u0026lt; 156\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       String example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Lt(got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = t.Lt(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is \u0026lt; \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/lte/","title":"Lte","tags":[],"description":"","content":"func Lte(maxExpectedValue interface{}) TestDeep Lte operator checks that data is lesser or equal than maxExpectedValue. maxExpectedValue can be any numeric or time.Time (or assignable) value. maxExpectedValue must be the same kind as the compared value if numeric, and the same type if time.Time (or assignable).\ntd.Cmp(t, 17, td.Lte(17)) before := time.Now() td.Cmp(t, before, td.Lt(time.Now())) TypeBehind method returns the reflect.Type of maxExpectedValue.\n See also Lte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.Cmp(t, got, td.Lte(156), \u0026#34;checks %v is ≤ 156\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(157), \u0026#34;checks %v is ≤ 157\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(155), \u0026#34;checks %v is ≤ 155\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.Cmp(t, got, td.Lte(\u0026#34;abc\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(\u0026#34;abd\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Lte(\u0026#34;abb\u0026#34;), `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false    \nCmpLte shortcut func CmpLte(t TestingT, got interface{}, maxExpectedValue interface{}, args ...interface{}) bool CmpLte is a shortcut for:\ntd.Cmp(t, got, td.Lte(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpLte godoc.\n Examples    Int example   t := \u0026amp;testing.T{} got := 156 ok := td.CmpLte(t, got, 156, \u0026#34;checks %v is ≤ 156\u0026#34;, got) fmt.Println(ok) ok = td.CmpLte(t, got, 157, \u0026#34;checks %v is ≤ 157\u0026#34;, got) fmt.Println(ok) ok = td.CmpLte(t, got, 155, \u0026#34;checks %v is ≤ 155\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false       String example   t := \u0026amp;testing.T{} got := \u0026#34;abc\u0026#34; ok := td.CmpLte(t, got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = td.CmpLte(t, got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = td.CmpLte(t, got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false    \nT.Lte shortcut func (t *T) Lte(got interface{}, maxExpectedValue interface{}, args ...interface{}) bool Lte is a shortcut for:\nt.Cmp(got, td.Lte(maxExpectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Lte godoc.\n Examples    Int example   t := td.NewT(\u0026amp;testing.T{}) got := 156 ok := t.Lte(got, 156, \u0026#34;checks %v is ≤ 156\u0026#34;, got) fmt.Println(ok) ok = t.Lte(got, 157, \u0026#34;checks %v is ≤ 157\u0026#34;, got) fmt.Println(ok) ok = t.Lte(got, 155, \u0026#34;checks %v is ≤ 155\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false       String example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;abc\u0026#34; ok := t.Lte(got, \u0026#34;abc\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abc\u0026#34;`, got) fmt.Println(ok) ok = t.Lte(got, \u0026#34;abd\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abd\u0026#34;`, got) fmt.Println(ok) ok = t.Lte(got, \u0026#34;abb\u0026#34;, `checks \u0026#34;%v\u0026#34; is ≤ \u0026#34;abb\u0026#34;`, got) fmt.Println(ok) // Output: \t// true \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/map/","title":"Map","tags":[],"description":"","content":"func Map(model interface{}, expectedEntries MapEntries) TestDeep Map operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, all expected entries must be found and all data entries must be expected to succeed.\ngot := map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;wizz\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;buzz\u0026#34;, } td.Cmp(t, got, td.Map( map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;wizz\u0026#34;, }, td.MapEntries{ \u0026#34;zip\u0026#34;: td.HasSuffix(\u0026#34;zz\u0026#34;), }), ) // succeeds TypeBehind method returns the reflect.Type of model.\n See also Map godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.Cmp(t, got, td.Map(map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Map(map[string]int{}, td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Map((map[string]int)(nil), td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.Cmp(t, got, td.Map(MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks typed map %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Map(\u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Map(\u0026amp;MyMap{}, td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Map((*MyMap)(nil), td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}), \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \nCmpMap shortcut func CmpMap(t TestingT, got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool CmpMap is a shortcut for:\ntd.Cmp(t, got, td.Map(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpMap godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.CmpMap(t, got, map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpMap(t, got, map[string]int{}, td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpMap(t, got, (map[string]int)(nil), td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.CmpMap(t, got, MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks typed map %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpMap(t, \u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpMap(t, \u0026amp;got, \u0026amp;MyMap{}, td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpMap(t, \u0026amp;got, (*MyMap)(nil), td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \nT.Map shortcut func (t *T) Map(got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool Map is a shortcut for:\nt.Cmp(got, td.Map(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Map godoc.\n Examples    Map example   t := td.NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.Map(got, map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(got, map[string]int{}, td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(got, (map[string]int)(nil), td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true       TypedMap example   t := td.NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.Map(got, MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks typed map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(\u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(\u0026amp;got, \u0026amp;MyMap{}, td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) ok = t.Map(\u0026amp;got, (*MyMap)(nil), td.MapEntries{\u0026#34;bar\u0026#34;: 42, \u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: td.Ignore()}, \u0026#34;checks pointer on typed map %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/mapeach/","title":"MapEach","tags":[],"description":"","content":"func MapEach(expectedValue interface{}) TestDeep MapEach operator has to be applied on maps. It compares each value of data map against expected value. During a match, all values have to match to succeed.\ngot := map[string]string{\u0026#34;test\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;buzz\u0026#34;: \u0026#34;bar\u0026#34;} td.Cmp(t, got, td.MapEach(\u0026#34;bar\u0026#34;)) // fails, coz \u0026#34;foo\u0026#34; ≠ \u0026#34;bar\u0026#34; td.Cmp(t, got, td.MapEach(td.Len(3))) // succeeds as values are 3 chars long  See also MapEach godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), \u0026#34;checks each value of map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.Cmp(t, got, td.MapEach(td.Between(10, 90)), \u0026#34;checks each value of typed map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.MapEach(td.Between(10, 90)), \u0026#34;checks each value of typed map pointer %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nCmpMapEach shortcut func CmpMapEach(t TestingT, got interface{}, expectedValue interface{}, args ...interface{}) bool CmpMapEach is a shortcut for:\ntd.Cmp(t, got, td.MapEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpMapEach godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.CmpMapEach(t, got, td.Between(10, 90), \u0026#34;checks each value of map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.CmpMapEach(t, got, td.Between(10, 90), \u0026#34;checks each value of typed map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) ok = td.CmpMapEach(t, \u0026amp;got, td.Between(10, 90), \u0026#34;checks each value of typed map pointer %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nT.MapEach shortcut func (t *T) MapEach(got interface{}, expectedValue interface{}, args ...interface{}) bool MapEach is a shortcut for:\nt.Cmp(got, td.MapEach(expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.MapEach godoc.\n Examples    Map example   t := td.NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.MapEach(got, td.Between(10, 90), \u0026#34;checks each value of map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := td.NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.MapEach(got, td.Between(10, 90), \u0026#34;checks each value of typed map %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) ok = t.MapEach(\u0026amp;got, td.Between(10, 90), \u0026#34;checks each value of typed map pointer %v is in [10 .. 90]\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/n/","title":"N","tags":[],"description":"","content":"func N(num interface{}, tolerance ...interface{}) TestDeep N operator compares a numeric data against num ± tolerance. If tolerance is missing, it defaults to 0. num and tolerance must be the same kind as the compared value.\ntd.Cmp(t, 12.2, td.N(12., 0.3)) // succeeds td.Cmp(t, 12.2, td.N(12., 0.1)) // fails TypeBehind method returns the reflect.Type of num.\n See also N godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 1.12345 ok := td.Cmp(t, got, td.N(1.1234, 0.00006), \u0026#34;checks %v = 1.1234 ± 0.00006\u0026#34;, got) fmt.Println(ok) // Output: \t// true     CmpN shortcut func CmpN(t TestingT, got interface{}, num interface{}, tolerance interface{}, args ...interface{}) bool CmpN is a shortcut for:\ntd.Cmp(t, got, td.N(num, tolerance), args...) See above for details.\nN() optional parameter tolerance is here mandatory. 0 value should be passed to mimic its absence in original N() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpN godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 1.12345 ok := td.CmpN(t, got, 1.1234, 0.00006, \u0026#34;checks %v = 1.1234 ± 0.00006\u0026#34;, got) fmt.Println(ok) // Output: \t// true     T.N shortcut func (t *T) N(got interface{}, num interface{}, tolerance interface{}, args ...interface{}) bool N is a shortcut for:\nt.Cmp(got, td.N(num, tolerance), args...) See above for details.\nN() optional parameter tolerance is here mandatory. 0 value should be passed to mimic its absence in original N() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.N godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := 1.12345 ok := t.N(got, 1.1234, 0.00006, \u0026#34;checks %v = 1.1234 ± 0.00006\u0026#34;, got) fmt.Println(ok) // Output: \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/nan/","title":"NaN","tags":[],"description":"","content":"func NaN() TestDeep NaN operator checks that data is a float and is not-a-number.\ngot := math.NaN() td.Cmp(t, got, td.NaN()) // succeeds td.Cmp(t, 4.2, td.NaN()) // fails  See also NaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is float32 not-a-number:\u0026#34;, ok) got = 12 ok = td.Cmp(t, got, td.NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is float32 not-a-number: true \t// float32(12) is float32 not-a-number: false       Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = td.Cmp(t, got, td.NaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is not-a-number: true \t// float64(12) is not-a-number: false    \nCmpNaN shortcut func CmpNaN(t TestingT, got interface{}, args ...interface{}) bool CmpNaN is a shortcut for:\ntd.Cmp(t, got, td.NaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := td.CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is float32 not-a-number:\u0026#34;, ok) got = 12 ok = td.CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is float32 not-a-number: true \t// float32(12) is float32 not-a-number: false       Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := td.CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = td.CmpNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is not-a-number: true \t// float64(12) is not-a-number: false    \nT.NaN shortcut func (t *T) NaN(got interface{}, args ...interface{}) bool NaN is a shortcut for:\nt.Cmp(got, td.NaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.NaN godoc.\n Examples    Float32 example   t := td.NewT(\u0026amp;testing.T{}) got := float32(math.NaN()) ok := t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is float32 not-a-number:\u0026#34;, ok) got = 12 ok = t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is float32 not-a-number: true \t// float32(12) is float32 not-a-number: false       Float64 example   t := td.NewT(\u0026amp;testing.T{}) got := math.NaN() ok := t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = t.NaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is not-a-number: true \t// float64(12) is not-a-number: false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/nil/","title":"Nil","tags":[],"description":"","content":"func Nil() TestDeep Nil operator checks that data is nil (or is a non-nil interface, but containing a nil pointer.)\nvar got *int td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails as (*int)(nil) ≠ untyped nil td.Cmp(t, got, (*int)(nil)) // succeeds but:\nvar got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.Nil()) // succeeds td.Cmp(t, got, nil) // fails, as the interface is not nil got = nil td.Cmp(t, got, nil) // succeeds  See also Nil godoc.\n Example   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer // interface  // nil value can be compared directly with nil, no need of Nil() here \tok := td.Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway \tok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with nil fails, as the interface is not nil \tok = td.Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed \tok = td.Cmp(t, got, td.Nil()) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true     CmpNil shortcut func CmpNil(t TestingT, got interface{}, args ...interface{}) bool CmpNil is a shortcut for:\ntd.Cmp(t, got, td.Nil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNil godoc.\n Example   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer // interface  // nil value can be compared directly with nil, no need of Nil() here \tok := td.Cmp(t, got, nil) fmt.Println(ok) // But it works with Nil() anyway \tok = td.CmpNil(t, got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with nil fails, as the interface is not nil \tok = td.Cmp(t, got, nil) fmt.Println(ok) // In this case Nil() succeed \tok = td.CmpNil(t, got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true     T.Nil shortcut func (t *T) Nil(got interface{}, args ...interface{}) bool Nil is a shortcut for:\nt.Cmp(got, td.Nil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Nil godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) var got fmt.Stringer // interface  // nil value can be compared directly with nil, no need of Nil() here \tok := t.Cmp(got, nil) fmt.Println(ok) // But it works with Nil() anyway \tok = t.Nil(got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with nil fails, as the interface is not nil \tok = t.Cmp(got, nil) fmt.Println(ok) // In this case Nil() succeed \tok = t.Nil(got) fmt.Println(ok) // Output: \t// true \t// true \t// false \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/none/","title":"None","tags":[],"description":"","content":"func None(notExpectedValues ...interface{}) TestDeep None operator compares data against several not expected values. During a match, none of them have to match to succeed.\ntd.Cmp(t, 12, td.None(8, 10, 14)) // succeeds td.Cmp(t, 12, td.None(8, 10, 12, 14)) // fails Note Flatten function can be used to group or reuse some values or operators and so avoid boring and inefficient copies:\nprime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) td.Cmp(t, 9, td.None(prime, even)) // succeeds  See also None godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 18 ok := td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 20 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 142 ok = td.Cmp(t, got, td.None(0, 10, 20, 30, td.Between(100, 199)), \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = td.Cmp(t, got, td.None(prime, even, td.Gt(14)), \u0026#34;checks %v is not prime number, nor an even number and not \u0026gt; 14\u0026#34;) fmt.Printf(\u0026#34;%d → %t\\n\u0026#34;, got, ok) } // Output: \t// true \t// false \t// false \t// 9 → true \t// 3 → false \t// 8 → false \t// 15 → false     CmpNone shortcut func CmpNone(t TestingT, got interface{}, notExpectedValues []interface{}, args ...interface{}) bool CmpNone is a shortcut for:\ntd.Cmp(t, got, td.None(notExpectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNone godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 18 ok := td.CmpNone(t, got, []interface{}{0, 10, 20, 30, td.Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 20 ok = td.CmpNone(t, got, []interface{}{0, 10, 20, 30, td.Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 142 ok = td.CmpNone(t, got, []interface{}{0, 10, 20, 30, td.Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = td.CmpNone(t, got, []interface{}{prime, even, td.Gt(14)}, \u0026#34;checks %v is not prime number, nor an even number and not \u0026gt; 14\u0026#34;) fmt.Printf(\u0026#34;%d → %t\\n\u0026#34;, got, ok) } // Output: \t// true \t// false \t// false \t// 9 → true \t// 3 → false \t// 8 → false \t// 15 → false     T.None shortcut func (t *T) None(got interface{}, notExpectedValues []interface{}, args ...interface{}) bool None is a shortcut for:\nt.Cmp(got, td.None(notExpectedValues...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.None godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := 18 ok := t.None(got, []interface{}{0, 10, 20, 30, td.Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 20 ok = t.None(got, []interface{}{0, 10, 20, 30, td.Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) got = 142 ok = t.None(got, []interface{}{0, 10, 20, 30, td.Between(100, 199)}, \u0026#34;checks %v is non-null, and ≠ 10, 20 \u0026amp; 30, and not in [100-199]\u0026#34;, got) fmt.Println(ok) prime := td.Flatten([]int{1, 2, 3, 5, 7, 11, 13}) even := td.Flatten([]int{2, 4, 6, 8, 10, 12, 14}) for _, got := range [...]int{9, 3, 8, 15} { ok = t.None(got, []interface{}{prime, even, td.Gt(14)}, \u0026#34;checks %v is not prime number, nor an even number and not \u0026gt; 14\u0026#34;) fmt.Printf(\u0026#34;%d → %t\\n\u0026#34;, got, ok) } // Output: \t// true \t// false \t// false \t// 9 → true \t// 3 → false \t// 8 → false \t// 15 → false     "},{"uri":"https://go-testdeep.zetta.rocks/operators/not/","title":"Not","tags":[],"description":"","content":"func Not(notExpected interface{}) TestDeep Not operator compares data against the not expected value. During a match, it must not match to succeed.\nNot is the same operator as None() with only one argument. It is provided as a more readable function when only one argument is needed.\ntd.Cmp(t, 12, td.Not(10)) // succeeds td.Cmp(t, 12, td.Not(12)) // fails  See also Not godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 42 ok := td.Cmp(t, got, td.Not(0), \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Not(td.Between(10, 30)), \u0026#34;checks %v is not in [10 .. 30]\u0026#34;, got) fmt.Println(ok) got = 0 ok = td.Cmp(t, got, td.Not(0), \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     CmpNot shortcut func CmpNot(t TestingT, got interface{}, notExpected interface{}, args ...interface{}) bool CmpNot is a shortcut for:\ntd.Cmp(t, got, td.Not(notExpected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNot godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 42 ok := td.CmpNot(t, got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) ok = td.CmpNot(t, got, td.Between(10, 30), \u0026#34;checks %v is not in [10 .. 30]\u0026#34;, got) fmt.Println(ok) got = 0 ok = td.CmpNot(t, got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     T.Not shortcut func (t *T) Not(got interface{}, notExpected interface{}, args ...interface{}) bool Not is a shortcut for:\nt.Cmp(got, td.Not(notExpected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Not godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := 42 ok := t.Not(got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) ok = t.Not(got, td.Between(10, 30), \u0026#34;checks %v is not in [10 .. 30]\u0026#34;, got) fmt.Println(ok) got = 0 ok = t.Not(got, 0, \u0026#34;checks %v is non-null\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// false     "},{"uri":"https://go-testdeep.zetta.rocks/operators/notany/","title":"NotAny","tags":[],"description":"","content":"func NotAny(notExpectedItems ...interface{}) TestDeep NotAny operator checks that the contents of an array or a slice (or a pointer on array/slice) does not contain any of notExpectedItems.\ntd.Cmp(t, []int{1}, td.NotAny(1, 2, 3)) // fails td.Cmp(t, []int{5}, td.NotAny(1, 2, 3)) // succeeds  // works with slices/arrays of any type td.Cmp(t, personSlice, td.NotAny( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nnotExpected := []int{2, 1} td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(td.Flatten(notExpected))) // succeeds // = td.Cmp(t, []int{4, 4, 3, 8}, td.NotAny(2, 1))  notExp1 := []int{2, 1} notExp2 := []int{5, 8} td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(td.Flatten(notExp1), 3, td.Flatten(notExp2))) // succeeds // = td.Cmp(t, []int{4, 4, 42, 8}, td.NotAny(2, 1, 3, 5, 8)) Beware that NotAny(…) is not equivalent to Not(Any(…)) but is like Not(SuperSet(…)).\n See also NotAny godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{4, 5, 9, 42} ok := td.Cmp(t, got, td.NotAny(3, 6, 8, 41, 43), \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.NotAny(3, 6, 8, 42, 43), \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using notExpected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \tnotExpected := []int{3, 6, 8, 41, 43} ok = td.Cmp(t, got, td.NotAny(td.Flatten(notExpected)), \u0026#34;checks %v contains no item listed in notExpected\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     CmpNotAny shortcut func CmpNotAny(t TestingT, got interface{}, notExpectedItems []interface{}, args ...interface{}) bool CmpNotAny is a shortcut for:\ntd.Cmp(t, got, td.NotAny(notExpectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNotAny godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{4, 5, 9, 42} ok := td.CmpNotAny(t, got, []interface{}{3, 6, 8, 41, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) ok = td.CmpNotAny(t, got, []interface{}{3, 6, 8, 42, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using notExpected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \tnotExpected := []int{3, 6, 8, 41, 43} ok = td.CmpNotAny(t, got, []interface{}{td.Flatten(notExpected)}, \u0026#34;checks %v contains no item listed in notExpected\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     T.NotAny shortcut func (t *T) NotAny(got interface{}, notExpectedItems []interface{}, args ...interface{}) bool NotAny is a shortcut for:\nt.Cmp(got, td.NotAny(notExpectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.NotAny godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{4, 5, 9, 42} ok := t.NotAny(got, []interface{}{3, 6, 8, 41, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) ok = t.NotAny(got, []interface{}{3, 6, 8, 42, 43}, \u0026#34;checks %v contains no item listed in NotAny()\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using notExpected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \tnotExpected := []int{3, 6, 8, 41, 43} ok = t.NotAny(got, []interface{}{td.Flatten(notExpected)}, \u0026#34;checks %v contains no item listed in notExpected\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/notempty/","title":"NotEmpty","tags":[],"description":"","content":"func NotEmpty() TestDeep NotEmpty operator checks that an array, a channel, a map, a slice or a string is not empty. As a special case (non-typed) nil, as well as nil channel, map or slice are considered empty.\nNote that the compared data can be a pointer (of pointer of pointer etc.) on an array, a channel, a map, a slice or a string.\ntd.Cmp(t, \u0026#34;\u0026#34;, td.NotEmpty()) // fails td.Cmp(t, map[string]bool{}, td.NotEmpty()) // fails td.Cmp(t, []string{\u0026#34;foo\u0026#34;}, td.NotEmpty()) // succeeds  See also NotEmpty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := td.Cmp(t, nil, td.NotEmpty()) // fails, as nil is considered empty \tfmt.Println(ok) ok = td.Cmp(t, \u0026#34;foobar\u0026#34;, td.NotEmpty()) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead \tok = td.Cmp(t, 0, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, map[string]int{\u0026#34;foobar\u0026#34;: 42}, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, []int{1}, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.NotEmpty()) // succeeds, NotEmpty() is not NotZero()! \tfmt.Println(ok) // Output: \t// false \t// true \t// false \t// true \t// true \t// true       Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := td.Cmp(t, MySlice{12}, td.NotEmpty()) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;MySlice{12}, td.NotEmpty()) // Ptr() not needed \tfmt.Println(ok) l1 := \u0026amp;MySlice{12} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = td.Cmp(t, \u0026amp;l3, td.NotEmpty()) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = td.Cmp(t, \u0026amp;MyStruct{}, td.NotEmpty()) // fails, use NotZero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false    \nCmpNotEmpty shortcut func CmpNotEmpty(t TestingT, got interface{}, args ...interface{}) bool CmpNotEmpty is a shortcut for:\ntd.Cmp(t, got, td.NotEmpty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNotEmpty godoc.\n Examples    Base example   t := \u0026amp;testing.T{} ok := td.CmpNotEmpty(t, nil) // fails, as nil is considered empty \tfmt.Println(ok) ok = td.CmpNotEmpty(t, \u0026#34;foobar\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead \tok = td.CmpNotEmpty(t, 0) fmt.Println(ok) ok = td.CmpNotEmpty(t, map[string]int{\u0026#34;foobar\u0026#34;: 42}) fmt.Println(ok) ok = td.CmpNotEmpty(t, []int{1}) fmt.Println(ok) ok = td.CmpNotEmpty(t, [3]int{}) // succeeds, NotEmpty() is not NotZero()! \tfmt.Println(ok) // Output: \t// false \t// true \t// false \t// true \t// true \t// true       Pointers example   t := \u0026amp;testing.T{} type MySlice []int ok := td.CmpNotEmpty(t, MySlice{12}) fmt.Println(ok) ok = td.CmpNotEmpty(t, \u0026amp;MySlice{12}) // Ptr() not needed \tfmt.Println(ok) l1 := \u0026amp;MySlice{12} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = td.CmpNotEmpty(t, \u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = td.CmpNotEmpty(t, \u0026amp;MyStruct{}) // fails, use NotZero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false    \nT.NotEmpty shortcut func (t *T) NotEmpty(got interface{}, args ...interface{}) bool NotEmpty is a shortcut for:\nt.Cmp(got, td.NotEmpty(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.NotEmpty godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) ok := t.NotEmpty(nil) // fails, as nil is considered empty \tfmt.Println(ok) ok = t.NotEmpty(\u0026#34;foobar\u0026#34;) fmt.Println(ok) // Fails as 0 is a number, so not empty. Use NotZero() instead \tok = t.NotEmpty(0) fmt.Println(ok) ok = t.NotEmpty(map[string]int{\u0026#34;foobar\u0026#34;: 42}) fmt.Println(ok) ok = t.NotEmpty([]int{1}) fmt.Println(ok) ok = t.NotEmpty([3]int{}) // succeeds, NotEmpty() is not NotZero()! \tfmt.Println(ok) // Output: \t// false \t// true \t// false \t// true \t// true \t// true       Pointers example   t := td.NewT(\u0026amp;testing.T{}) type MySlice []int ok := t.NotEmpty(MySlice{12}) fmt.Println(ok) ok = t.NotEmpty(\u0026amp;MySlice{12}) // Ptr() not needed \tfmt.Println(ok) l1 := \u0026amp;MySlice{12} l2 := \u0026amp;l1 l3 := \u0026amp;l2 ok = t.NotEmpty(\u0026amp;l3) fmt.Println(ok) // Works the same for array, map, channel and string  // But not for others types as: \ttype MyStruct struct { Value int } ok = t.NotEmpty(\u0026amp;MyStruct{}) // fails, use NotZero() instead \tfmt.Println(ok) // Output: \t// true \t// true \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/notnan/","title":"NotNaN","tags":[],"description":"","content":"func NotNaN() TestDeep NotNaN operator checks that data is a float and is not not-a-number.\ngot := math.NaN() td.Cmp(t, got, td.NotNaN()) // fails td.Cmp(t, 4.2, td.NotNaN()) // succeeds td.Cmp(t, 4, td.NotNaN()) // fails, as 4 is not a float  See also NotNaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := td.Cmp(t, got, td.NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is NOT float32 not-a-number:\u0026#34;, ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is NOT float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is NOT float32 not-a-number: false \t// float32(12) is NOT float32 not-a-number: true       Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := td.Cmp(t, got, td.NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = td.Cmp(t, got, td.NotNaN(), \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is NOT not-a-number: false \t// float64(12) is NOT not-a-number: true    \nCmpNotNaN shortcut func CmpNotNaN(t TestingT, got interface{}, args ...interface{}) bool CmpNotNaN is a shortcut for:\ntd.Cmp(t, got, td.NotNaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNotNaN godoc.\n Examples    Float32 example   t := \u0026amp;testing.T{} got := float32(math.NaN()) ok := td.CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is NOT float32 not-a-number:\u0026#34;, ok) got = 12 ok = td.CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is NOT float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is NOT float32 not-a-number: false \t// float32(12) is NOT float32 not-a-number: true       Float64 example   t := \u0026amp;testing.T{} got := math.NaN() ok := td.CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = td.CmpNotNaN(t, got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is NOT not-a-number: false \t// float64(12) is NOT not-a-number: true    \nT.NotNaN shortcut func (t *T) NotNaN(got interface{}, args ...interface{}) bool NotNaN is a shortcut for:\nt.Cmp(got, td.NotNaN(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.NotNaN godoc.\n Examples    Float32 example   t := td.NewT(\u0026amp;testing.T{}) got := float32(math.NaN()) ok := t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(math.NaN()) is NOT float32 not-a-number:\u0026#34;, ok) got = 12 ok = t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float32(12) is NOT float32 not-a-number:\u0026#34;, ok) // Output: \t// float32(math.NaN()) is NOT float32 not-a-number: false \t// float32(12) is NOT float32 not-a-number: true       Float64 example   t := td.NewT(\u0026amp;testing.T{}) got := math.NaN() ok := t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;math.NaN() is not-a-number:\u0026#34;, ok) got = 12 ok = t.NotNaN(got, \u0026#34;checks %v is not-a-number\u0026#34;, got) fmt.Println(\u0026#34;float64(12) is not-a-number:\u0026#34;, ok) // math.NaN() is NOT not-a-number: false \t// float64(12) is NOT not-a-number: true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/notnil/","title":"NotNil","tags":[],"description":"","content":"func NotNil() TestDeep NotNil operator checks that data is not nil (or is a non-nil interface, containing a non-nil pointer.)\ngot := \u0026amp;Person{} td.Cmp(t, got, td.NotNil()) // succeeds td.Cmp(t, got, td.Not(nil)) // succeeds too, but be careful it is first // because of got type *Person ≠ untyped nil so prefer NotNil() but:\nvar got fmt.Stringer = (*bytes.Buffer)(nil) td.Cmp(t, got, td.NotNil()) // fails td.Cmp(t, got, td.Not(nil)) // succeeds, as the interface is not nil  See also NotNil godoc.\n Example   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer = \u0026amp;bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here \tok := td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway \tok = td.Cmp(t, got, td.NotNil()) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with Not(nil) succeeds, as the interface is not nil \tok = td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // In this case NotNil() fails \tok = td.Cmp(t, got, td.NotNil()) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// false     CmpNotNil shortcut func CmpNotNil(t TestingT, got interface{}, args ...interface{}) bool CmpNotNil is a shortcut for:\ntd.Cmp(t, got, td.NotNil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNotNil godoc.\n Example   Base example   t := \u0026amp;testing.T{} var got fmt.Stringer = \u0026amp;bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here \tok := td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway \tok = td.CmpNotNil(t, got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with Not(nil) succeeds, as the interface is not nil \tok = td.Cmp(t, got, td.Not(nil)) fmt.Println(ok) // In this case NotNil() fails \tok = td.CmpNotNil(t, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// false     T.NotNil shortcut func (t *T) NotNil(got interface{}, args ...interface{}) bool NotNil is a shortcut for:\nt.Cmp(got, td.NotNil(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.NotNil godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) var got fmt.Stringer = \u0026amp;bytes.Buffer{} // nil value can be compared directly with Not(nil), no need of NotNil() here \tok := t.Cmp(got, td.Not(nil)) fmt.Println(ok) // But it works with NotNil() anyway \tok = t.NotNil(got) fmt.Println(ok) got = (*bytes.Buffer)(nil) // In the case of an interface containing a nil pointer, comparing \t// with Not(nil) succeeds, as the interface is not nil \tok = t.Cmp(got, td.Not(nil)) fmt.Println(ok) // In this case NotNil() fails \tok = t.NotNil(got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// false     "},{"uri":"https://go-testdeep.zetta.rocks/operators/notzero/","title":"NotZero","tags":[],"description":"","content":"func NotZero() TestDeep NotZero operator checks that data is not zero regarding its type.\n nil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \u0026quot;\u0026rdquo; is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized.  Beware that:\ntd.Cmp(t, AnyStruct{}, td.NotZero()) // is false td.Cmp(t, \u0026amp;AnyStruct{}, td.NotZero()) // is true, coz pointer ≠ nil td.Cmp(t, \u0026amp;AnyStruct{}, td.Ptr(td.NotZero())) // is false  See also NotZero godoc.\n Example   Base example   t := \u0026amp;testing.T{} ok := td.Cmp(t, 0, td.NotZero()) // fails \tfmt.Println(ok) ok = td.Cmp(t, float64(0), td.NotZero()) // fails \tfmt.Println(ok) ok = td.Cmp(t, 12, td.NotZero()) fmt.Println(ok) ok = td.Cmp(t, (map[string]int)(nil), td.NotZero()) // fails, as nil \tfmt.Println(ok) ok = td.Cmp(t, map[string]int{}, td.NotZero()) // succeeds, as not nil \tfmt.Println(ok) ok = td.Cmp(t, ([]int)(nil), td.NotZero()) // fails, as nil \tfmt.Println(ok) ok = td.Cmp(t, []int{}, td.NotZero()) // succeeds, as not nil \tfmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.NotZero()) // fails \tfmt.Println(ok) ok = td.Cmp(t, [3]int{0, 1}, td.NotZero()) // succeeds, DATA[1] is not 0 \tfmt.Println(ok) ok = td.Cmp(t, bytes.Buffer{}, td.NotZero()) // fails \tfmt.Println(ok) ok = td.Cmp(t, \u0026amp;bytes.Buffer{}, td.NotZero()) // succeeds, as pointer not nil \tfmt.Println(ok) ok = td.Cmp(t, \u0026amp;bytes.Buffer{}, td.Ptr(td.NotZero())) // fails as deref by Ptr() \tfmt.Println(ok) // Output: \t// false \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false     CmpNotZero shortcut func CmpNotZero(t TestingT, got interface{}, args ...interface{}) bool CmpNotZero is a shortcut for:\ntd.Cmp(t, got, td.NotZero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpNotZero godoc.\n Example   Base example   t := \u0026amp;testing.T{} ok := td.CmpNotZero(t, 0) // fails \tfmt.Println(ok) ok = td.CmpNotZero(t, float64(0)) // fails \tfmt.Println(ok) ok = td.CmpNotZero(t, 12) fmt.Println(ok) ok = td.CmpNotZero(t, (map[string]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = td.CmpNotZero(t, map[string]int{}) // succeeds, as not nil \tfmt.Println(ok) ok = td.CmpNotZero(t, ([]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = td.CmpNotZero(t, []int{}) // succeeds, as not nil \tfmt.Println(ok) ok = td.CmpNotZero(t, [3]int{}) // fails \tfmt.Println(ok) ok = td.CmpNotZero(t, [3]int{0, 1}) // succeeds, DATA[1] is not 0 \tfmt.Println(ok) ok = td.CmpNotZero(t, bytes.Buffer{}) // fails \tfmt.Println(ok) ok = td.CmpNotZero(t, \u0026amp;bytes.Buffer{}) // succeeds, as pointer not nil \tfmt.Println(ok) ok = td.Cmp(t, \u0026amp;bytes.Buffer{}, td.Ptr(td.NotZero())) // fails as deref by Ptr() \tfmt.Println(ok) // Output: \t// false \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false     T.NotZero shortcut func (t *T) NotZero(got interface{}, args ...interface{}) bool NotZero is a shortcut for:\nt.Cmp(got, td.NotZero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.NotZero godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) ok := t.NotZero(0) // fails \tfmt.Println(ok) ok = t.NotZero(float64(0)) // fails \tfmt.Println(ok) ok = t.NotZero(12) fmt.Println(ok) ok = t.NotZero((map[string]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = t.NotZero(map[string]int{}) // succeeds, as not nil \tfmt.Println(ok) ok = t.NotZero(([]int)(nil)) // fails, as nil \tfmt.Println(ok) ok = t.NotZero([]int{}) // succeeds, as not nil \tfmt.Println(ok) ok = t.NotZero([3]int{}) // fails \tfmt.Println(ok) ok = t.NotZero([3]int{0, 1}) // succeeds, DATA[1] is not 0 \tfmt.Println(ok) ok = t.NotZero(bytes.Buffer{}) // fails \tfmt.Println(ok) ok = t.NotZero(\u0026amp;bytes.Buffer{}) // succeeds, as pointer not nil \tfmt.Println(ok) ok = t.Cmp(\u0026amp;bytes.Buffer{}, td.Ptr(td.NotZero())) // fails as deref by Ptr() \tfmt.Println(ok) // Output: \t// false \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false     "},{"uri":"https://go-testdeep.zetta.rocks/operators/pptr/","title":"PPtr","tags":[],"description":"","content":"func PPtr(val interface{}) TestDeep PPtr is a smuggler operator. It takes the address of the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an **int, one can have:\nnum := 12 pnum = \u0026amp;num td.Cmp(t, \u0026amp;pnum, td.PPtr(12)) // succeeds as well as an other operator:\nnum := 3 pnum = \u0026amp;num td.Cmp(t, \u0026amp;pnum, td.PPtr(td.Between(3, 4))) // succeeds It is more efficient and shorter to write than:\ntd.Cmp(t, \u0026amp;pnum, td.Ptr(td.Ptr(val))) // succeeds too TypeBehind method returns the reflect.Type of a pointer on a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on a pointer on the returned value (if non-nil of course).\n See also PPtr godoc.\n Example   Base example   t := \u0026amp;testing.T{} num := 12 got := \u0026amp;num ok := td.Cmp(t, \u0026amp;got, td.PPtr(12)) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.PPtr(td.Between(4, 15))) fmt.Println(ok) // Output: \t// true \t// true     CmpPPtr shortcut func CmpPPtr(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpPPtr is a shortcut for:\ntd.Cmp(t, got, td.PPtr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpPPtr godoc.\n Example   Base example   t := \u0026amp;testing.T{} num := 12 got := \u0026amp;num ok := td.CmpPPtr(t, \u0026amp;got, 12) fmt.Println(ok) ok = td.CmpPPtr(t, \u0026amp;got, td.Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true     T.PPtr shortcut func (t *T) PPtr(got interface{}, val interface{}, args ...interface{}) bool PPtr is a shortcut for:\nt.Cmp(got, td.PPtr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.PPtr godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) num := 12 got := \u0026amp;num ok := t.PPtr(\u0026amp;got, 12) fmt.Println(ok) ok = t.PPtr(\u0026amp;got, td.Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/ptr/","title":"Ptr","tags":[],"description":"","content":"func Ptr(val interface{}) TestDeep Ptr is a smuggler operator. It takes the address of data and compares it to val.\nval depends on data type. For example, if the compared data is an *int, one can have:\nnum := 12 td.Cmp(t, \u0026amp;num, td.Ptr(12)) // succeeds as well as an other operator:\nnum := 3 td.Cmp(t, \u0026amp;num, td.Ptr(td.Between(3, 4))) TypeBehind method returns the reflect.Type of a pointer on val, except if val is a TestDeep operator. In this case, it delegates TypeBehind() to the operator and returns the reflect.Type of a pointer on the returned value (if non-nil of course).\n See also Ptr godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 12 ok := td.Cmp(t, \u0026amp;got, td.Ptr(12)) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Ptr(td.Between(4, 15))) fmt.Println(ok) // Output: \t// true \t// true     CmpPtr shortcut func CmpPtr(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpPtr is a shortcut for:\ntd.Cmp(t, got, td.Ptr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpPtr godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := 12 ok := td.CmpPtr(t, \u0026amp;got, 12) fmt.Println(ok) ok = td.CmpPtr(t, \u0026amp;got, td.Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true     T.Ptr shortcut func (t *T) Ptr(got interface{}, val interface{}, args ...interface{}) bool Ptr is a shortcut for:\nt.Cmp(got, td.Ptr(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Ptr godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := 12 ok := t.Ptr(\u0026amp;got, 12) fmt.Println(ok) ok = t.Ptr(\u0026amp;got, td.Between(4, 15)) fmt.Println(ok) // Output: \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/re/","title":"Re","tags":[],"description":"","content":"func Re(reg interface{}, capture ...interface{}) TestDeep Re operator allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer.)\nreg is the regexp. It can be a string that is automatically compiled using regexp.MustCompile, or a *regexp.Regexp.\nOptional capture parameter can be used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.\ntd.Cmp(t, \u0026#34;foobar zip!\u0026#34;, td.Re(`^foobar`)) // succeeds td.Cmp(t, \u0026#34;John Doe\u0026#34;, td.Re(`^(\\w+) (\\w+)`, []string{\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;})) // succeeds td.Cmp(t, \u0026#34;John Doe\u0026#34;, td.Re(`^(\\w+) (\\w+)`, td.Bag(\u0026#34;Doe\u0026#34;, \u0026#34;John\u0026#34;))) // succeeds  See also Re godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar\u0026#34; ok := td.Cmp(t, got, td.Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = td.Cmp(t, got, td.Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := td.Cmp(t, got, td.Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foo bar\u0026#34;) ok := td.Cmp(t, got, td.Re(\u0026#34;(zip|bar)$\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := td.Cmp(t, got, td.Re(`^(\\w+) (\\w+) (\\w+)$`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = td.Cmp(t, got, td.Re(`^(\\w+) (\\w+) (\\w+)$`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       Compiled example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := \u0026#34;foo bar\u0026#34; ok := td.Cmp(t, got, td.Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = td.Cmp(t, got, td.Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledStringer example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := td.Cmp(t, got, td.Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       CompiledError example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := td.Cmp(t, got, td.Re(expected), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \u0026#34;foo bar biz\u0026#34; ok := td.Cmp(t, got, td.Re(expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = td.Cmp(t, got, td.Re(expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false    \nCmpRe shortcut func CmpRe(t TestingT, got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool CmpRe is a shortcut for:\ntd.Cmp(t, got, td.Re(reg, capture), args...) See above for details.\nRe() optional parameter capture is here mandatory. nil value should be passed to mimic its absence in original Re() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpRe godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar\u0026#34; ok := td.CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = td.CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := td.CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foo bar\u0026#34;) ok := td.CmpRe(t, got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := td.CmpRe(t, got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = td.CmpRe(t, got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       Compiled example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := \u0026#34;foo bar\u0026#34; ok := td.CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = td.CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledStringer example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := td.CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       CompiledError example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := td.CmpRe(t, got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \u0026#34;foo bar biz\u0026#34; ok := td.CmpRe(t, got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = td.CmpRe(t, got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false    \nT.Re shortcut func (t *T) Re(got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool Re is a shortcut for:\nt.Cmp(got, td.Re(reg, capture), args...) See above for details.\nRe() optional parameter capture is here mandatory. nil value should be passed to mimic its absence in original Re() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Re godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foo bar\u0026#34; ok := t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       Stringer example   t := td.NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := td.NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, \u0026#34;(zip|bar)$\u0026#34;, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Capture example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foo bar biz\u0026#34; ok := t.Re(got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = t.Re(got, `^(\\w+) (\\w+) (\\w+)$`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       Compiled example   t := td.NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := \u0026#34;foo bar\u0026#34; ok := t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;bar foo\u0026#34; ok = t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledStringer example   t := td.NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       CompiledError example   t := td.NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(\u0026#34;(zip|bar)$\u0026#34;) got := errors.New(\u0026#34;foo bar\u0026#34;) ok := t.Re(got, expected, nil, \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       CompiledCapture example   t := td.NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(`^(\\w+) (\\w+) (\\w+)$`) got := \u0026#34;foo bar biz\u0026#34; ok := t.Re(got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) got = \u0026#34;foo bar! biz\u0026#34; ok = t.Re(got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/reall/","title":"ReAll","tags":[],"description":"","content":"func ReAll(reg interface{}, capture interface{}) TestDeep ReAll operator allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interface (error interface is tested before fmt.Stringer) and to match its groups contents.\nreg is the regexp. It can be a string that is automatically compiled using regexp.MustCompile, or a *regexp.Regexp.\ncapture is used to match the contents of regexp groups. Groups are presented as a []string or [][]byte depending the original matched data. Note that an other operator can be used here.\ntd.Cmp(t, \u0026#34;John Doe\u0026#34;, td.ReAll(`(\\w+)(?: |\\z)`, []string{\u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;})) // succeeds td.Cmp(t, \u0026#34;John Doe\u0026#34;, td.ReAll(`(\\w+)(?: |\\z)`, td.Bag(\u0026#34;Doe\u0026#34;, \u0026#34;John\u0026#34;))) // succeeds  See also ReAll godoc.\n Examples    Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := td.Cmp(t, got, td.ReAll(`(\\w+)`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = td.Cmp(t, got, td.ReAll(`(\\w+)`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CaptureComplex example   t := \u0026amp;testing.T{} got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := td.Cmp(t, got, td.ReAll(`(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = td.Cmp(t, got, td.ReAll(`(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\w+)`) got := \u0026#34;foo bar biz\u0026#34; ok := td.Cmp(t, got, td.ReAll(expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = td.Cmp(t, got, td.ReAll(expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;)), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledCaptureComplex example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\d+)`) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := td.Cmp(t, got, td.ReAll(expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = td.Cmp(t, got, td.ReAll(expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 }))), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false    \nCmpReAll shortcut func CmpReAll(t TestingT, got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool CmpReAll is a shortcut for:\ntd.Cmp(t, got, td.ReAll(reg, capture), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpReAll godoc.\n Examples    Capture example   t := \u0026amp;testing.T{} got := \u0026#34;foo bar biz\u0026#34; ok := td.CmpReAll(t, got, `(\\w+)`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = td.CmpReAll(t, got, `(\\w+)`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CaptureComplex example   t := \u0026amp;testing.T{} got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := td.CmpReAll(t, got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = td.CmpReAll(t, got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledCapture example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\w+)`) got := \u0026#34;foo bar biz\u0026#34; ok := td.CmpReAll(t, got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = td.CmpReAll(t, got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledCaptureComplex example   t := \u0026amp;testing.T{} expected := regexp.MustCompile(`(\\d+)`) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := td.CmpReAll(t, got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = td.CmpReAll(t, got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false    \nT.ReAll shortcut func (t *T) ReAll(got interface{}, reg interface{}, capture interface{}, args ...interface{}) bool ReAll is a shortcut for:\nt.Cmp(got, td.ReAll(reg, capture), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.ReAll godoc.\n Examples    Capture example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foo bar biz\u0026#34; ok := t.ReAll(got, `(\\w+)`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = t.ReAll(got, `(\\w+)`, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CaptureComplex example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := t.ReAll(got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = t.ReAll(got, `(\\d+)`, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledCapture example   t := td.NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(`(\\w+)`) got := \u0026#34;foo bar biz\u0026#34; ok := t.ReAll(got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but all catured groups do not match Set \tgot = \u0026#34;foo BAR biz\u0026#34; ok = t.ReAll(got, expected, td.Set(\u0026#34;biz\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false       CompiledCaptureComplex example   t := td.NewT(\u0026amp;testing.T{}) expected := regexp.MustCompile(`(\\d+)`) got := \u0026#34;11 45 23 56 85 96\u0026#34; ok := t.ReAll(got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 10 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Matches, but 11 is not greater than 20 \tok = t.ReAll(got, expected, td.ArrayEach(td.Code(func(num string) bool { n, err := strconv.Atoi(num) return err == nil \u0026amp;\u0026amp; n \u0026gt; 20 \u0026amp;\u0026amp; n \u0026lt; 100 })), \u0026#34;checks value %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/set/","title":"Set","tags":[],"description":"","content":"func Set(expectedItems ...interface{}) TestDeep Set operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice, and each array/slice item should be matched by an expected item to succeed.\ntd.Cmp(t, []int{1, 1, 2}, td.Set(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(2, 1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.Set(1, 2, 3)) // fails, 3 is missing  // works with slices/arrays of any type td.Cmp(t, personSlice, td.Set( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{2, 1} td.Cmp(t, []int{1, 1, 2}, td.Set(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1, 2}, td.Set(2, 1))  exp1 := []int{2, 1} exp2 := []int{5, 8} td.Cmp(t, []int{1, 5, 1, 2, 8, 3, 3}, td.Set(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 2, 8, 3, 3}, td.Set(2, 1, 3, 5, 8))  See also Set godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates \tok := td.Cmp(t, got, td.Set(1, 2, 3, 5, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Duplicates are ignored in a Set \tok = td.Cmp(t, got, td.Set(1, 2, 2, 2, 2, 2, 3, 5, 8), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several Set entries \tok = td.Cmp(t, got, td.Set(td.Between(1, 4), 3, td.Between(2, 10)), \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5, 8} ok = td.Cmp(t, got, td.Set(td.Flatten(expected)), \u0026#34;checks all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     CmpSet shortcut func CmpSet(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSet is a shortcut for:\ntd.Cmp(t, got, td.Set(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSet godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates \tok := td.CmpSet(t, got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Duplicates are ignored in a Set \tok = td.CmpSet(t, got, []interface{}{1, 2, 2, 2, 2, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several Set entries \tok = td.CmpSet(t, got, []interface{}{td.Between(1, 4), 3, td.Between(2, 10)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5, 8} ok = td.CmpSet(t, got, []interface{}{td.Flatten(expected)}, \u0026#34;checks all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     T.Set shortcut func (t *T) Set(got interface{}, expectedItems []interface{}, args ...interface{}) bool Set is a shortcut for:\nt.Cmp(got, td.Set(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Set godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are present, ignoring duplicates \tok := t.Set(got, []interface{}{1, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Duplicates are ignored in a Set \tok = t.Set(got, []interface{}{1, 2, 2, 2, 2, 2, 3, 5, 8}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several Set entries \tok = t.Set(got, []interface{}{td.Between(1, 4), 3, td.Between(2, 10)}, \u0026#34;checks all items are present, in any order\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5, 8} ok = t.Set(got, []interface{}{td.Flatten(expected)}, \u0026#34;checks all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/shallow/","title":"Shallow","tags":[],"description":"","content":"func Shallow(expectedPtr interface{}) TestDeep Shallow operator compares pointers only, not their contents. It applies on channels, functions (with some restrictions), maps, pointers, slices and strings.\nDuring a match, the compared data must be the same as expectedPtr to succeed.\na, b := 123, 123 td.Cmp(t, \u0026amp;a, td.Shallow(\u0026amp;a)) // succeeds td.Cmp(t, \u0026amp;a, td.Shallow(\u0026amp;b)) // fails even if a == b as \u0026amp;a != \u0026amp;b  back := \u0026#34;foobarfoobar\u0026#34; a, b := back[:6], back[6:] // a == b but... td.Cmp(t, \u0026amp;a, td.Shallow(\u0026amp;b)) // fails Be careful for slices and strings! Shallow can succeed but the slices/strings not be identical because of their different lengths. For example:\na := \u0026#34;foobar yes!\u0026#34; b := a[:1] // aka \u0026#34;f\u0026#34; td.Cmp(t, \u0026amp;a, td.Shallow(\u0026amp;b)) // succeeds as both strings point to the same area, even if len() differ The same behavior occurs for slices:\na := []int{1, 2, 3, 4, 5, 6} b := a[:2] // aka []int{1, 2} td.Cmp(t, \u0026amp;a, td.Shallow(\u0026amp;b)) // succeeds as both slices point to the same area, even if len() differ  See also Shallow godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026amp;data ok := td.Cmp(t, got, td.Shallow(\u0026amp;data), \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Same contents, but not same pointer \tok = td.Cmp(t, got, td.Shallow(\u0026amp;MyStruct{Value: 12}), \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false       Slice example   t := \u0026amp;testing.T{} back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := td.Cmp(t, a, td.Shallow(back)) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = td.Cmp(t, b, td.Shallow(back)) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false       String example   t := \u0026amp;testing.T{} back := \u0026#34;foobarfoobar\u0026#34; a := back[:6] b := back[6:] ok := td.Cmp(t, a, td.Shallow(back)) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = td.Cmp(t, b, td.Shallow(a)) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false    \nCmpShallow shortcut func CmpShallow(t TestingT, got interface{}, expectedPtr interface{}, args ...interface{}) bool CmpShallow is a shortcut for:\ntd.Cmp(t, got, td.Shallow(expectedPtr), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpShallow godoc.\n Examples    Base example   t := \u0026amp;testing.T{} type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026amp;data ok := td.CmpShallow(t, got, \u0026amp;data, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Same contents, but not same pointer \tok = td.CmpShallow(t, got, \u0026amp;MyStruct{Value: 12}, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false       Slice example   t := \u0026amp;testing.T{} back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := td.CmpShallow(t, a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = td.CmpShallow(t, b, back) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false       String example   t := \u0026amp;testing.T{} back := \u0026#34;foobarfoobar\u0026#34; a := back[:6] b := back[6:] ok := td.CmpShallow(t, a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = td.CmpShallow(t, b, a) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false    \nT.Shallow shortcut func (t *T) Shallow(got interface{}, expectedPtr interface{}, args ...interface{}) bool Shallow is a shortcut for:\nt.Cmp(got, td.Shallow(expectedPtr), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Shallow godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) type MyStruct struct { Value int } data := MyStruct{Value: 12} got := \u0026amp;data ok := t.Shallow(got, \u0026amp;data, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Same contents, but not same pointer \tok = t.Shallow(got, \u0026amp;MyStruct{Value: 12}, \u0026#34;checks pointers only, not contents\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false       Slice example   t := td.NewT(\u0026amp;testing.T{}) back := []int{1, 2, 3, 1, 2, 3} a := back[:3] b := back[3:] ok := t.Shallow(a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = t.Shallow(b, back) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false       String example   t := td.NewT(\u0026amp;testing.T{}) back := \u0026#34;foobarfoobar\u0026#34; a := back[:6] b := back[6:] ok := t.Shallow(a, back) fmt.Println(\u0026#34;are ≠ but share the same area:\u0026#34;, ok) ok = t.Shallow(b, a) fmt.Println(\u0026#34;are = but do not point to same area:\u0026#34;, ok) // Output: \t// are ≠ but share the same area: true \t// are = but do not point to same area: false    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/slice/","title":"Slice","tags":[],"description":"","content":"func Slice(model interface{}, expectedEntries ArrayEntries) TestDeep Slice operator compares the contents of a slice or a pointer on a slice against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\ngot := []int{12, 14, 17} td.Cmp(t, got, td.Slice([]int{0, 14}, td.ArrayEntries{0: 12, 2: 17})) // succeeds td.Cmp(t, got, td.Slice([]int{0, 14}, td.ArrayEntries{0: td.Gt(10), 2: td.Gt(15)})) // succeeds TypeBehind method returns the reflect.Type of model.\n See also Slice godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := td.Cmp(t, got, td.Slice([]int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Slice([]int{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, got, td.Slice(([]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true       TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.Cmp(t, got, td.Slice(MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \u0026#34;checks typed slice %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Slice(\u0026amp;MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}), \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Slice(\u0026amp;MySlice{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.Slice((*MySlice)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}), \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \nCmpSlice shortcut func CmpSlice(t TestingT, got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool CmpSlice is a shortcut for:\ntd.Cmp(t, got, td.Slice(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSlice godoc.\n Examples    Slice example   t := \u0026amp;testing.T{} got := []int{42, 58, 26} ok := td.CmpSlice(t, got, []int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpSlice(t, got, []int{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpSlice(t, got, ([]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true       TypedSlice example   t := \u0026amp;testing.T{} type MySlice []int got := MySlice{42, 58, 26} ok := td.CmpSlice(t, got, MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks typed slice %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpSlice(t, \u0026amp;got, \u0026amp;MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpSlice(t, \u0026amp;got, \u0026amp;MySlice{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = td.CmpSlice(t, \u0026amp;got, (*MySlice)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \nT.Slice shortcut func (t *T) Slice(got interface{}, model interface{}, expectedEntries ArrayEntries, args ...interface{}) bool Slice is a shortcut for:\nt.Cmp(got, td.Slice(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Slice godoc.\n Examples    Slice example   t := td.NewT(\u0026amp;testing.T{}) got := []int{42, 58, 26} ok := t.Slice(got, []int{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(got, []int{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(got, ([]int)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true       TypedSlice example   t := td.NewT(\u0026amp;testing.T{}) type MySlice []int got := MySlice{42, 58, 26} ok := t.Slice(got, MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks typed slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(\u0026amp;got, \u0026amp;MySlice{42}, td.ArrayEntries{1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(\u0026amp;got, \u0026amp;MySlice{}, td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) ok = t.Slice(\u0026amp;got, (*MySlice)(nil), td.ArrayEntries{0: 42, 1: 58, 2: td.Ignore()}, \u0026#34;checks pointer on typed slice %v\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/smuggle/","title":"Smuggle","tags":[],"description":"","content":"func Smuggle(fn interface{}, expectedValue interface{}) TestDeep Smuggle operator allows to change data contents or mutate it into another type before stepping down in favor of generic comparison process. Of course it is a smuggler operator. So fn is a function that must take one parameter whose type must be convertible to the type of the compared value (as a convenient shortcut, fn can be a string specifying a fields-path through structs, see below for details).\nfn must return at least one value. These value will be compared as is to expectedValue, here integer 28:\ntd.Cmp(t, \u0026#34;0028\u0026#34;, td.Smuggle(func(value string) int { num, _ := strconv.Atoi(value) return num }, 28), ) or using an other TestDeep operator, here Between(28, 30):\ntd.Cmp(t, \u0026#34;0029\u0026#34;, td.Smuggle(func(value string) int { num, _ := strconv.Atoi(value) return num }, td.Between(28, 30)), ) fn can return a second boolean value, used to tell that a problem occurred and so stop the comparison:\ntd.Cmp(t, \u0026#34;0029\u0026#34;, td.Smuggle(func(value string) (int, bool) { num, err := strconv.Atoi(value) return num, err == nil }, td.Between(28, 30)), ) fn can return a third string value which is used to describe the test when a problem occurred (false second boolean value):\ntd.Cmp(t, \u0026#34;0029\u0026#34;, td.Smuggle(func(value string) (int, bool, string) { num, err := strconv.Atoi(value) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return num, true, \u0026#34;\u0026#34; }, td.Between(28, 30)), ) Instead of returning (X, bool) or (X, bool, string), fn can return (X, error). When a problem occurs, the returned error is non-nil, as in:\ntd.Cmp(t, \u0026#34;0029\u0026#34;, td.Smuggle(func(value string) (int, error) { num, err := strconv.Atoi(value) return num, err }, td.Between(28, 30)), ) Which can be simplified to:\ntd.Cmp(t, \u0026#34;0029\u0026#34;, td.Smuggle(strconv.Atoi, td.Between(28, 30))) Imagine you want to compare that the Year of a date is between 2010 and 2020:\ntd.Cmp(t, time.Date(2015, time.May, 1, 1, 2, 3, 0, time.UTC), td.Smuggle(func(date time.Time) int { return date.Year() }, td.Between(2010, 2020)), ) In this case the data location forwarded to next test will be something like \u0026ldquo;DATA.MyTimeField\u0026rdquo;, but you can act on it too by returning a SmuggledGot struct (by value or by address):\ntd.Cmp(t, time.Date(2015, time.May, 1, 1, 2, 3, 0, time.UTC), td.Smuggle(func(date time.Time) SmuggledGot { return SmuggledGot{ Name: \u0026#34;Year\u0026#34;, Got: date.Year(), } }, td.Between(2010, 2020)), ) then the data location forwarded to next test will be something like \u0026ldquo;DATA.MyTimeField.Year\u0026rdquo;. The \u0026ldquo;.\u0026rdquo; between the current path (here \u0026ldquo;DATA.MyTimeField\u0026rdquo;) and the returned Name \u0026ldquo;Year\u0026rdquo; is automatically added when Name starts with a Letter.\nNote that SmuggledGot and SmuggledGot returns are treated equally, and they are only used when fn has only one returned value or when the second boolean returned value is true.\nOf course, all cases can go together:\n// Accepts a \u0026#34;YYYY/mm/DD HH:MM:SS\u0026#34; string to produce a time.Time and tests // whether this date is contained between 2 hours before now and now. td.Cmp(t, \u0026#34;2020-01-25 12:13:14\u0026#34;, td.Smuggle(func(date string) (*SmuggledGot, bool, string) { date, err := time.Parse(\u0026#34;2006/01/02 15:04:05\u0026#34;, date) if err != nil { return nil, false, `date must conform to \u0026#34;YYYY/mm/DD HH:MM:SS\u0026#34; format` } return \u0026amp;SmuggledGot{ Name: \u0026#34;Date\u0026#34;, Got: date, }, true, \u0026#34;\u0026#34; }, td.Between(time.Now().Add(-2*time.Hour), time.Now())), ) or:\n// Accepts a \u0026#34;YYYY/mm/DD HH:MM:SS\u0026#34; string to produce a time.Time and tests // whether this date is contained between 2 hours before now and now. td.Cmp(t, \u0026#34;2020-01-25 12:13:14\u0026#34;, td.Smuggle(func(date string) (*SmuggledGot, error) { date, err := time.Parse(\u0026#34;2006/01/02 15:04:05\u0026#34;, date) if err != nil { return nil, err } return \u0026amp;SmuggledGot{ Name: \u0026#34;Date\u0026#34;, Got: date, }, nil }, td.Between(time.Now().Add(-2*time.Hour), time.Now())), ) Smuggle can also be used to access a struct field embedded in several struct layers.\ntype A struct{ Num int } type B struct{ A *A } type C struct{ B B } got := C{B: B{A: \u0026amp;A{Num: 12}}} // Tests that got.B.A.Num is 12 td.Cmp(t, got, td.Smuggle(func(c C) int { return c.B.A.Num }, 12)) As brought up above, a field-path can be passed as fn value instead of a function pointer. Using this feature, the Cmp call in the above example can be rewritten as follows:\n// Tests that got.B.A.Num is 12 td.Cmp(t, got, td.Smuggle(\u0026#34;B.A.Num\u0026#34;, 12)) Behind the scenes, a temporary function is automatically created to achieve the same goal, but add some checks against nil values and auto-dereference interfaces and pointers.\nThe difference between Smuggle and Code operators is that Code is used to do a final comparison while Smuggle transforms the data and then steps down in favor of generic comparison process. Moreover, the type accepted as input for the function is more lax to facilitate the tests writing (e.g. the function can accept a float64 and the got value be an int). See examples. On the other hand, the output type is strict and must match exactly the expected value type. The fields-path string fn shortcut is not available with Code operator.\nTypeBehind method returns the reflect.Type of only parameter of fn. For the case where fn is a fields-path, it is always interface{}, as the type can not be known in advance.\n See also Smuggle godoc.\n Examples    Convert example   t := \u0026amp;testing.T{} got := int64(123) ok := td.Cmp(t, got, td.Smuggle(func(n int64) int { return int(n) }, 123), \u0026#34;checks int64 got against an int value\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, \u0026#34;123\u0026#34;, td.Smuggle( func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, td.Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, \u0026#34;123\u0026#34;, td.Smuggle( func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return n, true, \u0026#34;\u0026#34; }, td.Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, \u0026#34;123\u0026#34;, td.Smuggle( func(numStr string) (int, error) { return strconv.Atoi(numStr) }, td.Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Short version :) \tok = td.Cmp(t, \u0026#34;123\u0026#34;, td.Smuggle(strconv.Atoi, td.Between(120, 130)), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true \t// true       Lax example   t := \u0026amp;testing.T{} // got is an int16 and Smuggle func input is an int64: it is OK \tgot := int(123) ok := td.Cmp(t, got, td.Smuggle(func(n int64) uint32 { return uint32(n) }, uint32(123))) fmt.Println(\u0026#34;got int16(123) → smuggle via int64 → uint32(123):\u0026#34;, ok) // Output: \t// got int16(123) → smuggle via int64 → uint32(123): true       Auto_unmarshal example   t := \u0026amp;testing.T{} // Automatically json.Unmarshal to compare \tgot := []byte(`{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}`) ok := td.Cmp(t, got, td.Smuggle( func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026amp;r) return }, map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, })) fmt.Println(\u0026#34;JSON contents is OK:\u0026#34;, ok) // Output: \t// JSON contents is OK: true       Complex example   t := \u0026amp;testing.T{} // No end date but a start date and a duration \ttype StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h \t// for each of these durations in hours  for _, duration := range []time.Duration{48, 72, 96} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration * time.Hour, } // Simplest way, but in case of Between() failure, error will be bound \t// to DATA\u0026lt;smuggled\u0026gt;, not very clear... \tok := td.Cmp(t, got, td.Smuggle( func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC)))) fmt.Println(ok) // Name the computed value \u0026#34;ComputedEndDate\u0026#34; to render a Between() failure \t// more understandable, so error will be bound to DATA.ComputedEndDate \tok = td.Cmp(t, got, td.Smuggle( func(sd StartDuration) td.SmuggledGot { return td.SmuggledGot{ Name: \u0026#34;ComputedEndDate\u0026#34;, Got: sd.StartDate.Add(sd.Duration), } }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC)))) fmt.Println(ok) } // Output: \t// false \t// false \t// true \t// true \t// true \t// true       Interface example   t := \u0026amp;testing.T{} gotTime, err := time.Parse(time.RFC3339, \u0026#34;2018-05-23T12:13:14Z\u0026#34;) if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form \tok := td.Cmp(t, gotTime, td.Smuggle(func(s fmt.Stringer) string { return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;)) fmt.Println(\u0026#34;stringified time.Time OK:\u0026#34;, ok) // If got does not implement the fmt.Stringer interface, it fails \t// without calling the Smuggle func \ttype MyTime time.Time ok = td.Cmp(t, MyTime(gotTime), td.Smuggle(func(s fmt.Stringer) string { fmt.Println(\u0026#34;Smuggle func called!\u0026#34;) return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;)) fmt.Println(\u0026#34;stringified MyTime OK:\u0026#34;, ok) // Output \t// stringified time.Time OK: true \t// stringified MyTime OK: false       Field_path example   t := \u0026amp;testing.T{} type Body struct { Name string Value interface{} } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026amp;Transaction{ Request: Request{ Body: \u0026amp;Body{ Name: \u0026#34;test\u0026#34;, Value: \u0026amp;ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? \tok := td.Cmp(t, got, td.Smuggle( func(t *Transaction) (int, error) { if t.Request.Body == nil || t.Request.Body.Value == nil { return 0, errors.New(\u0026#34;Request.Body or Request.Body.Value is nil\u0026#34;) } if v, ok := t.Request.Body.Value.(*ValueNum); ok \u0026amp;\u0026amp; v != nil { return v.Num, nil } return 0, errors.New(\u0026#34;Request.Body.Value isn\u0026#39;t *ValueNum or nil\u0026#34;) }, td.Between(100, 200))) fmt.Println(\u0026#34;check Num by hand:\u0026#34;, ok) // Same, but automagically generated... \tok = td.Cmp(t, got, td.Smuggle(\u0026#34;Request.Body.Value.Num\u0026#34;, td.Between(100, 200))) fmt.Println(\u0026#34;check Num using a fields-path:\u0026#34;, ok) // And as Request is an anonymous field, can be simplified further \t// as it can be omitted \tok = td.Cmp(t, got, td.Smuggle(\u0026#34;Body.Value.Num\u0026#34;, td.Between(100, 200))) fmt.Println(\u0026#34;check Num using an other fields-path:\u0026#34;, ok) // Output: \t// check Num by hand: true \t// check Num using a fields-path: true \t// check Num using an other fields-path: true    \nCmpSmuggle shortcut func CmpSmuggle(t TestingT, got interface{}, fn interface{}, expectedValue interface{}, args ...interface{}) bool CmpSmuggle is a shortcut for:\ntd.Cmp(t, got, td.Smuggle(fn, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSmuggle godoc.\n Examples    Convert example   t := \u0026amp;testing.T{} got := int64(123) ok := td.CmpSmuggle(t, got, func(n int64) int { return int(n) }, 123, \u0026#34;checks int64 got against an int value\u0026#34;) fmt.Println(ok) ok = td.CmpSmuggle(t, \u0026#34;123\u0026#34;, func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = td.CmpSmuggle(t, \u0026#34;123\u0026#34;, func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return n, true, \u0026#34;\u0026#34; }, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = td.CmpSmuggle(t, \u0026#34;123\u0026#34;, func(numStr string) (int, error) { return strconv.Atoi(numStr) }, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Short version :) \tok = td.CmpSmuggle(t, \u0026#34;123\u0026#34;, strconv.Atoi, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true \t// true       Lax example   t := \u0026amp;testing.T{} // got is an int16 and Smuggle func input is an int64: it is OK \tgot := int(123) ok := td.CmpSmuggle(t, got, func(n int64) uint32 { return uint32(n) }, uint32(123)) fmt.Println(\u0026#34;got int16(123) → smuggle via int64 → uint32(123):\u0026#34;, ok) // Output: \t// got int16(123) → smuggle via int64 → uint32(123): true       Auto_unmarshal example   t := \u0026amp;testing.T{} // Automatically json.Unmarshal to compare \tgot := []byte(`{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}`) ok := td.CmpSmuggle(t, got, func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026amp;r) return }, map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, }) fmt.Println(\u0026#34;JSON contents is OK:\u0026#34;, ok) // Output: \t// JSON contents is OK: true       Complex example   t := \u0026amp;testing.T{} // No end date but a start date and a duration \ttype StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h \t// for each of these durations in hours  for _, duration := range []time.Duration{48, 72, 96} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration * time.Hour, } // Simplest way, but in case of Between() failure, error will be bound \t// to DATA\u0026lt;smuggled\u0026gt;, not very clear... \tok := td.CmpSmuggle(t, got, func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) // Name the computed value \u0026#34;ComputedEndDate\u0026#34; to render a Between() failure \t// more understandable, so error will be bound to DATA.ComputedEndDate \tok = td.CmpSmuggle(t, got, func(sd StartDuration) td.SmuggledGot { return td.SmuggledGot{ Name: \u0026#34;ComputedEndDate\u0026#34;, Got: sd.StartDate.Add(sd.Duration), } }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) } // Output: \t// false \t// false \t// true \t// true \t// true \t// true       Interface example   t := \u0026amp;testing.T{} gotTime, err := time.Parse(time.RFC3339, \u0026#34;2018-05-23T12:13:14Z\u0026#34;) if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form \tok := td.CmpSmuggle(t, gotTime, func(s fmt.Stringer) string { return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified time.Time OK:\u0026#34;, ok) // If got does not implement the fmt.Stringer interface, it fails \t// without calling the Smuggle func \ttype MyTime time.Time ok = td.CmpSmuggle(t, MyTime(gotTime), func(s fmt.Stringer) string { fmt.Println(\u0026#34;Smuggle func called!\u0026#34;) return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified MyTime OK:\u0026#34;, ok) // Output \t// stringified time.Time OK: true \t// stringified MyTime OK: false       Field_path example   t := \u0026amp;testing.T{} type Body struct { Name string Value interface{} } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026amp;Transaction{ Request: Request{ Body: \u0026amp;Body{ Name: \u0026#34;test\u0026#34;, Value: \u0026amp;ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? \tok := td.CmpSmuggle(t, got, func(t *Transaction) (int, error) { if t.Request.Body == nil || t.Request.Body.Value == nil { return 0, errors.New(\u0026#34;Request.Body or Request.Body.Value is nil\u0026#34;) } if v, ok := t.Request.Body.Value.(*ValueNum); ok \u0026amp;\u0026amp; v != nil { return v.Num, nil } return 0, errors.New(\u0026#34;Request.Body.Value isn\u0026#39;t *ValueNum or nil\u0026#34;) }, td.Between(100, 200)) fmt.Println(\u0026#34;check Num by hand:\u0026#34;, ok) // Same, but automagically generated... \tok = td.CmpSmuggle(t, got, \u0026#34;Request.Body.Value.Num\u0026#34;, td.Between(100, 200)) fmt.Println(\u0026#34;check Num using a fields-path:\u0026#34;, ok) // And as Request is an anonymous field, can be simplified further \t// as it can be omitted \tok = td.CmpSmuggle(t, got, \u0026#34;Body.Value.Num\u0026#34;, td.Between(100, 200)) fmt.Println(\u0026#34;check Num using an other fields-path:\u0026#34;, ok) // Output: \t// check Num by hand: true \t// check Num using a fields-path: true \t// check Num using an other fields-path: true    \nT.Smuggle shortcut func (t *T) Smuggle(got interface{}, fn interface{}, expectedValue interface{}, args ...interface{}) bool Smuggle is a shortcut for:\nt.Cmp(got, td.Smuggle(fn, expectedValue), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Smuggle godoc.\n Examples    Convert example   t := td.NewT(\u0026amp;testing.T{}) got := int64(123) ok := t.Smuggle(got, func(n int64) int { return int(n) }, 123, \u0026#34;checks int64 got against an int value\u0026#34;) fmt.Println(ok) ok = t.Smuggle(\u0026#34;123\u0026#34;, func(numStr string) (int, bool) { n, err := strconv.Atoi(numStr) return n, err == nil }, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = t.Smuggle(\u0026#34;123\u0026#34;, func(numStr string) (int, bool, string) { n, err := strconv.Atoi(numStr) if err != nil { return 0, false, \u0026#34;string must contain a number\u0026#34; } return n, true, \u0026#34;\u0026#34; }, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) ok = t.Smuggle(\u0026#34;123\u0026#34;, func(numStr string) (int, error) { return strconv.Atoi(numStr) }, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Short version :) \tok = t.Smuggle(\u0026#34;123\u0026#34;, strconv.Atoi, td.Between(120, 130), \u0026#34;checks that number in %#v is in [120 .. 130]\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true \t// true       Lax example   t := td.NewT(\u0026amp;testing.T{}) // got is an int16 and Smuggle func input is an int64: it is OK \tgot := int(123) ok := t.Smuggle(got, func(n int64) uint32 { return uint32(n) }, uint32(123)) fmt.Println(\u0026#34;got int16(123) → smuggle via int64 → uint32(123):\u0026#34;, ok) // Output: \t// got int16(123) → smuggle via int64 → uint32(123): true       Auto_unmarshal example   t := td.NewT(\u0026amp;testing.T{}) // Automatically json.Unmarshal to compare \tgot := []byte(`{\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:2}`) ok := t.Smuggle(got, func(b json.RawMessage) (r map[string]int, err error) { err = json.Unmarshal(b, \u0026amp;r) return }, map[string]int{ \u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, }) fmt.Println(\u0026#34;JSON contents is OK:\u0026#34;, ok) // Output: \t// JSON contents is OK: true       Complex example   t := td.NewT(\u0026amp;testing.T{}) // No end date but a start date and a duration \ttype StartDuration struct { StartDate time.Time Duration time.Duration } // Checks that end date is between 17th and 19th February both at 0h \t// for each of these durations in hours  for _, duration := range []time.Duration{48, 72, 96} { got := StartDuration{ StartDate: time.Date(2018, time.February, 14, 12, 13, 14, 0, time.UTC), Duration: duration * time.Hour, } // Simplest way, but in case of Between() failure, error will be bound \t// to DATA\u0026lt;smuggled\u0026gt;, not very clear... \tok := t.Smuggle(got, func(sd StartDuration) time.Time { return sd.StartDate.Add(sd.Duration) }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) // Name the computed value \u0026#34;ComputedEndDate\u0026#34; to render a Between() failure \t// more understandable, so error will be bound to DATA.ComputedEndDate \tok = t.Smuggle(got, func(sd StartDuration) td.SmuggledGot { return td.SmuggledGot{ Name: \u0026#34;ComputedEndDate\u0026#34;, Got: sd.StartDate.Add(sd.Duration), } }, td.Between( time.Date(2018, time.February, 17, 0, 0, 0, 0, time.UTC), time.Date(2018, time.February, 19, 0, 0, 0, 0, time.UTC))) fmt.Println(ok) } // Output: \t// false \t// false \t// true \t// true \t// true \t// true       Interface example   t := td.NewT(\u0026amp;testing.T{}) gotTime, err := time.Parse(time.RFC3339, \u0026#34;2018-05-23T12:13:14Z\u0026#34;) if err != nil { t.Fatal(err) } // Do not check the struct itself, but its stringified form \tok := t.Smuggle(gotTime, func(s fmt.Stringer) string { return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified time.Time OK:\u0026#34;, ok) // If got does not implement the fmt.Stringer interface, it fails \t// without calling the Smuggle func \ttype MyTime time.Time ok = t.Smuggle(MyTime(gotTime), func(s fmt.Stringer) string { fmt.Println(\u0026#34;Smuggle func called!\u0026#34;) return s.String() }, \u0026#34;2018-05-23 12:13:14 +0000 UTC\u0026#34;) fmt.Println(\u0026#34;stringified MyTime OK:\u0026#34;, ok) // Output \t// stringified time.Time OK: true \t// stringified MyTime OK: false       Field_path example   t := td.NewT(\u0026amp;testing.T{}) type Body struct { Name string Value interface{} } type Request struct { Body *Body } type Transaction struct { Request } type ValueNum struct { Num int } got := \u0026amp;Transaction{ Request: Request{ Body: \u0026amp;Body{ Name: \u0026#34;test\u0026#34;, Value: \u0026amp;ValueNum{Num: 123}, }, }, } // Want to check whether Num is between 100 and 200? \tok := t.Smuggle(got, func(t *Transaction) (int, error) { if t.Request.Body == nil || t.Request.Body.Value == nil { return 0, errors.New(\u0026#34;Request.Body or Request.Body.Value is nil\u0026#34;) } if v, ok := t.Request.Body.Value.(*ValueNum); ok \u0026amp;\u0026amp; v != nil { return v.Num, nil } return 0, errors.New(\u0026#34;Request.Body.Value isn\u0026#39;t *ValueNum or nil\u0026#34;) }, td.Between(100, 200)) fmt.Println(\u0026#34;check Num by hand:\u0026#34;, ok) // Same, but automagically generated... \tok = t.Smuggle(got, \u0026#34;Request.Body.Value.Num\u0026#34;, td.Between(100, 200)) fmt.Println(\u0026#34;check Num using a fields-path:\u0026#34;, ok) // And as Request is an anonymous field, can be simplified further \t// as it can be omitted \tok = t.Smuggle(got, \u0026#34;Body.Value.Num\u0026#34;, td.Between(100, 200)) fmt.Println(\u0026#34;check Num using an other fields-path:\u0026#34;, ok) // Output: \t// check Num by hand: true \t// check Num using a fields-path: true \t// check Num using an other fields-path: true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/sstruct/","title":"SStruct","tags":[],"description":"","content":"func SStruct(model interface{}, expectedFields StructFields) TestDeep SStruct operator (aka strict-Struct) compares the contents of a struct or a pointer on a struct against values of model (if any) and the values of expectedFields. The zero values are compared too even if they are omitted from expectedFields: that is the difference with Struct operator.\nmodel must be the same type as compared data.\nexpectedFields can be nil, if no TestDeep operators are involved.\nTo ignore a field, one has to specify it in expectedFields and use the Ignore operator.\ntd.Cmp(t, td.SStruct( Person{ Name: \u0026#34;John Doe\u0026#34;, }, td.StructFields{ Age: td.Between(40, 45), Children: td.Ignore(), }), ) During a match, all expected and zero fields must be found to succeed.\nTypeBehind method returns the reflect.Type of model.\n See also SStruct godoc.\n Example   Base example   t := \u0026amp;testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 0, } // NumChildren is not listed in expected fields so it must be zero \tok := td.Cmp(t, got, td.SStruct(Person{Name: \u0026#34;Foobar\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 50), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tgot.NumChildren = 3 ok = td.Cmp(t, got, td.SStruct(Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = td.Cmp(t, \u0026amp;got, td.SStruct(\u0026amp;Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = td.Cmp(t, \u0026amp;got, td.SStruct((*Person)(nil), td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     CmpSStruct shortcut func CmpSStruct(t TestingT, got interface{}, model interface{}, expectedFields StructFields, args ...interface{}) bool CmpSStruct is a shortcut for:\ntd.Cmp(t, got, td.SStruct(model, expectedFields), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSStruct godoc.\n Example   Base example   t := \u0026amp;testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 0, } // NumChildren is not listed in expected fields so it must be zero \tok := td.CmpSStruct(t, got, Person{Name: \u0026#34;Foobar\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 50), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tgot.NumChildren = 3 ok = td.CmpSStruct(t, got, Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = td.CmpSStruct(t, \u0026amp;got, \u0026amp;Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = td.CmpSStruct(t, \u0026amp;got, (*Person)(nil), td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     T.SStruct shortcut func (t *T) SStruct(got interface{}, model interface{}, expectedFields StructFields, args ...interface{}) bool SStruct is a shortcut for:\nt.Cmp(got, td.SStruct(model, expectedFields), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SStruct godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 0, } // NumChildren is not listed in expected fields so it must be zero \tok := t.SStruct(got, Person{Name: \u0026#34;Foobar\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 50), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tgot.NumChildren = 3 ok = t.SStruct(got, Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = t.SStruct(\u0026amp;got, \u0026amp;Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = t.SStruct(\u0026amp;got, (*Person)(nil), td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/string/","title":"String","tags":[],"description":"","content":"func String(expected string) TestDeep String operator allows to compare a string (or convertible), []byte (or convertible), error or fmt.Stringer interface (error interface is tested before fmt.Stringer).\nerr := errors.New(\u0026#34;error!\u0026#34;) td.Cmp(t, err, td.String(\u0026#34;error!\u0026#34;)) // succeeds  bstr := bytes.NewBufferString(\u0026#34;fmt.Stringer!\u0026#34;) td.Cmp(t, bstr, td.String(\u0026#34;fmt.Stringer!\u0026#34;)) // succeeds  See also String godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.Cmp(t, got, td.String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = td.Cmp(t, []byte(got), td.String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.Cmp(t, got, td.String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \nCmpString shortcut func CmpString(t TestingT, got interface{}, expected string, args ...interface{}) bool CmpString is a shortcut for:\ntd.Cmp(t, got, td.String(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpString godoc.\n Examples    Base example   t := \u0026amp;testing.T{} got := \u0026#34;foobar\u0026#34; ok := td.CmpString(t, got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = td.Cmp(t, []byte(got), td.String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := \u0026amp;testing.T{} // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := td.CmpString(t, got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := \u0026amp;testing.T{} got := errors.New(\u0026#34;foobar\u0026#34;) ok := td.CmpString(t, got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \nT.String shortcut func (t *T) String(got interface{}, expected string, args ...interface{}) bool String is a shortcut for:\nt.Cmp(got, td.String(expected), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.String godoc.\n Examples    Base example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026#34;foobar\u0026#34; ok := t.String(got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using string:\u0026#34;, ok) ok = t.Cmp([]byte(got), td.String(\u0026#34;foobar\u0026#34;), \u0026#34;checks %s\u0026#34;, got) fmt.Println(\u0026#34;using []byte:\u0026#34;, ok) // Output: \t// using string: true \t// using []byte: true       Stringer example   t := td.NewT(\u0026amp;testing.T{}) // bytes.Buffer implements fmt.Stringer \tgot := bytes.NewBufferString(\u0026#34;foobar\u0026#34;) ok := t.String(got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true       Error example   t := td.NewT(\u0026amp;testing.T{}) got := errors.New(\u0026#34;foobar\u0026#34;) ok := t.String(got, \u0026#34;foobar\u0026#34;, \u0026#34;checks %s\u0026#34;, got) fmt.Println(ok) // Output: \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/struct/","title":"Struct","tags":[],"description":"","content":"func Struct(model interface{}, expectedFields StructFields) TestDeep Struct operator compares the contents of a struct or a pointer on a struct against the non-zero values of model (if any) and the values of expectedFields. See SStruct to compares against zero fields without specifying them in expectedFields.\nmodel must be the same type as compared data.\nexpectedFields can be nil, if no zero entries are expected and no TestDeep operators are involved.\ntd.Cmp(t, td.Struct( Person{ Name: \u0026#34;John Doe\u0026#34;, }, td.StructFields{ Age: td.Between(40, 45), Children: 0, }), ) During a match, all expected fields must be found to succeed. Non-expected fields are ignored.\nTypeBehind method returns the reflect.Type of model.\n See also Struct godoc.\n Example   Base example   t := \u0026amp;testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked \tok := td.Cmp(t, got, td.Struct(Person{Name: \u0026#34;Foobar\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 50), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tok = td.Cmp(t, got, td.Struct(Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = td.Cmp(t, \u0026amp;got, td.Struct(\u0026amp;Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = td.Cmp(t, \u0026amp;got, td.Struct((*Person)(nil), td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }), \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     CmpStruct shortcut func CmpStruct(t TestingT, got interface{}, model interface{}, expectedFields StructFields, args ...interface{}) bool CmpStruct is a shortcut for:\ntd.Cmp(t, got, td.Struct(model, expectedFields), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpStruct godoc.\n Example   Base example   t := \u0026amp;testing.T{} type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked \tok := td.CmpStruct(t, got, Person{Name: \u0026#34;Foobar\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 50), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tok = td.CmpStruct(t, got, Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = td.CmpStruct(t, \u0026amp;got, \u0026amp;Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = td.CmpStruct(t, \u0026amp;got, (*Person)(nil), td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     T.Struct shortcut func (t *T) Struct(got interface{}, model interface{}, expectedFields StructFields, args ...interface{}) bool Struct is a shortcut for:\nt.Cmp(got, td.Struct(model, expectedFields), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Struct godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) type Person struct { Name string Age int NumChildren int } got := Person{ Name: \u0026#34;Foobar\u0026#34;, Age: 42, NumChildren: 3, } // As NumChildren is zero in Struct() call, it is not checked \tok := t.Struct(got, Person{Name: \u0026#34;Foobar\u0026#34;}, td.StructFields{ \u0026#34;Age\u0026#34;: td.Between(40, 50), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model can be empty \tok = t.Struct(got, Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Works with pointers too \tok = t.Struct(\u0026amp;got, \u0026amp;Person{}, td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Model does not need to be instanciated \tok = t.Struct(\u0026amp;got, (*Person)(nil), td.StructFields{ \u0026#34;Name\u0026#34;: \u0026#34;Foobar\u0026#34;, \u0026#34;Age\u0026#34;: td.Between(40, 50), \u0026#34;NumChildren\u0026#34;: td.Not(0), }, \u0026#34;checks %v is the right Person\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/subbagof/","title":"SubBagOf","tags":[],"description":"","content":"func SubBagOf(expectedItems ...interface{}) TestDeep SubBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\ntd.Cmp(t, []int{1}, td.SubBagOf(1, 1, 2)) // succeeds td.Cmp(t, []int{1, 1, 1}, td.SubBagOf(1, 1, 2)) // fails, one 1 is an extra item  // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubBagOf( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{1, 2, 1} td.Cmp(t, []int{1}, td.SubBagOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1}, td.SubBagOf(1, 2, 1))  exp1 := []int{5, 1, 1} exp2 := []int{8, 42, 3} td.Cmp(t, []int{1, 42, 3}, td.SubBagOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 42, 3}, td.SubBagOf(5, 1, 1, 3, 8, 42, 3))  See also SubBagOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.Cmp(t, got, td.SubBagOf(0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9), \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) // got contains one 8 too many \tok = td.Cmp(t, got, td.SubBagOf(0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9), \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 2} ok = td.Cmp(t, got, td.SubBagOf( td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Gt(4), td.Gt(4)), \u0026#34;checks at least all items match, in any order with TestDeep operators\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5, 9, 8} ok = td.Cmp(t, got, td.SubBagOf(td.Flatten(expected)), \u0026#34;checks at least all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true \t// true     CmpSubBagOf shortcut func CmpSubBagOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSubBagOf is a shortcut for:\ntd.Cmp(t, got, td.SubBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSubBagOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.CmpSubBagOf(t, got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) // got contains one 8 too many \tok = td.CmpSubBagOf(t, got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 2} ok = td.CmpSubBagOf(t, got, []interface{}{td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Gt(4), td.Gt(4)}, \u0026#34;checks at least all items match, in any order with TestDeep operators\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5, 9, 8} ok = td.CmpSubBagOf(t, got, []interface{}{td.Flatten(expected)}, \u0026#34;checks at least all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true \t// true     T.SubBagOf shortcut func (t *T) SubBagOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SubBagOf is a shortcut for:\nt.Cmp(got, td.SubBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SubBagOf godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SubBagOf(got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) // got contains one 8 too many \tok = t.SubBagOf(got, []interface{}{0, 0, 1, 1, 2, 2, 3, 3, 5, 5, 8, 9, 9}, \u0026#34;checks at least all items are present, in any order\u0026#34;) fmt.Println(ok) got = []int{1, 3, 5, 2} ok = t.SubBagOf(got, []interface{}{td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Between(0, 3), td.Gt(4), td.Gt(4)}, \u0026#34;checks at least all items match, in any order with TestDeep operators\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 5, 9, 8} ok = t.SubBagOf(got, []interface{}{td.Flatten(expected)}, \u0026#34;checks at least all expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// false \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/subjsonof/","title":"SubJSONOf","tags":[],"description":"","content":"func SubJSONOf(expectedJSON interface{}, params ...interface{}) TestDeep SubJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshalled data must be a JSON object/map (aka {…}). expectedJSON can be a:\n string containing JSON data like {\u0026quot;fullname\u0026quot;:\u0026quot;Bob\u0026quot;,\u0026quot;age\u0026quot;:42} string containing a JSON filename, ending with \u0026ldquo;.json\u0026rdquo; (its content is ioutil.ReadFile before unmarshaling) []byte containing JSON data io.Reader stream containing JSON data (is ioutil.ReadAll before unmarshaling)  JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some expected entries can be missing from the compared map.\ntype MyStruct struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` } got := MyStruct{ Name: \u0026#34;Bob\u0026#34;, Age: 42, } td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42, \u0026#34;city\u0026#34;: \u0026#34;NY\u0026#34;}`)) // succeeds td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;zip\u0026#34;: 666}`)) // fails, extra \u0026#34;age\u0026#34; expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n\u0026rsquo;th \u0026ldquo;operators\u0026rdquo; item (starting at 1). Named placeholders are used with Tag operator as follows:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\u0026#34;fullname\u0026#34;: $name, \u0026#34;age\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 Note that placeholders can be double-quoted as in:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a \u0026ldquo;.json\u0026rdquo; file.\nNote expectedJSON can be a []byte, JSON filename or io.Reader:\ntd.Cmp(t, gotValue, td.SubJSONOf(\u0026#34;file.json\u0026#34;, td.Between(12, 34))) td.Cmp(t, gotValue, td.SubJSONOf([]byte(`[1, $1, 3]`), td.Between(12, 34))) td.Cmp(t, gotValue, td.SubJSONOf(osFile, td.Between(12, 34))) A JSON filename ends with \u0026ldquo;.json\u0026rdquo;.\nTo avoid a legit \u0026ldquo;$\u0026rdquo; string prefix causes a bad placeholder error, just double it to escape it. Note it is only needed when the \u0026ldquo;$\u0026rdquo; is the first character of a string:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, \u0026#34;age\u0026#34;: $2}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43))) // matches only $2 For the \u0026ldquo;details\u0026rdquo; key, the raw value \u0026ldquo;$info\u0026rdquo; is expected, no placeholders are involved here.\nNote that Lax mode is automatically enabled by SubJSONOf operator to simplify numeric tests.\nComments can be embedded in JSON data:\ntd.Cmp(t, gotValue, SubJSONOf(` { // A guy properties: \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, // The full name of the guy \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, // Literally \u0026#34;$info\u0026#34;, thanks to \u0026#34;$\u0026#34; escape \u0026#34;age\u0026#34;: $2 /* The age of the guy: - placeholder unquoted, but could be without any change - to demonstrate a multi-lines comment */ }`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43))) // matches only $2 Comments, like in go, have 2 forms. To quote the Go language specification:\n line comments start with the character sequence // and stop at the end of the line. multi-lines comments start with the character sequence /* and stop with the first subsequent character sequence */.  Last but not least, simple operators can be directly embedded in JSON data without requiring any placeholder but using directly $^OperatorName. They are operator shortcuts:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\u0026#34;id\u0026#34;: $1}`, td.NotZero())) can be written as:\ntd.Cmp(t, gotValue, td.SubJSONOf(`{\u0026#34;id\u0026#34;: $^NotZero}`)) Unfortunately, only simple operators (in fact those which take no parameters) have shortcuts. They follow:\n Empty → $^Empty Ignore → $^Ignore NaN → $^NaN Nil → $^Nil NotEmpty → $^NotEmpty NotNaN → $^NotNaN NotNil → $^NotNil NotZero → $^NotZero Zero → $^Zero  TypeBehind method returns the map[string]interface{} type.\n See also SubJSONOf godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34; // This field is ignored as SubJSONOf }`)) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got without age field:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got without age field: false       Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, 42, \u0026#34;Bob Foobar\u0026#34;, \u0026#34;male\u0026#34;)) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty())) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty())) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name, \u0026#34;gender\u0026#34;: $gender}`, td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)), td.Tag(\u0026#34;gender\u0026#34;, td.NotEmpty()))) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.SubJSONOf(`{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty, \u0026#34;gender\u0026#34;: $^NotEmpty}`)) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;TestCity\u0026#34;, \u0026#34;zip\u0026#34;: 666 } }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := td.Cmp(t, got, td.SubJSONOf(filename, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.Cmp(t, got, td.SubJSONOf(file, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \nCmpSubJSONOf shortcut func CmpSubJSONOf(t TestingT, got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool CmpSubJSONOf is a shortcut for:\ntd.Cmp(t, got, td.SubJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSubJSONOf godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := td.CmpSubJSONOf(t, got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, ` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34; // This field is ignored as SubJSONOf }`, nil) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got without age field:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got without age field: false       Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := td.CmpSubJSONOf(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;, \u0026#34;male\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name, \u0026#34;gender\u0026#34;: $gender}`, []interface{}{td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)), td.Tag(\u0026#34;gender\u0026#34;, td.NotEmpty())}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = td.CmpSubJSONOf(t, got, `{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty, \u0026#34;gender\u0026#34;: $^NotEmpty}`, nil) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;TestCity\u0026#34;, \u0026#34;zip\u0026#34;: 666 } }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := td.CmpSubJSONOf(t, got, filename, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.CmpSubJSONOf(t, got, file, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \nT.SubJSONOf shortcut func (t *T) SubJSONOf(got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool SubJSONOf is a shortcut for:\nt.Cmp(got, td.SubJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SubJSONOf godoc.\n Examples    Basic example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, } ok := t.SubJSONOf(got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = t.SubJSONOf(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = t.SubJSONOf(got, ` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34; // This field is ignored as SubJSONOf }`, nil) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = t.SubJSONOf(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got without age field:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got without age field: false       Placeholders example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, } ok := t.SubJSONOf(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;, \u0026#34;male\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = t.SubJSONOf(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = t.SubJSONOf(got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = t.SubJSONOf(got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name, \u0026#34;gender\u0026#34;: $gender}`, []interface{}{td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)), td.Tag(\u0026#34;gender\u0026#34;, td.NotEmpty())}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = t.SubJSONOf(got, `{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty, \u0026#34;gender\u0026#34;: $^NotEmpty}`, nil) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34;, \u0026#34;details\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;TestCity\u0026#34;, \u0026#34;zip\u0026#34;: 666 } }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := t.SubJSONOf(got, filename, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.SubJSONOf(got, file, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/submapof/","title":"SubMapOf","tags":[],"description":"","content":"func SubMapOf(model interface{}, expectedEntries MapEntries) TestDeep SubMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, each map entry should be matched by an expected entry to succeed. But some expected entries can be missing from the compared map.\ngot := map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;buzz\u0026#34;, } td.Cmp(t, got, td.SubMapOf( map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;wizz\u0026#34;, }, td.MapEntries{ \u0026#34;zip\u0026#34;: td.HasSuffix(\u0026#34;zz\u0026#34;), }), ) // succeeds  td.Cmp(t, got, td.SubMapOf( map[string]string{ \u0026#34;bar\u0026#34;: \u0026#34;wizz\u0026#34;, }, td.MapEntries{ \u0026#34;zip\u0026#34;: td.HasSuffix(\u0026#34;zz\u0026#34;), }), ) // fails, extra {\u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;} in got TypeBehind method returns the reflect.Type of model.\n See also SubMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := td.Cmp(t, got, td.SubMapOf(map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}), \u0026#34;checks map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := td.Cmp(t, got, td.SubMapOf(MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}), \u0026#34;checks typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.SubMapOf(\u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}), \u0026#34;checks pointed typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nCmpSubMapOf shortcut func CmpSubMapOf(t TestingT, got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool CmpSubMapOf is a shortcut for:\ntd.Cmp(t, got, td.SubMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSubMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := td.CmpSubMapOf(t, got, map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := td.CmpSubMapOf(t, got, MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) ok = td.CmpSubMapOf(t, \u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks pointed typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nT.SubMapOf shortcut func (t *T) SubMapOf(got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool SubMapOf is a shortcut for:\nt.Cmp(got, td.SubMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SubMapOf godoc.\n Examples    Map example   t := td.NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := t.SubMapOf(got, map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := td.NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42} ok := t.SubMapOf(got, MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) ok = t.SubMapOf(\u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15), \u0026#34;zip\u0026#34;: 666}, \u0026#34;checks pointed typed map %v is included in expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/subsetof/","title":"SubSetOf","tags":[],"description":"","content":"func SubSetOf(expectedItems ...interface{}) TestDeep SubSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each array/slice item should be matched by an expected item to succeed. But some expected items can be missing from the compared array/slice.\ntd.Cmp(t, []int{1, 1}, td.SubSetOf(1, 2)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SubSetOf(1, 3)) // fails, 2 is an extra item  // works with slices/arrays of any type td.Cmp(t, personSlice, td.SubSetOf( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{2, 1} td.Cmp(t, []int{1, 1}, td.SubSetOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1}, td.SubSetOf(2, 1))  exp1 := []int{2, 1} exp2 := []int{5, 8} td.Cmp(t, []int{1, 5, 1, 3, 3}, td.SubSetOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 3, 3}, td.SubSetOf(2, 1, 3, 5, 8))  See also SubSetOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates \tok := td.Cmp(t, got, td.SubSetOf(1, 2, 3, 4, 5, 6, 7, 8), \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several SubSetOf entries \tok = td.Cmp(t, got, td.SubSetOf(td.Between(1, 4), 3, td.Between(2, 10), td.Gt(100)), \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 4, 5, 6, 7, 8} ok = td.Cmp(t, got, td.SubSetOf(td.Flatten(expected)), \u0026#34;checks at least all expected items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     CmpSubSetOf shortcut func CmpSubSetOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSubSetOf is a shortcut for:\ntd.Cmp(t, got, td.SubSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSubSetOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates \tok := td.CmpSubSetOf(t, got, []interface{}{1, 2, 3, 4, 5, 6, 7, 8}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several SubSetOf entries \tok = td.CmpSubSetOf(t, got, []interface{}{td.Between(1, 4), 3, td.Between(2, 10), td.Gt(100)}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 4, 5, 6, 7, 8} ok = td.CmpSubSetOf(t, got, []interface{}{td.Flatten(expected)}, \u0026#34;checks at least all expected items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     T.SubSetOf shortcut func (t *T) SubSetOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SubSetOf is a shortcut for:\nt.Cmp(got, td.SubSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SubSetOf godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} // Matches as all items are expected, ignoring duplicates \tok := t.SubSetOf(got, []interface{}{1, 2, 3, 4, 5, 6, 7, 8}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Tries its best to not raise an error when a value can be matched \t// by several SubSetOf entries \tok = t.SubSetOf(got, []interface{}{td.Between(1, 4), 3, td.Between(2, 10), td.Gt(100)}, \u0026#34;checks at least all items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3, 4, 5, 6, 7, 8} ok = t.SubSetOf(got, []interface{}{td.Flatten(expected)}, \u0026#34;checks at least all expected items are present, in any order, ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/superbagof/","title":"SuperBagOf","tags":[],"description":"","content":"func SuperBagOf(expectedItems ...interface{}) TestDeep SuperBagOf operator compares the contents of an array or a slice (or a pointer on array/slice) without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\ntd.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperBagOf(1, 1, 1)) // fails, one 1 is missing  // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperBagOf( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{1, 2, 1} td.Cmp(t, []int{1}, td.SuperBagOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1}, td.SuperBagOf(1, 2, 1))  exp1 := []int{5, 1, 1} exp2 := []int{8, 42} td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3, 6}, td.SuperBagOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3, 6}, td.SuperBagOf(5, 1, 1, 3, 8, 42))  See also SuperBagOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.Cmp(t, got, td.SuperBagOf(8, 5, 8), \u0026#34;checks the items are present, in any order\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, got, td.SuperBagOf(td.Gt(5), td.Lte(2)), \u0026#34;checks at least 2 items of %v match\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{8, 5, 8} ok = td.Cmp(t, got, td.SuperBagOf(td.Flatten(expected)), \u0026#34;checks the expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     CmpSuperBagOf shortcut func CmpSuperBagOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSuperBagOf is a shortcut for:\ntd.Cmp(t, got, td.SuperBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSuperBagOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.CmpSuperBagOf(t, got, []interface{}{8, 5, 8}, \u0026#34;checks the items are present, in any order\u0026#34;) fmt.Println(ok) ok = td.CmpSuperBagOf(t, got, []interface{}{td.Gt(5), td.Lte(2)}, \u0026#34;checks at least 2 items of %v match\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{8, 5, 8} ok = td.CmpSuperBagOf(t, got, []interface{}{td.Flatten(expected)}, \u0026#34;checks the expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     T.SuperBagOf shortcut func (t *T) SuperBagOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SuperBagOf is a shortcut for:\nt.Cmp(got, td.SuperBagOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SuperBagOf godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SuperBagOf(got, []interface{}{8, 5, 8}, \u0026#34;checks the items are present, in any order\u0026#34;) fmt.Println(ok) ok = t.SuperBagOf(got, []interface{}{td.Gt(5), td.Lte(2)}, \u0026#34;checks at least 2 items of %v match\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{8, 5, 8} ok = t.SuperBagOf(got, []interface{}{td.Flatten(expected)}, \u0026#34;checks the expected items are present, in any order\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/superjsonof/","title":"SuperJSONOf","tags":[],"description":"","content":"func SuperJSONOf(expectedJSON interface{}, params ...interface{}) TestDeep SuperJSONOf operator allows to compare the JSON representation of data against expectedJSON. Unlike JSON operator, marshalled data must be a JSON object/map (aka {…}). expectedJSON can be a:\n string containing JSON data like {\u0026quot;fullname\u0026quot;:\u0026quot;Bob\u0026quot;,\u0026quot;age\u0026quot;:42} string containing a JSON filename, ending with \u0026ldquo;.json\u0026rdquo; (its content is ioutil.ReadFile before unmarshaling) []byte containing JSON data io.Reader stream containing JSON data (is ioutil.ReadAll before unmarshaling)  JSON data contained in expectedJSON must be a JSON object/map (aka {…}) too. During a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.\ntype MyStruct struct { Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` City string `json:\u0026#34;city\u0026#34;` } got := MyStruct{ Name: \u0026#34;Bob\u0026#34;, Age: 42, City: \u0026#34;TestCity\u0026#34;, } td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42}`)) // succeeds td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;zip\u0026#34;: 666}`)) // fails, miss \u0026#34;zip\u0026#34; expectedJSON JSON value can contain placeholders. The params are for any placeholder parameters in expectedJSON. params can contain TestDeep operators as well as raw values. A placeholder can be numeric like $2 or named like $name and always references an item in params.\nNumeric placeholders reference the n\u0026rsquo;th \u0026ldquo;operators\u0026rdquo; item (starting at 1). Named placeholders are used with Tag operator as follows:\ntd.Cmp(t, gotValue, SuperJSONOf(`{\u0026#34;fullname\u0026#34;: $name, \u0026#34;age\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 Note that placeholders can be double-quoted as in:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43), // matches only $2  \u0026#34;male\u0026#34;)) // matches only $3 It makes no difference whatever the underlying type of the replaced item is (= double quoting a placeholder matching a number is not a problem). It is just a matter of taste, double-quoting placeholders can be preferred when the JSON data has to conform to the JSON specification, like when used in a \u0026ldquo;.json\u0026rdquo; file.\nNote expectedJSON can be a []byte, JSON filename or io.Reader:\ntd.Cmp(t, gotValue, td.SuperJSONOf(\u0026#34;file.json\u0026#34;, td.Between(12, 34))) td.Cmp(t, gotValue, td.SuperJSONOf([]byte(`[1, $1, 3]`), td.Between(12, 34))) td.Cmp(t, gotValue, td.SuperJSONOf(osFile, td.Between(12, 34))) A JSON filename ends with \u0026ldquo;.json\u0026rdquo;.\nTo avoid a legit \u0026ldquo;$\u0026rdquo; string prefix causes a bad placeholder error, just double it to escape it. Note it is only needed when the \u0026ldquo;$\u0026rdquo; is the first character of a string:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, \u0026#34;age\u0026#34;: $2}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43))) // matches only $2 For the \u0026ldquo;details\u0026rdquo; key, the raw value \u0026ldquo;$info\u0026rdquo; is expected, no placeholders are involved here.\nNote that Lax mode is automatically enabled by SuperJSONOf operator to simplify numeric tests.\nComments can be embedded in JSON data:\ntd.Cmp(t, gotValue, td.SuperJSONOf(` { // A guy properties: \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, // The full name of the guy \u0026#34;details\u0026#34;: \u0026#34;$$info\u0026#34;, // Literally \u0026#34;$info\u0026#34;, thanks to \u0026#34;$\u0026#34; escape \u0026#34;age\u0026#34;: $2 /* The age of the guy: - placeholder unquoted, but could be without any change - to demonstrate a multi-lines comment */ }`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $1 and $name  td.Between(41, 43))) // matches only $2 Comments, like in go, have 2 forms. To quote the Go language specification:\n line comments start with the character sequence // and stop at the end of the line. multi-lines comments start with the character sequence /* and stop with the first subsequent character sequence */.  Last but not least, simple operators can be directly embedded in JSON data without requiring any placeholder but using directly $^OperatorName. They are operator shortcuts:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\u0026#34;id\u0026#34;: $1}`, td.NotZero())) can be written as:\ntd.Cmp(t, gotValue, td.SuperJSONOf(`{\u0026#34;id\u0026#34;: $^NotZero}`)) Unfortunately, only simple operators (in fact those which take no parameters) have shortcuts. They follow:\n Empty → $^Empty Ignore → $^Ignore NaN → $^NaN Nil → $^Nil NotEmpty → $^NotEmpty NotNaN → $^NotNaN NotNil → $^NotNil NotZero → $^NotZero Zero → $^Zero  TypeBehind method returns the map[string]interface{} type.\n See also SuperJSONOf godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } ok := td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`)) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34; // The gender! }`)) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;,\u0026#34;details\u0026#34;:{}}`)) fmt.Println(\u0026#34;check got with details field:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got with details field: false       Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } ok := td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, 42, \u0026#34;Bob Foobar\u0026#34;, \u0026#34;male\u0026#34;)) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty())) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty())) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name, \u0026#34;gender\u0026#34;: $gender}`, td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)), td.Tag(\u0026#34;gender\u0026#34;, td.NotEmpty()))) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = td.Cmp(t, got, td.SuperJSONOf(`{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty, \u0026#34;gender\u0026#34;: $^NotEmpty}`)) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := td.Cmp(t, got, td.SuperJSONOf(filename, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.Cmp(t, got, td.SuperJSONOf(file, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`)))) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \nCmpSuperJSONOf shortcut func CmpSuperJSONOf(t TestingT, got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool CmpSuperJSONOf is a shortcut for:\ntd.Cmp(t, got, td.SuperJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSuperJSONOf godoc.\n Examples    Basic example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } ok := td.CmpSuperJSONOf(t, got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, ` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34; // The gender! }`, nil) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;,\u0026#34;details\u0026#34;:{}}`, nil) fmt.Println(\u0026#34;check got with details field:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got with details field: false       Placeholders example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } ok := td.CmpSuperJSONOf(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;, \u0026#34;male\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name, \u0026#34;gender\u0026#34;: $gender}`, []interface{}{td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)), td.Tag(\u0026#34;gender\u0026#34;, td.NotEmpty())}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = td.CmpSuperJSONOf(t, got, `{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty, \u0026#34;gender\u0026#34;: $^NotEmpty}`, nil) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := \u0026amp;testing.T{} got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := td.CmpSuperJSONOf(t, got, filename, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = td.CmpSuperJSONOf(t, got, file, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \nT.SuperJSONOf shortcut func (t *T) SuperJSONOf(got interface{}, expectedJSON interface{}, params []interface{}, args ...interface{}) bool SuperJSONOf is a shortcut for:\nt.Cmp(got, td.SuperJSONOf(expectedJSON, params...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SuperJSONOf godoc.\n Examples    Basic example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } ok := t.SuperJSONOf(got, `{\u0026#34;age\u0026#34;:42,\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with age then fullname:\u0026#34;, ok) ok = t.SuperJSONOf(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;age\u0026#34;:42,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;}`, nil) fmt.Println(\u0026#34;check got with fullname then age:\u0026#34;, ok) ok = t.SuperJSONOf(got, ` // This should be the JSON representation of a struct { // A person: \u0026#34;fullname\u0026#34;: \u0026#34;Bob\u0026#34;, // The name of this person \u0026#34;age\u0026#34;: 42, /* The age of this person: - 42 of course - to demonstrate a multi-lines comment */ \u0026#34;gender\u0026#34;: \u0026#34;male\u0026#34; // The gender! }`, nil) fmt.Println(\u0026#34;check got with nicely formatted and commented JSON:\u0026#34;, ok) ok = t.SuperJSONOf(got, `{\u0026#34;fullname\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;gender\u0026#34;:\u0026#34;male\u0026#34;,\u0026#34;details\u0026#34;:{}}`, nil) fmt.Println(\u0026#34;check got with details field:\u0026#34;, ok) // Output: \t// check got with age then fullname: true \t// check got with fullname then age: true \t// check got with nicely formatted and commented JSON: true \t// check got with details field: false       Placeholders example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } ok := t.SuperJSONOf(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{42, \u0026#34;Bob Foobar\u0026#34;, \u0026#34;male\u0026#34;}) fmt.Println(\u0026#34;check got with numeric placeholders without operators:\u0026#34;, ok) ok = t.SuperJSONOf(got, `{\u0026#34;age\u0026#34;: $1, \u0026#34;fullname\u0026#34;: $2, \u0026#34;gender\u0026#34;: $3}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with numeric placeholders:\u0026#34;, ok) ok = t.SuperJSONOf(got, `{\u0026#34;age\u0026#34;: \u0026#34;$1\u0026#34;, \u0026#34;fullname\u0026#34;: \u0026#34;$2\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$3\u0026#34;}`, []interface{}{td.Between(40, 45), td.HasSuffix(\u0026#34;Foobar\u0026#34;), td.NotEmpty()}) fmt.Println(\u0026#34;check got with double-quoted numeric placeholders:\u0026#34;, ok) ok = t.SuperJSONOf(got, `{\u0026#34;age\u0026#34;: $age, \u0026#34;fullname\u0026#34;: $name, \u0026#34;gender\u0026#34;: $gender}`, []interface{}{td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;name\u0026#34;, td.HasSuffix(\u0026#34;Foobar\u0026#34;)), td.Tag(\u0026#34;gender\u0026#34;, td.NotEmpty())}) fmt.Println(\u0026#34;check got with named placeholders:\u0026#34;, ok) ok = t.SuperJSONOf(got, `{\u0026#34;age\u0026#34;: $^NotZero, \u0026#34;fullname\u0026#34;: $^NotEmpty, \u0026#34;gender\u0026#34;: $^NotEmpty}`, nil) fmt.Println(\u0026#34;check got with operator shortcuts:\u0026#34;, ok) // Output: \t// check got with numeric placeholders without operators: true \t// check got with numeric placeholders: true \t// check got with double-quoted numeric placeholders: true \t// check got with named placeholders: true \t// check got with operator shortcuts: true       File example   t := td.NewT(\u0026amp;testing.T{}) got := \u0026amp;struct { Fullname string `json:\u0026#34;fullname\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` Gender string `json:\u0026#34;gender\u0026#34;` City string `json:\u0026#34;city\u0026#34;` Zip int `json:\u0026#34;zip\u0026#34;` }{ Fullname: \u0026#34;Bob Foobar\u0026#34;, Age: 42, Gender: \u0026#34;male\u0026#34;, City: \u0026#34;TestCity\u0026#34;, Zip: 666, } tmpDir, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) if err != nil { t.Fatal(err) } defer os.RemoveAll(tmpDir) // clean up  filename := tmpDir + \u0026#34;/test.json\u0026#34; if err = ioutil.WriteFile(filename, []byte(` { \u0026#34;fullname\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;$age\u0026#34;, \u0026#34;gender\u0026#34;: \u0026#34;$gender\u0026#34; }`), 0644); err != nil { t.Fatal(err) } // OK let\u0026#39;s test with this file \tok := t.SuperJSONOf(got, filename, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from file name:\u0026#34;, ok) // When the file is already open \tfile, err := os.Open(filename) if err != nil { t.Fatal(err) } ok = t.SuperJSONOf(got, file, []interface{}{td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Bob\u0026#34;)), td.Tag(\u0026#34;age\u0026#34;, td.Between(40, 45)), td.Tag(\u0026#34;gender\u0026#34;, td.Re(`^(male|female)\\z`))}) fmt.Println(\u0026#34;Full match from io.Reader:\u0026#34;, ok) // Output: \t// Full match from file name: true \t// Full match from io.Reader: true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/supermapof/","title":"SuperMapOf","tags":[],"description":"","content":"func SuperMapOf(model interface{}, expectedEntries MapEntries) TestDeep SuperMapOf operator compares the contents of a map against the non-zero values of model (if any) and the values of expectedEntries.\nmodel must be the same type as compared data.\nexpectedEntries can be nil, if no zero entries are expected and no TestDeep operator are involved.\nDuring a match, each expected entry should match in the compared map. But some entries in the compared map may not be expected.\ngot := map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;wizz\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;buzz\u0026#34;, } td.Cmp(t, got, td.SuperMapOf( map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, }, td.MapEntries{ \u0026#34;zip\u0026#34;: td.HasSuffix(\u0026#34;zz\u0026#34;), }), ) // succeeds  td.Cmp(t, got, td.SuperMapOf( map[string]string{ \u0026#34;foo\u0026#34;: \u0026#34;test\u0026#34;, }, td.MapEntries{ \u0026#34;biz\u0026#34;: td.HasSuffix(\u0026#34;zz\u0026#34;), }), ) // fails, missing {\u0026#34;biz\u0026#34;: …} in got TypeBehind method returns the reflect.Type of model.\n See also SuperMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.Cmp(t, got, td.SuperMapOf(map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}), \u0026#34;checks map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.Cmp(t, got, td.SuperMapOf(MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}), \u0026#34;checks typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;got, td.SuperMapOf(\u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}), \u0026#34;checks pointed typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nCmpSuperMapOf shortcut func CmpSuperMapOf(t TestingT, got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool CmpSuperMapOf is a shortcut for:\ntd.Cmp(t, got, td.SuperMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSuperMapOf godoc.\n Examples    Map example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.CmpSuperMapOf(t, got, map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}, \u0026#34;checks map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := \u0026amp;testing.T{} type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := td.CmpSuperMapOf(t, got, MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}, \u0026#34;checks typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) ok = td.CmpSuperMapOf(t, \u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}, \u0026#34;checks pointed typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \nT.SuperMapOf shortcut func (t *T) SuperMapOf(got interface{}, model interface{}, expectedEntries MapEntries, args ...interface{}) bool SuperMapOf is a shortcut for:\nt.Cmp(got, td.SuperMapOf(model, expectedEntries), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SuperMapOf godoc.\n Examples    Map example   t := td.NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.SuperMapOf(got, map[string]int{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}, \u0026#34;checks map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true       TypedMap example   t := td.NewT(\u0026amp;testing.T{}) type MyMap map[string]int got := MyMap{\u0026#34;foo\u0026#34;: 12, \u0026#34;bar\u0026#34;: 42, \u0026#34;zip\u0026#34;: 89} ok := t.SuperMapOf(got, MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}, \u0026#34;checks typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) ok = t.SuperMapOf(\u0026amp;got, \u0026amp;MyMap{\u0026#34;bar\u0026#34;: 42}, td.MapEntries{\u0026#34;foo\u0026#34;: td.Lt(15)}, \u0026#34;checks pointed typed map %v contains at leat all expected keys/values\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true    \n"},{"uri":"https://go-testdeep.zetta.rocks/operators/supersetof/","title":"SuperSetOf","tags":[],"description":"","content":"func SuperSetOf(expectedItems ...interface{}) TestDeep SuperSetOf operator compares the contents of an array or a slice (or a pointer on array/slice) ignoring duplicates and without taking care of the order of items.\nDuring a match, each expected item should match in the compared array/slice. But some items in the compared array/slice may not be expected.\ntd.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1)) // succeeds td.Cmp(t, []int{1, 1, 2}, td.SuperSetOf(1, 3)) // fails, 3 is missing  // works with slices/arrays of any type td.Cmp(t, personSlice, td.SuperSetOf( Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, Person{Name: \u0026#34;Alice\u0026#34;, Age: 26}, )) To flatten a non-[]interface{} slice/array, use Flatten function and so avoid boring and inefficient copies:\nexpected := []int{2, 1} td.Cmp(t, []int{1, 1, 2, 8}, td.SuperSetOf(td.Flatten(expected))) // succeeds // = td.Cmp(t, []int{1, 1, 2, 8}, td.SubSetOf(2, 1))  exp1 := []int{2, 1} exp2 := []int{5, 8} td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.SuperSetOf(td.Flatten(exp1), 3, td.Flatten(exp2))) // succeeds // = td.Cmp(t, []int{1, 5, 1, 8, 42, 3, 3}, td.SuperSetOf(2, 1, 3, 5, 8))  See also SuperSetOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.Cmp(t, got, td.SuperSetOf(1, 2, 3), \u0026#34;checks the items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) ok = td.Cmp(t, got, td.SuperSetOf(td.Gt(5), td.Lte(2)), \u0026#34;checks at least 2 items of %v match ignoring duplicates\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3} ok = td.Cmp(t, got, td.SuperSetOf(td.Flatten(expected)), \u0026#34;checks the expected items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     CmpSuperSetOf shortcut func CmpSuperSetOf(t TestingT, got interface{}, expectedItems []interface{}, args ...interface{}) bool CmpSuperSetOf is a shortcut for:\ntd.Cmp(t, got, td.SuperSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpSuperSetOf godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := []int{1, 3, 5, 8, 8, 1, 2} ok := td.CmpSuperSetOf(t, got, []interface{}{1, 2, 3}, \u0026#34;checks the items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) ok = td.CmpSuperSetOf(t, got, []interface{}{td.Gt(5), td.Lte(2)}, \u0026#34;checks at least 2 items of %v match ignoring duplicates\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3} ok = td.CmpSuperSetOf(t, got, []interface{}{td.Flatten(expected)}, \u0026#34;checks the expected items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     T.SuperSetOf shortcut func (t *T) SuperSetOf(got interface{}, expectedItems []interface{}, args ...interface{}) bool SuperSetOf is a shortcut for:\nt.Cmp(got, td.SuperSetOf(expectedItems...), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.SuperSetOf godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := []int{1, 3, 5, 8, 8, 1, 2} ok := t.SuperSetOf(got, []interface{}{1, 2, 3}, \u0026#34;checks the items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) ok = t.SuperSetOf(got, []interface{}{td.Gt(5), td.Lte(2)}, \u0026#34;checks at least 2 items of %v match ignoring duplicates\u0026#34;, got) fmt.Println(ok) // When expected is already a non-[]interface{} slice, it cannot be \t// flattened directly using expected... without copying it to a new \t// []interface{} slice, then use td.Flatten! \texpected := []int{1, 2, 3} ok = t.SuperSetOf(got, []interface{}{td.Flatten(expected)}, \u0026#34;checks the expected items are present, in any order and ignoring duplicates\u0026#34;) fmt.Println(ok) // Output: \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/tag/","title":"Tag","tags":[],"description":"","content":"func Tag(tag string, expectedValue interface{}) TestDeep Tag is a smuggler operator. It only allows to name expectedValue, which can be an operator or a value. The data is then compared against expectedValue as if Tag was never called. It is only useful as JSON operator parameter, to name placeholders. See JSON operator for more details.\ntd.Cmp(t, gotValue, td.JSON(`{\u0026#34;fullname\u0026#34;: $name, \u0026#34;age\u0026#34;: $age, \u0026#34;gender\u0026#34;: $gender}`, td.Tag(\u0026#34;name\u0026#34;, td.HasPrefix(\u0026#34;Foo\u0026#34;)), // matches $name  td.Tag(\u0026#34;age\u0026#34;, td.Between(41, 43)), // matches $age  td.Tag(\u0026#34;gender\u0026#34;, \u0026#34;male\u0026#34;))) // matches $gender TypeBehind method is delegated to expectedValue one if expectedValue is a TestDeep operator, otherwise it returns the type of expectedValue (or nil if it is originally untyped nil).\n See also Tag godoc.\n "},{"uri":"https://go-testdeep.zetta.rocks/operators/trunctime/","title":"TruncTime","tags":[],"description":"","content":"func TruncTime(expectedTime interface{}, trunc ...time.Duration) TestDeep TruncTime operator compares time.Time (or assignable) values after truncating them to the optional trunc duration. See time.Truncate for details about the truncation.\nIf trunc is missing, it defaults to 0.\nDuring comparison, location does not matter as time.Equal method is used behind the scenes: a time instant in two different locations is the same time instant.\nWhatever the trunc value is, the monotonic clock is stripped before the comparison against expectedTime.\ngotDate := time.Date(2018, time.March, 9, 1, 2, 3, 999999999, time.UTC). In(time.FixedZone(\u0026#34;UTC+2\u0026#34;, 2)) expected := time.Date(2018, time.March, 9, 1, 2, 3, 0, time.UTC) td.Cmp(t, gotDate, td.TruncTime(expected)) // fails, ns differ td.Cmp(t, gotDate, td.TruncTime(expected, time.Second)) // succeeds TypeBehind method returns the reflect.Type of expectedTime.\n See also TruncTime godoc.\n Example   Base example   t := \u0026amp;testing.T{} dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) // Compare dates ignoring nanoseconds and monotonic parts \texpected := dateToTime(\u0026#34;2018-05-01T12:45:53Z\u0026#34;) ok := td.Cmp(t, got, td.TruncTime(expected, time.Second), \u0026#34;checks date %v, truncated to the second\u0026#34;, got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts \texpected = dateToTime(\u0026#34;2018-05-01T11:22:33.444444444Z\u0026#34;) ok = td.Cmp(t, got, td.TruncTime(expected, 24*time.Hour), \u0026#34;checks date %v, truncated to the day\u0026#34;, got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part \texpected = dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) ok = td.Cmp(t, got, td.TruncTime(expected), \u0026#34;checks date %v ignoring monotonic part\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     CmpTruncTime shortcut func CmpTruncTime(t TestingT, got interface{}, expectedTime interface{}, trunc time.Duration, args ...interface{}) bool CmpTruncTime is a shortcut for:\ntd.Cmp(t, got, td.TruncTime(expectedTime, trunc), args...) See above for details.\nTruncTime() optional parameter trunc is here mandatory. 0 value should be passed to mimic its absence in original TruncTime() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpTruncTime godoc.\n Example   Base example   t := \u0026amp;testing.T{} dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) // Compare dates ignoring nanoseconds and monotonic parts \texpected := dateToTime(\u0026#34;2018-05-01T12:45:53Z\u0026#34;) ok := td.CmpTruncTime(t, got, expected, time.Second, \u0026#34;checks date %v, truncated to the second\u0026#34;, got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts \texpected = dateToTime(\u0026#34;2018-05-01T11:22:33.444444444Z\u0026#34;) ok = td.CmpTruncTime(t, got, expected, 24*time.Hour, \u0026#34;checks date %v, truncated to the day\u0026#34;, got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part \texpected = dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) ok = td.CmpTruncTime(t, got, expected, 0, \u0026#34;checks date %v ignoring monotonic part\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     T.TruncTime shortcut func (t *T) TruncTime(got interface{}, expectedTime interface{}, trunc time.Duration, args ...interface{}) bool TruncTime is a shortcut for:\nt.Cmp(got, td.TruncTime(expectedTime, trunc), args...) See above for details.\nTruncTime() optional parameter trunc is here mandatory. 0 value should be passed to mimic its absence in original TruncTime() call.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.TruncTime godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) dateToTime := func(str string) time.Time { t, err := time.Parse(time.RFC3339Nano, str) if err != nil { panic(err) } return t } got := dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) // Compare dates ignoring nanoseconds and monotonic parts \texpected := dateToTime(\u0026#34;2018-05-01T12:45:53Z\u0026#34;) ok := t.TruncTime(got, expected, time.Second, \u0026#34;checks date %v, truncated to the second\u0026#34;, got) fmt.Println(ok) // Compare dates ignoring time and so monotonic parts \texpected = dateToTime(\u0026#34;2018-05-01T11:22:33.444444444Z\u0026#34;) ok = t.TruncTime(got, expected, 24*time.Hour, \u0026#34;checks date %v, truncated to the day\u0026#34;, got) fmt.Println(ok) // Compare dates exactly but ignoring monotonic part \texpected = dateToTime(\u0026#34;2018-05-01T12:45:53.123456789Z\u0026#34;) ok = t.TruncTime(got, expected, 0, \u0026#34;checks date %v ignoring monotonic part\u0026#34;, got) fmt.Println(ok) // Output: \t// true \t// true \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/example/using-testing/","title":"Using testing package","tags":[],"description":"","content":"To check the freshly created record contents using standard testing package, we have to do something like that:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if err != nil { t.Errorf(\u0026#34;An error occurred: %s\u0026#34;, err) } else { expected := Record{Name: \u0026#34;Bob\u0026#34;, Age: 23} if record.Id == 0 { t.Error(\u0026#34;Id probably not initialized\u0026#34;) } if record.Name != expected.Name { t.Errorf(\u0026#34;Name field differs, got=%s, expected=%s\u0026#34;, record.Name, expected.Name) } if record.Age != expected.Age { t.Errorf(\u0026#34;Age field differs, got=%s, expected=%s\u0026#34;, record.Age, expected.Age) } if before.After(record.CreatedAt) || time.Now().Before(record.CreatedAt) { t.Errorf(\u0026#34;CreatedAt field not expected: %s\u0026#34;, record.CreatedAt) } } } "},{"uri":"https://go-testdeep.zetta.rocks/operators/values/","title":"Values","tags":[],"description":"","content":"func Values(val interface{}) TestDeep Values is a smuggler operator. It takes a map and compares its ordered values to val.\nval can be a slice of items of the same type as the map values:\ngot := map[int]string{3: \u0026#34;c\u0026#34;, 1: \u0026#34;a\u0026#34;, 2: \u0026#34;b\u0026#34;} td.Cmp(t, got, td.Values([]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;})) // succeeds, values sorted td.Cmp(t, got, td.Values([]string{\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;})) // fails as not sorted as well as an other operator as Bag, for example, to test values in an unsorted manner:\ngot := map[int]string{3: \u0026#34;c\u0026#34;, 1: \u0026#34;a\u0026#34;, 2: \u0026#34;b\u0026#34;} td.Cmp(t, got, td.Values(td.Bag(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;))) // succeeds  See also Values godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Values tests values in an ordered manner \tok := td.Cmp(t, got, td.Values([]int{1, 2, 3})) fmt.Println(\u0026#34;All sorted values are found:\u0026#34;, ok) // If the expected values are not ordered, it fails \tok = td.Cmp(t, got, td.Values([]int{3, 1, 2})) fmt.Println(\u0026#34;All unsorted values are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = td.Cmp(t, got, td.Values(td.Bag(3, 1, 2))) fmt.Println(\u0026#34;All unsorted values are found, with the help of Bag operator:\u0026#34;, ok) // Check that each value is between 1 and 3 \tok = td.Cmp(t, got, td.Values(td.ArrayEach(td.Between(1, 3)))) fmt.Println(\u0026#34;Each value is between 1 and 3:\u0026#34;, ok) // Output: \t// All sorted values are found: true \t// All unsorted values are found: false \t// All unsorted values are found, with the help of Bag operator: true \t// Each value is between 1 and 3: true     CmpValues shortcut func CmpValues(t TestingT, got interface{}, val interface{}, args ...interface{}) bool CmpValues is a shortcut for:\ntd.Cmp(t, got, td.Values(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpValues godoc.\n Example   Base example   t := \u0026amp;testing.T{} got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Values tests values in an ordered manner \tok := td.CmpValues(t, got, []int{1, 2, 3}) fmt.Println(\u0026#34;All sorted values are found:\u0026#34;, ok) // If the expected values are not ordered, it fails \tok = td.CmpValues(t, got, []int{3, 1, 2}) fmt.Println(\u0026#34;All unsorted values are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = td.CmpValues(t, got, td.Bag(3, 1, 2)) fmt.Println(\u0026#34;All unsorted values are found, with the help of Bag operator:\u0026#34;, ok) // Check that each value is between 1 and 3 \tok = td.CmpValues(t, got, td.ArrayEach(td.Between(1, 3))) fmt.Println(\u0026#34;Each value is between 1 and 3:\u0026#34;, ok) // Output: \t// All sorted values are found: true \t// All unsorted values are found: false \t// All unsorted values are found, with the help of Bag operator: true \t// Each value is between 1 and 3: true     T.Values shortcut func (t *T) Values(got interface{}, val interface{}, args ...interface{}) bool Values is a shortcut for:\nt.Cmp(got, td.Values(val), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Values godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) got := map[string]int{\u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, \u0026#34;zip\u0026#34;: 3} // Values tests values in an ordered manner \tok := t.Values(got, []int{1, 2, 3}) fmt.Println(\u0026#34;All sorted values are found:\u0026#34;, ok) // If the expected values are not ordered, it fails \tok = t.Values(got, []int{3, 1, 2}) fmt.Println(\u0026#34;All unsorted values are found:\u0026#34;, ok) // To circumvent that, one can use Bag operator \tok = t.Values(got, td.Bag(3, 1, 2)) fmt.Println(\u0026#34;All unsorted values are found, with the help of Bag operator:\u0026#34;, ok) // Check that each value is between 1 and 3 \tok = t.Values(got, td.ArrayEach(td.Between(1, 3))) fmt.Println(\u0026#34;Each value is between 1 and 3:\u0026#34;, ok) // Output: \t// All sorted values are found: true \t// All unsorted values are found: false \t// All unsorted values are found, with the help of Bag operator: true \t// Each value is between 1 and 3: true     "},{"uri":"https://go-testdeep.zetta.rocks/operators/zero/","title":"Zero","tags":[],"description":"","content":"func Zero() TestDeep Zero operator checks that data is zero regarding its type.\n nil is the zero value of pointers, maps, slices, channels and functions; 0 is the zero value of numbers; \u0026quot;\u0026rdquo; is the 0 value of strings; false is the zero value of booleans; zero value of structs is the struct with no fields initialized.  Beware that:\ntd.Cmp(t, AnyStruct{}, td.Zero()) // is true td.Cmp(t, \u0026amp;AnyStruct{}, td.Zero()) // is false, coz pointer ≠ nil td.Cmp(t, \u0026amp;AnyStruct{}, td.Ptr(td.Zero())) // is true  See also Zero godoc.\n Example   Base example   t := \u0026amp;testing.T{} ok := td.Cmp(t, 0, td.Zero()) fmt.Println(ok) ok = td.Cmp(t, float64(0), td.Zero()) fmt.Println(ok) ok = td.Cmp(t, 12, td.Zero()) // fails, as 12 is not 0 :) \tfmt.Println(ok) ok = td.Cmp(t, (map[string]int)(nil), td.Zero()) fmt.Println(ok) ok = td.Cmp(t, map[string]int{}, td.Zero()) // fails, as not nil \tfmt.Println(ok) ok = td.Cmp(t, ([]int)(nil), td.Zero()) fmt.Println(ok) ok = td.Cmp(t, []int{}, td.Zero()) // fails, as not nil \tfmt.Println(ok) ok = td.Cmp(t, [3]int{}, td.Zero()) fmt.Println(ok) ok = td.Cmp(t, [3]int{0, 1}, td.Zero()) // fails, DATA[1] is not 0 \tfmt.Println(ok) ok = td.Cmp(t, bytes.Buffer{}, td.Zero()) fmt.Println(ok) ok = td.Cmp(t, \u0026amp;bytes.Buffer{}, td.Zero()) // fails, as pointer not nil \tfmt.Println(ok) ok = td.Cmp(t, \u0026amp;bytes.Buffer{}, td.Ptr(td.Zero())) // OK with the help of Ptr() \tfmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true     CmpZero shortcut func CmpZero(t TestingT, got interface{}, args ...interface{}) bool CmpZero is a shortcut for:\ntd.Cmp(t, got, td.Zero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also CmpZero godoc.\n Example   Base example   t := \u0026amp;testing.T{} ok := td.CmpZero(t, 0) fmt.Println(ok) ok = td.CmpZero(t, float64(0)) fmt.Println(ok) ok = td.CmpZero(t, 12) // fails, as 12 is not 0 :) \tfmt.Println(ok) ok = td.CmpZero(t, (map[string]int)(nil)) fmt.Println(ok) ok = td.CmpZero(t, map[string]int{}) // fails, as not nil \tfmt.Println(ok) ok = td.CmpZero(t, ([]int)(nil)) fmt.Println(ok) ok = td.CmpZero(t, []int{}) // fails, as not nil \tfmt.Println(ok) ok = td.CmpZero(t, [3]int{}) fmt.Println(ok) ok = td.CmpZero(t, [3]int{0, 1}) // fails, DATA[1] is not 0 \tfmt.Println(ok) ok = td.CmpZero(t, bytes.Buffer{}) fmt.Println(ok) ok = td.CmpZero(t, \u0026amp;bytes.Buffer{}) // fails, as pointer not nil \tfmt.Println(ok) ok = td.Cmp(t, \u0026amp;bytes.Buffer{}, td.Ptr(td.Zero())) // OK with the help of Ptr() \tfmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true     T.Zero shortcut func (t *T) Zero(got interface{}, args ...interface{}) bool Zero is a shortcut for:\nt.Cmp(got, td.Zero(), args...) See above for details.\nReturns true if the test is OK, false if it fails.\nargs\u0026hellip; are optional and allow to name the test. This name is used in case of failure to qualify the test. If len(args) \u0026gt; 1 and the first item of args is a string and contains a \u0026lsquo;%\u0026rsquo; rune then fmt.Fprintf is used to compose the name, else args are passed to fmt.Fprint. Do not forget it is the name of the test, not the reason of a potential failure.\n See also T.Zero godoc.\n Example   Base example   t := td.NewT(\u0026amp;testing.T{}) ok := t.Zero(0) fmt.Println(ok) ok = t.Zero(float64(0)) fmt.Println(ok) ok = t.Zero(12) // fails, as 12 is not 0 :) \tfmt.Println(ok) ok = t.Zero((map[string]int)(nil)) fmt.Println(ok) ok = t.Zero(map[string]int{}) // fails, as not nil \tfmt.Println(ok) ok = t.Zero(([]int)(nil)) fmt.Println(ok) ok = t.Zero([]int{}) // fails, as not nil \tfmt.Println(ok) ok = t.Zero([3]int{}) fmt.Println(ok) ok = t.Zero([3]int{0, 1}) // fails, DATA[1] is not 0 \tfmt.Println(ok) ok = t.Zero(bytes.Buffer{}) fmt.Println(ok) ok = t.Zero(\u0026amp;bytes.Buffer{}) // fails, as pointer not nil \tfmt.Println(ok) ok = t.Cmp(\u0026amp;bytes.Buffer{}, td.Ptr(td.Zero())) // OK with the help of Ptr() \tfmt.Println(ok) // Output: \t// true \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true \t// false \t// true     "},{"uri":"https://go-testdeep.zetta.rocks/example/","title":"Example","tags":[],"description":"","content":"Imagine a function returning a struct containing a newly created database record. The Id and the CreatedAt fields are set by the database layer:\ntype Record struct { Id uint64 Name string Age int CreatedAt time.Time } func CreateRecord(name string, age int) (*Record, error) { // Do INSERT INTO … and return newly created record or error if it failed } "},{"uri":"https://go-testdeep.zetta.rocks/functions/","title":"Functions","tags":[],"description":"","content":"import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(t *testing.T) { // Compares MyFunc() result against a fixed value  td.Cmp(t, MyFunc(), 128, \u0026#34;MyFunc() result is 128\u0026#34;) // Compares MyFunc() result using the Between Testdeep operator  td.Cmp(t, MyFunc(), td.Between(100, 199), \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) }  func Cmp(t TestingT, got, expected interface{}, args ...interface{}) bool func CmpError(t TestingT, got error, args ...interface{}) bool func CmpFalse(t TestingT, got interface{}, args ...interface{}) bool func CmpLax(t TestingT, got interface{}, expected interface{}, args ...interface{}) bool (in fact the shortcut of Lax operator) func CmpNoError(t TestingT, got error, args ...interface{}) bool func CmpNot(t TestingT, got interface{}, notExpected interface{}, args ...interface{}) bool (in fact the shortcut of Not operator) func CmpNotPanic(t TestingT, fn func(), args ...interface{}) bool func CmpPanic(t TestingT, fn func(), expectedPanic interface{}, args ...interface{}) bool func CmpTrue(t TestingT, got interface{}, args ...interface{}) bool func EqDeeply(got, expected interface{}) bool func EqDeeplyError(got, expected interface{}) error  CmpDeeply() is now replaced by Cmp(), but it is still available for backward compatibility purpose.\nMain shortcut functions import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(t *testing.T) { td.CmpBetween(t, MyFunc(), 100, 199, td.BoundsInIn, \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) } For each of these functions, it is always a shortcut on Cmp() and the correponding Testdeep operator:\nCmpHasPrefix(t, got, expected, …) ⇒ Cmp(t, got, HasPrefix(expected), …) ^-------^ ^-------^ +--------------------------------------------+ Each shortcut method is described in the corresponding operator page. See operators list.\n"},{"uri":"https://go-testdeep.zetta.rocks/operators/","title":"Operators","tags":[],"description":"","content":"All operators  All all expected values have to match Any at least one expected value have to match Array compares the contents of an array or a pointer on an array ArrayEach compares each array or slice item Bag compares the contents of an array or a slice without taking care of the order of items Between checks that a number, string or time.Time is between two bounds Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Code checks using a custom function Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key Delay delays the operator construction till first use Empty checks that an array, a channel, a map, a slice or a string is empty Gt checks that a number, string or time.Time is greater than a value Gte checks that a number, string or time.Time is greater or equal than a value HasPrefix checks the prefix of a string, []byte, error or fmt.Stringer interfaces HasSuffix checks the suffix of a string, []byte, error or fmt.Stringer interfaces Ignore allows to ignore a comparison Isa checks the data type or whether data implements an interface or not JSON compares against JSON representation Keys checks keys of a map Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length Lt checks that a number, string or time.Time is lesser than a value Lte checks that a number, string or time.Time is lesser or equal than a value Map compares the contents of a map MapEach compares each map entry N compares a number with a tolerance value NaN checks a floating number is math.NaN Nil compares to nil None no values have to match Not value must not match NotAny compares the contents of an array or a slice, no values have to match NotEmpty checks that an array, a channel, a map, a slice or a string is not empty NotNaN checks a floating number is not math.NaN NotNil checks that data is not nil NotZero checks that data is not zero regarding its type PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Re allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups ReAll allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Set compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items Shallow compares pointers only, not their contents Slice compares the contents of a slice or a pointer on a slice Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process SStruct strictly compares the contents of a struct or a pointer on a struct String checks a string, []byte, error or fmt.Stringer interfaces string contents Struct compares the contents of a struct or a pointer on a struct SubBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some exclusions SubJSONOf compares struct or map against JSON representation but with potentially some exclusions SubMapOf compares the contents of a map but with potentially some exclusions SubSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some exclusions SuperBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some extra items SuperJSONOf compares struct or map against JSON representation but with potentially extra entries SuperMapOf compares the contents of a map but with potentially some extra entries SuperSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some extra items Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders TruncTime compares time.Time (or assignable) values after truncating them Values checks values of a map Zero checks data against its zero\u0026rsquo;ed conterpart  Smuggler operators A smuggler operator is an operator able to transform the value (by changing its value or even its type) before comparing it.\nThe following operators are smuggler ones:\n Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key Keys checks keys of a map Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders Values checks values of a map  TypeBehind method TypeBehind() reflect.Type This method returns the type handled by the operator or nil if it is not known. tdhttp helper uses it to know how to unmarshal HTTP responses bodies before comparing them using the operator.\nIt is usually not used outside the go-testdeep repository.\n"},{"uri":"https://go-testdeep.zetta.rocks/example/basic-testdeep/","title":"Basic go-testdeep approach","tags":[],"description":"","content":"td package, via its Cmp* functions, handles the tests and all the error message boiler plate. Let\u0026rsquo;s do it:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record.Id, td.NotZero(), \u0026#34;Id initialized\u0026#34;) td.Cmp(t, record.Name, \u0026#34;Bob\u0026#34;) td.Cmp(t, record.Age, 23) td.Cmp(t, record.CreatedAt, td.Between(before, time.Now())) } } As we cannot guess the Id field value before its creation, we use the NotZero operator to check it is set by CreateRecord() call. The same is true for the creation date field CreatedAt. Thanks to the Between operator we can check it is set with a value included between the date before CreateRecord() call and the date just after.\nNote that if Id and CreateAt could be known in advance, we could simply do:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record, \u0026amp;Record{ Id: 1234, Name: \u0026#34;Bob\u0026#34;, Age: 23, CreatedAt: time.Date(2019, time.May, 1, 12, 13, 14, 0, time.UTC), }) } } But unfortunately, it is common to not know exactly the value of some fields…\n"},{"uri":"https://go-testdeep.zetta.rocks/helpers/","title":"Helpers","tags":[],"description":"","content":"HTTP API test helper aka tdhttp The tdhttp package helper allows to easily test HTTP APIs.\nIt handles any kind of API, with some specific features for the routes accepting and/or returning JSON or XML.\nSee examples of use in tdhttp package example section, in FAQ or expand the one below:\n  Main example   package myapi import ( \u0026#34;encoding/json\u0026#34; \u0026#34;encoding/xml\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/helpers/tdhttp\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyAPI(t *testing.T) { // Our API handle Persons with 3 routes: \t// - POST /person \t// - GET /person/{personID} \t// - DELETE /person/{personID}  // Person describes a person. \ttype Person struct { ID int64 `json:\u0026#34;id,omitempty\u0026#34; xml:\u0026#34;ID,omitempty\u0026#34;` Name string `json:\u0026#34;name\u0026#34; xml:\u0026#34;Name\u0026#34;` Age int `json:\u0026#34;age\u0026#34; xml:\u0026#34;Age\u0026#34;` CreatedAt *time.Time `json:\u0026#34;created_at,omitempty\u0026#34; xml:\u0026#34;CreatedAt,omitempty\u0026#34;` } // Error is returned to the client in case of error. \ttype Error struct { Mesg string `json:\u0026#34;message\u0026#34; xml:\u0026#34;Message\u0026#34;` Code int `json:\u0026#34;code\u0026#34; xml:\u0026#34;Code\u0026#34;` } // Our µDB :) \tvar mu sync.Mutex personByID := map[int64]*Person{} personByName := map[string]*Person{} var lastID int64 // reply is a helper to send responses. \treply := func(w http.ResponseWriter, status int, contentType string, body interface{}) { if body == nil { w.WriteHeader(status) return } w.Header().Set(\u0026#34;Content-Type\u0026#34;, contentType) w.WriteHeader(status) switch contentType { case \u0026#34;application/json\u0026#34;: json.NewEncoder(w).Encode(body) //nolint: errcheck \tcase \u0026#34;application/xml\u0026#34;: xml.NewEncoder(w).Encode(body) //nolint: errcheck \tdefault: // text/plain \tfmt.Fprintf(w, \u0026#34;%+v\u0026#34;, body) } } // Our API \tmux := http.NewServeMux() // POST /person \tmux.HandleFunc(\u0026#34;/person\u0026#34;, func(w http.ResponseWriter, req *http.Request) { if req.Method != http.MethodPost { http.Error(w, \u0026#34;Method not allowed\u0026#34;, http.StatusMethodNotAllowed) return } if req.Body == nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } defer req.Body.Close() var in Person var contentType string switch req.Header.Get(\u0026#34;Content-Type\u0026#34;) { case \u0026#34;application/json\u0026#34;: err := json.NewDecoder(req.Body).Decode(\u0026amp;in) if err != nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } case \u0026#34;application/xml\u0026#34;: err := xml.NewDecoder(req.Body).Decode(\u0026amp;in) if err != nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } case \u0026#34;application/x-www-form-urlencoded\u0026#34;: b, err := ioutil.ReadAll(req.Body) if err != nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } v, err := url.ParseQuery(string(b)) if err != nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } in.Name = v.Get(\u0026#34;name\u0026#34;) in.Age, err = strconv.Atoi(v.Get(\u0026#34;age\u0026#34;)) if err != nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } default: http.Error(w, \u0026#34;Unsupported media type\u0026#34;, http.StatusUnsupportedMediaType) return } contentType = req.Header.Get(\u0026#34;Accept\u0026#34;) if in.Name == \u0026#34;\u0026#34; || in.Age \u0026lt;= 0 { reply(w, http.StatusBadRequest, contentType, Error{ Mesg: \u0026#34;Empty name or bad age\u0026#34;, Code: http.StatusBadRequest, }) return } mu.Lock() defer mu.Unlock() if personByName[in.Name] != nil { reply(w, http.StatusConflict, contentType, Error{ Mesg: \u0026#34;Person already exists\u0026#34;, Code: http.StatusConflict, }) return } lastID++ in.ID = lastID now := time.Now() in.CreatedAt = \u0026amp;now personByID[in.ID] = \u0026amp;in personByName[in.Name] = \u0026amp;in reply(w, http.StatusCreated, contentType, in) }) // GET /person/{id} \t// DELETE /person/{id} \tmux.HandleFunc(\u0026#34;/person/\u0026#34;, func(w http.ResponseWriter, req *http.Request) { id, err := strconv.ParseInt(strings.TrimPrefix(req.URL.Path, \u0026#34;/person/\u0026#34;), 10, 64) if err != nil { http.Error(w, \u0026#34;Bad request\u0026#34;, http.StatusBadRequest) return } accept := req.Header.Get(\u0026#34;Accept\u0026#34;) mu.Lock() defer mu.Unlock() if personByID[id] == nil { reply(w, http.StatusNotFound, accept, Error{ Mesg: \u0026#34;Person does not exist\u0026#34;, Code: http.StatusNotFound, }) return } switch req.Method { case http.MethodGet: reply(w, http.StatusOK, accept, personByID[id]) case http.MethodDelete: delete(personByID, id) reply(w, http.StatusNoContent, \u0026#34;\u0026#34;, nil) default: http.Error(w, \u0026#34;Method not allowed\u0026#34;, http.StatusMethodNotAllowed) } }) // \t// Let\u0026#39;s test our API \t// \tta := tdhttp.NewTestAPI(t, mux) // Re-usable custom operator to check Content-Type header \tcontentTypeIs := func(ct string) td.TestDeep { return td.SuperMapOf(http.Header{\u0026#34;Content-Type\u0026#34;: []string{ct}}, nil) } // \t// Person not found \t// \tta.Get(\u0026#34;/person/42\u0026#34;, \u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;). Name(\u0026#34;GET /person/42 - JSON\u0026#34;). CmpStatus(404). CmpHeader(contentTypeIs(\u0026#34;application/json\u0026#34;)). CmpJSONBody(Error{ Mesg: \u0026#34;Person does not exist\u0026#34;, Code: 404, }) t.Log(\u0026#34;GET /person/42 - JSON:\u0026#34;, !ta.Failed()) ta.Get(\u0026#34;/person/42\u0026#34;, \u0026#34;Accept\u0026#34;, \u0026#34;application/xml\u0026#34;). Name(\u0026#34;GET /person/42 - XML\u0026#34;). CmpStatus(404). CmpHeader(contentTypeIs(\u0026#34;application/xml\u0026#34;)). CmpXMLBody(Error{ Mesg: \u0026#34;Person does not exist\u0026#34;, Code: 404, }) t.Log(\u0026#34;GET /person/42 - XML:\u0026#34;, !ta.Failed()) ta.Get(\u0026#34;/person/42\u0026#34;, \u0026#34;Accept\u0026#34;, \u0026#34;text/plain\u0026#34;). Name(\u0026#34;GET /person/42 - raw\u0026#34;). CmpStatus(404). CmpHeader(contentTypeIs(\u0026#34;text/plain\u0026#34;)). CmpBody(\u0026#34;{Mesg:Person does not exist Code:404}\u0026#34;) t.Log(\u0026#34;GET /person/42 - raw:\u0026#34;, !ta.Failed()) // \t// Create a Person \t// \tvar bobID int64 ta.PostXML(\u0026#34;/person\u0026#34;, Person{Name: \u0026#34;Bob\u0026#34;, Age: 32}, \u0026#34;Accept\u0026#34;, \u0026#34;application/xml\u0026#34;). Name(\u0026#34;POST /person - XML\u0026#34;). CmpStatus(201). CmpHeader(contentTypeIs(\u0026#34;application/xml\u0026#34;)). CmpXMLBody(Person{ // using operator anchoring directly in litteral \tID: ta.A(td.Catch(\u0026amp;bobID, td.NotZero()), int64(0)).(int64), Name: \u0026#34;Bob\u0026#34;, Age: 32, CreatedAt: ta.A(td.Ptr(td.Between(ta.SentAt(), time.Now()))).(*time.Time), }) t.Logf(\u0026#34;POST /person - XML: %t → Bob ID=%d\\n\u0026#34;, !ta.Failed(), bobID) var aliceID int64 ta.PostJSON(\u0026#34;/person\u0026#34;, Person{Name: \u0026#34;Alice\u0026#34;, Age: 35}, \u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;). Name(\u0026#34;POST /person - JSON\u0026#34;). CmpStatus(201). CmpHeader(contentTypeIs(\u0026#34;application/json\u0026#34;)). CmpJSONBody(td.JSON(` // using JSON operator (yes comment allowed in JSON!) { \u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 35, \u0026#34;created_at\u0026#34;: $2 }`, td.Catch(\u0026amp;aliceID, td.NotZero()), td.Smuggle(func(date string) (time.Time, error) { return time.Parse(time.RFC3339Nano, date) }, td.Between(ta.SentAt(), time.Now())))) t.Logf(\u0026#34;POST /person - JSON: %t → Alice ID=%d\\n\u0026#34;, !ta.Failed(), aliceID) var brittID int64 ta.PostForm(\u0026#34;/person\u0026#34;, url.Values{ \u0026#34;name\u0026#34;: []string{\u0026#34;Britt\u0026#34;}, \u0026#34;age\u0026#34;: []string{\u0026#34;29\u0026#34;}, }, \u0026#34;Accept\u0026#34;, \u0026#34;text/plain\u0026#34;). Name(\u0026#34;POST /person - raw\u0026#34;). CmpStatus(201). CmpHeader(contentTypeIs(\u0026#34;text/plain\u0026#34;)). // using Re (= Regexp) operator \tCmpBody(td.Re(`\\{ID:(\\d+) Name:Britt Age:29 CreatedAt:.*\\}\\z`, td.Smuggle(func(groups []string) (int64, error) { return strconv.ParseInt(groups[0], 10, 64) }, td.Catch(\u0026amp;brittID, td.NotZero())))) t.Logf(\u0026#34;POST /person - raw: %t → Britt ID=%d\\n\u0026#34;, !ta.Failed(), brittID) // \t// Get a Person \t// \tta.Get(fmt.Sprintf(\u0026#34;/person/%d\u0026#34;, aliceID), \u0026#34;Accept\u0026#34;, \u0026#34;application/xml\u0026#34;). Name(\u0026#34;GET Alice - XML (ID #%d)\u0026#34;, aliceID). CmpStatus(200). CmpHeader(contentTypeIs(\u0026#34;application/xml\u0026#34;)). CmpXMLBody(td.SStruct( // using SStruct operator \tPerson{ ID: aliceID, Name: \u0026#34;Alice\u0026#34;, Age: 35, }, td.StructFields{ \u0026#34;CreatedAt\u0026#34;: td.Ptr(td.NotZero()), }, )) t.Log(\u0026#34;GET XML Alice:\u0026#34;, !ta.Failed()) ta.Get(fmt.Sprintf(\u0026#34;/person/%d\u0026#34;, aliceID), \u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;). Name(\u0026#34;GET Alice - JSON (ID #%d)\u0026#34;, aliceID). CmpStatus(200). CmpHeader(contentTypeIs(\u0026#34;application/json\u0026#34;)). CmpJSONBody(td.JSON(` // using JSON operator (yes comment allowed in JSON!) { \u0026#34;id\u0026#34;: $1, \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 35, \u0026#34;created_at\u0026#34;: $2 }`, aliceID, td.Not(td.Re(`^0001-01-01`)), // time is not 0001-01-01… aka zero time.Time \t)) t.Log(\u0026#34;GET JSON Alice:\u0026#34;, !ta.Failed()) // \t// Delete a Person \t// \tta.Delete(fmt.Sprintf(\u0026#34;/person/%d\u0026#34;, aliceID), nil). Name(\u0026#34;DELETE Alice (ID #%d)\u0026#34;, aliceID). CmpStatus(204). CmpHeader(td.Not(td.ContainsKey(\u0026#34;Content-Type\u0026#34;))). NoBody() t.Log(\u0026#34;DELETE Alice:\u0026#34;, !ta.Failed()) // Check Alice is deleted \tta.Get(fmt.Sprintf(\u0026#34;/person/%d\u0026#34;, aliceID), \u0026#34;Accept\u0026#34;, \u0026#34;application/json\u0026#34;). Name(\u0026#34;GET (deleted) Alice - JSON (ID #%d)\u0026#34;, aliceID). CmpStatus(404). CmpHeader(contentTypeIs(\u0026#34;application/json\u0026#34;)). CmpJSONBody(td.JSON(` { \u0026#34;message\u0026#34;: \u0026#34;Person does not exist\u0026#34;, \u0026#34;code\u0026#34;: 404 }`)) t.Log(\u0026#34;Alice is not found anymore:\u0026#34;, !ta.Failed()) }    Helpers utils aka tdutil To write helpers, some commonly used functions are shared in tdutil package.\n"},{"uri":"https://go-testdeep.zetta.rocks/faq/","title":"FAQ","tags":[],"description":"","content":"How to mix strict requirements and simple assertions? import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestAssertionsAndRequirements(t *testing.T) { assert, require := td.AssertRequire(t) got := SomeFunction() require.Cmp(got, expected) // if it fails: report error + abort  assert.Cmp(got, expected) // if it fails: report error + continue } Why nil is handled so specifically? var pn *int td.Cmp(t, pn, nil) fails with the error And, yes, it is normal. (TL;DR use CmpNil instead, safer, or use CmpLax, but be careful of edge cases.)\nTo understand why, look at the following examples:\nvar err error td.Cmp(t, err, nil) works (and you want it works), but\nvar err error = (*MyError)(nil) td.Cmp(t, err, nil) fails with the error and in most cases you want it fails, because err is not nil! The pointer stored in the interface is nil, but not the interface itself.\nAs Cmp got parameter type is interface{}, when you pass an interface variable in it (whatever the interface is), Cmp always receives an interface{}. So here, Cmp receives (*MyError)(nil) in the got interface, and not error((*MyError)(nil)) ⇒ the error interface information is lost at the compilation time.\nIn other words, Cmp has no abilities to tell the difference between error((*MyError)(nil)) and (*MyError)(nil) when passed in got parameter.\nThat is why Cmp is strict by default, and requires that nil be strongly typed, to be able to detect when a non-nil interface contains a nil pointer.\nSo to recap:\nvar pn *int td.Cmp(t, pn, nil) // fails as nil is not strongly typed td.Cmp(t, pn, (*int)(nil)) // succeeds td.Cmp(t, pn, td.Nil()) // succeeds td.CmpNil(t, pn) // succeeds td.Cmp(t, pn, td.Lax(nil)) // succeeds td.CmpLax(t, pn, nil) // succeeds  var err error td.Cmp(t, err, nil) // succeeds td.Cmp(t, err, (*MyError)(nil)) // fails as err does not contain any value td.Cmp(t, err, td.Nil()) // succeeds td.CmpNil(t, err) // succeeds td.Cmp(t, err, td.Lax(nil)) // succeeds td.CmpLax(t, err, nil) // succeeds td.CmpError(t, err) // fails as err is nil td.CmpNoError(t, err) // succeeds  err = (*MyError)(nil) td.Cmp(t, err, nil) // fails as err contains a value td.Cmp(t, err, (*MyError)(nil)) // succeeds td.Cmp(t, err, td.Nil()) // succeeds td.CmpNil(t, err) // succeeds td.Cmp(t, err, td.Lax(nil)) // succeeds *** /!\\ be careful here! *** td.CmpLax(t, err, nil) // succeeds *** /!\\ be careful here! *** td.CmpError(t, err) // succeeds td.CmpNoError(t, err) // fails as err contains a value Morality:\n to compare a pointer against nil, use CmpNil or strongly type nil (e.g. (*int)(nil)) in expected parameter of Cmp; to compare an error against nil, use CmpNoError or nil direcly in expected parameter of Cmp.  How does operator anchoring work? Take this struct, returned by a GetPerson() function:\ntype Person struct { ID int64 Name string Age uint8 } For the Person returned by GetPerson(), we expect that:\n ID field should be ≠ 0; Name field should always be \u0026ldquo;Bob\u0026rdquo;; Age field should be ≥ 40 and ≤ 45.  Without operator anchoring:\nfunc TestPerson(tt *testing.T) { t := td.NewT(tt) t.Cmp(GetPerson(), // ← ①  td.Struct(Person{Name: \u0026#34;Bob\u0026#34;}, // ← ②  td.StructFields{ // ← ③  \u0026#34;ID\u0026#34;: td.NotZero(), // ← ④  \u0026#34;Age\u0026#34;: td.Between(uint8(40), uint8(45)), // ← ⑤  })) }  GetPerson() returns a Person; as some fields of the returned Person are not exactly known in advance, we use the Struct operator as expected parameter. It allows to match exactly some fields, and use TestDeep operators on others. Here we know that Name field should always be \u0026ldquo;Bob\u0026rdquo;; StructFields is a map allowing to use TestDeep operators for any field; ID field should be ≠ 0. See NotZero operator for details; Age field should be ≥ 40 and ≤ 45. See Between operator for details.  With operator anchoring, the use of Struct operator is no longer needed:\nfunc TestPerson(tt *testing.T) { t := td.NewT(tt) t.Cmp(GetPerson(), // ← ①  Person{ // ← ②  Name: \u0026#34;Bob\u0026#34;, // ← ③  ID: t.A(td.NotZero(), int64(0)).(int64), // ← ④  Age: t.A(td.Between(uint8(40), uint8(45))).(uint8), // ← ⑤  }) }  GetPerson() still returns a Person; expected parameter is directly a Person. No operator needed here; Name field should always be \u0026ldquo;Bob\u0026rdquo;, no change here; ID field should be ≠ 0: anchor the NotZero operator using the A method. Break this line down: t.A( // ← ①  td.NotZero(), // ← ②  int64(0), // ← ③ ).(int64) // ← ④  the A method is the key of the anchoring system. It saves the operator globally, so it can be retrieved during the comparison of the next Cmp call, the operator we want to anchor, this optional parameter is needed to tell A that the returned value must be a int64. Sometimes, this type can be deduced from the operator, but as NotZero can handle any kind of number, it is not the case here. So we have to pass it, as A method returns an interface{}, we need to assert the int64 type to bypass the golang static typing system,   Age field should be ≥ 40 and ≤ 45: anchor the Between operator using the A method. Break this line down: t.A( // ← ①  td.Between(uint8(40), uint8(45)), // ← ② ).(uint8) // ← ③  the A method saves the operator globally, so it can be retrieved during the comparison of the next Cmp call, the operator we want to anchor. As Between knows the type of its operands (here uint8), there is no need to tell A the returned type must be uint8. It can be deduced from Between, as A method returns an interface{}, we need to assert the uint8 type to bypass the golang static typing system.    Note the A method is a shortcut of Anchor method.\nSome rules have to be kept in mind:\n never cast a value returned by A or Anchor methods: t := td.NewT(tt) // tt is a *testing.T t.A(td.NotZero(), uint(8)).(uint8) // OK uint16(t.A(td.NotZero(), uint(8)).(uint8)) // Not OK! t.A(td.NotZero(), uint16(0)).(uint16) // OK  anchored operators disappear once the next Cmp call done. To share them between Cmp calls, use the SetAnchorsPersist method as in: t := td.NewT(tt) // tt is a *testing.T age := t.A(td.Between(uint8(40), uint8(45))).(uint8) t.SetAnchorsPersist(true) // ← Don\u0026#39;t reset anchors after next Cmp() call  t.Cmp(GetPerson(1), Person{ Name: \u0026#34;Bob\u0026#34;, Age: age, }) t.Cmp(GetPerson(2), Person{ Name: \u0026#34;Bob\u0026#34;, Age: age, // ← OK })   How to test io.Reader contents, like net/http.Response.Body for example? The Smuggle operator is done for that, here with the help of ReadAll.\nimport ( \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends \u0026#34;Expected Response!\u0026#34;  var resp *http.Response = GetResponse() td.Cmp(t, resp.Body, td.Smuggle(ioutil.ReadAll, []byte(\u0026#34;Expected Response!\u0026#34;))) } OK, but I prefer comparing strings instead of bytes No problem, ReadAll the body by yourself and cast returned []byte contents to string, still using Smuggle operator:\nimport ( \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends \u0026#34;Expected Response!\u0026#34;  var resp *http.Response = GetResponse() td.Cmp(t, resp.Body, td.Smuggle( // ← transform a io.Reader to a string  func(body io.Reader) (string, error) { b, err := ioutil.ReadAll(body) return string(b), err }, \u0026#34;Expected Response!\u0026#34;)) } OK, but my response is in fact a JSON marshaled struct of my own No problem, JSON decode while reading the body:\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends `{\u0026#34;ID\u0026#34;:42,\u0026#34;Name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;Age\u0026#34;:28}`  var resp *http.Response = GetResponse() type Person struct { ID uint64 Name string Age int } td.Cmp(t, resp.Body, td.Smuggle( // ← transform a io.Reader in *Person  func(body io.Reader) (*Person, error) { var s Person return \u0026amp;s, json.NewDecoder(body).Decode(\u0026amp;s) }, \u0026amp;Person{ // ← check Person content  ID: 42, Name: \u0026#34;Bob\u0026#34;, Age: 28, })) } OK, but you are funny, this response sends a new created object, so I don\u0026rsquo;t know the ID in advance! No problem, use Struct operator to test that ID field is non-zero (as a bonus, add a CreatedAt field):\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestResponseBody(t *testing.T) { // Expect this response sends:  // `{\u0026#34;ID\u0026#34;:42,\u0026#34;Name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;Age\u0026#34;:28,\u0026#34;CreatedAt\u0026#34;:\u0026#34;2019-01-02T11:22:33Z\u0026#34;}`  var resp *http.Response = GetResponse() type Person struct { ID uint64 Name string Age int CreatedAt time.Time } y2019, _ := time.Parse(time.RFC3339, \u0026#34;2019-01-01T00:00:00Z\u0026#34;) td.Cmp(t, resp.Body, td.Smuggle( // ← transform a io.Reader in *Person  func(body io.Reader) (*Person, error) { var s Person return \u0026amp;s, json.NewDecoder(body).Decode(\u0026amp;s) }, td.Struct(\u0026amp;Person{ // ← check Person content  Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.NotZero(), // check ID ≠ 0  \u0026#34;CreatedAt\u0026#34;: td.Gte(y2019), // check CreatedAt ≥ 2019/01/01  }))) tt := td.newT(t) tt.Cmp(resp.Body, td.Smuggle( // ← transform a io.Reader in *Person  func(body io.Reader) (*Person, error) { var s Person return \u0026amp;s, json.NewDecoder(body).Decode(\u0026amp;s) }, \u0026amp;Person{ // ← check Person content  Name: \u0026#34;Bob\u0026#34;, Age: 28, ID: tt.A(td.NotZero(), uint64(0)).(uint64), // check ID ≠ 0  CreatedAt: tt.A(td.Gte(y2019)).(time.Time), // check CreatedAt ≥ 2019/01/01  })) } What about testing the response using my API? tdhttp helper is done for that!\nimport ( \u0026#34;encoding/json\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/helpers/tdhttp\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) type Person struct { ID uint64 Name string Age int CreatedAt time.Time } // MyApi defines our API. func MyAPI() *http.ServeMux { mux := http.NewServeMux() // GET /json  mux.HandleFunc(\u0026#34;/json\u0026#34;, func(w http.ResponseWriter, req *http.Request) { if req.Method != \u0026#34;GET\u0026#34; { http.NotFound(w, req) return } b, err := json.Marshal(Person{ ID: 42, Name: \u0026#34;Bob\u0026#34;, Age: 28, CreatedAt: time.Now().UTC(), }) if err != nil { http.Error(w, \u0026#34;Internal server error\u0026#34;, http.StatusInternalServerError) return } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) w.Write(b) }) return mux } func TestMyApi(t *testing.T) { myAPI := MyAPI() y2019, _ := time.Parse(time.RFC3339, \u0026#34;2019-01-01T00:00:00Z\u0026#34;) testAPI := tdhttp.NewTestAPI(t, myAPI) // ← ①  testAPI.Get(\u0026#34;/json\u0026#34;). // ← ②  Name(\u0026#34;Testing GET /json\u0026#34;). CmpStatus(http.StatusOK). // ← ③  CmpJSONBody(td.SStruct(\u0026amp;Person{ // ← ④  Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.NotZero(), // ← ⑤  \u0026#34;CreatedAt\u0026#34;: td.Gte(y2019), // ← ⑥  })) // testAPI can be used to test another route… }  the API handler ready to be tested; the GET request; the expected HTTP status should be http.StatusOK; the expected body should match the SStruct operator; check the ID field is NotZero; check the CreatedAt field is greater or equal than y2019 variable (set just before tdhttp.NewTestAPI call).  If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nArf, I use Gin Gonic, and so no net/http handlers It is exactly the same as for net/http handlers as *gin.Engine implements http.Handler interface! So keep using tdhttp helper:\nimport ( \u0026#34;net/http\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/helpers/tdhttp\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) type Person struct { ID uint64 Name string Age int CreatedAt time.Time } // MyGinGonicApi defines our API. func MyGinGonicAPI() *gin.Engine { router := gin.Default() // or gin.New() or receive the router by param it doesn\u0026#39;t matter  router.GET(\u0026#34;/json\u0026#34;, func(c *gin.Context) { c.JSON(http.StatusOK, Person{ ID: 42, Name: \u0026#34;Bob\u0026#34;, Age: 28, CreatedAt: time.Now().UTC(), }) }) return router } func TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() y2019, _ := time.Parse(time.RFC3339, \u0026#34;2019-01-01T00:00:00Z\u0026#34;) testAPI := tdhttp.NewTestAPI(t, myAPI) // ← ①  testAPI.Get(\u0026#34;/json\u0026#34;). // ← ②  Name(\u0026#34;Testing GET /json\u0026#34;). CmpStatus(http.StatusOK). // ← ③  CmpJSONBody(td.SStruct(\u0026amp;Person{ // ← ④  Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.NotZero(), // ← ⑤  \u0026#34;CreatedAt\u0026#34;: td.Gte(y2019), // ← ⑥  })) // testAPI can be used to test another route… }  the API handler ready to be tested; the GET request; the expected HTTP status should be http.StatusOK; the expected body should match the SStruct operator; check the ID field is NotZero; check the CreatedAt field is greater or equal than y2019 variable (set just before tdhttp.NewTestAPI call).  If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nFine, the request succeeds and the ID is not 0, but what is the ID real value? Stay with tdhttp helper!\nIn fact you can Catch the ID before comparing it to 0 (as well as CreatedAt in fact). Try:\nfunc TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() var id uint64 var createdAt time.Time y2019, _ := time.Parse(time.RFC3339, \u0026#34;2019-01-01T00:00:00Z\u0026#34;) testAPI := tdhttp.NewTestAPI(t, myAPI) // ← ①  testAPI.Get(\u0026#34;/json\u0026#34;). // ← ②  Name(\u0026#34;Testing GET /json\u0026#34;). CmpStatus(http.StatusOK). // ← ③  CmpJSONBody(td.SStruct(\u0026amp;Person{ // ← ④  Name: \u0026#34;Bob\u0026#34;, Age: 28, }, td.StructFields{ \u0026#34;ID\u0026#34;: td.Catch(\u0026amp;id, td.NotZero()), // ← ⑤  \u0026#34;CreatedAt\u0026#34;: td.Catch(\u0026amp;createdAt, td.Gte(y2019)), // ← ⑥  })) if !testAPI.Failed() { t.Logf(\u0026#34;The ID is %d and was created at %s\u0026#34;, id, createdAt) } // testAPI can be used to test another route… }  the API handler ready to be tested; the GET request; the expected HTTP status should be http.StatusOK; the expected body should match the SStruct operator; Catch the ID field: put it in id variable and check it is NotZero; Catch the CreatedAt field: put it in createdAt variable and check it is greater or equal than y2019 variable (set just before tdhttp.NewTestAPI call).  If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nOK, but how to be sure the response content is well JSONified? Again, tdhttp helper is your friend!\nWith the help of JSON operator of course! See it below, used with Catch (note it can be used without), for a POST example:\ntype Person struct { ID uint64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Age int `json:\u0026#34;age\u0026#34;` CreatedAt time.Time `json:\u0026#34;created_at\u0026#34;` } func TestMyGinGonicApi(t *testing.T) { myAPI := MyGinGonicAPI() var id uint64 var createdAt time.Time testAPI := tdhttp.NewTestAPI(t, myAPI) // ← ①  testAPI.PostJSON(\u0026#34;/person\u0026#34;, Person{Name: \u0026#34;Bob\u0026#34;, Age: 42}), // ← ②  Name(\u0026#34;Create a new Person\u0026#34;). CmpStatus(http.StatusCreated). // ← ③ \tCmpJSONBody(td.JSON(` { \u0026#34;id\u0026#34;: $id, \u0026#34;name\u0026#34;: \u0026#34;Bob\u0026#34;, \u0026#34;age\u0026#34;: 42, \u0026#34;created_at\u0026#34;: \u0026#34;$createdAt\u0026#34;, }`, td.Tag(\u0026#34;id\u0026#34;, td.Catch(\u0026amp;id, td.NotZero())), // ← ④  td.Tag(\u0026#34;created_at\u0026#34;, td.All( // ← ⑤  td.HasSuffix(\u0026#34;Z\u0026#34;), // ← ⑥  td.Smuggle(func(s string) (time.Time, error) { // ← ⑦  return time.Parse(time.RFC3339Nano, s) }, td.Catch(\u0026amp;createdAt, td.Gte(testAPI.SentAt()))), // ← ⑧  )), )) if !testAPI.Failed() { t.Logf(\u0026#34;The new Person ID is %d and was created at %s\u0026#34;, id, createdAt) } // testAPI can be used to test another route… }  the API handler ready to be tested; the POST request with automatic JSON marshalling; the expected HTTP status should be http.StatusCreated and the line just below, the body should match the JSON operator; for the $id placeholder, Catch its value: put it in id variable and check it is NotZero; for the $created_at placeholder, use the All operator. It combines several operators like a AND; check that $created_at date ends with \u0026ldquo;Z\u0026rdquo; using HasSuffix. As we expect a RFC3339 date, we require it in UTC time zone; convert $created_at date into a time.Time using a custom function thanks to the Smuggle operator; then Catch the resulting value: put it in createdAt variable and check it is greater or equal than testAPI.SentAt() (the time just before the request is handled).  If you prefer to do one function call instead of chaining methods as above, you can try CmpJSONResponse.\nMy API use XML not JSON! tdhttp helper provides the same functions and methods for XML it does for JSON.\nRTFM :)\nNote that the JSON operator have not its XML counterpart yet. But PRs are welcome!\nShould I import github.com/maxatome/go-testdeep or github.com/maxatome/go-testdeep/td? Historically the main package of go-testdeep was testdeep as in:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(t *testing.T) { testdeep.Cmp(t, GetPerson(), Person{Name: \u0026#34;Bob\u0026#34;, Age: 42}) } As testdeep was boring to type, renaming it to td became a habit as in:\nimport ( \u0026#34;testing\u0026#34; td \u0026#34;github.com/maxatome/go-testdeep\u0026#34; ) func TestMyFunc(t *testing.T) { td.Cmp(t, GetPerson(), Person{Name: \u0026#34;Bob\u0026#34;, Age: 42}) } Forcing the developer to systematically rename testdeep package to td in all its tests is not very friendly. That is why a decision was taken to create a new package github.com/maxatome/go-testdeep/td while keeping github.com/maxatome/go-testdeep working thanks to go type aliases.\nSo the previous examples (that are still working) can now be written as:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(t *testing.T) { td.Cmp(t, GetPerson(), Person{Name: \u0026#34;Bob\u0026#34;, Age: 42}) } There is no package renaming anymore. Switching to import github.com/maxatome/go-testdeep/td is advised for new code.\nWhat does the error undefined: testdeep.DefaultContextConfig mean? Since release v1.3.0, this variable moved to the new github.com/maxatome/go-testdeep/td package.\n  If you rename the testdeep package to td as in:\nimport td \u0026quot;github.com/maxatome/go-testdeep\u0026quot; … td.DefaultContextConfig = td.ContextConfig{…} then just change the import line to:\nimport \u0026quot;github.com/maxatome/go-testdeep/td\u0026quot;   Otherwise, you have two choices:\n either add a new import line: import \u0026quot;github.com/maxatome/go-testdeep/td\u0026quot; then use td.DefaultContextConfig instead of testdeep.DefaultContextConfig, and continue to use testdeep package elsewhere.\n or replace the import line: import \u0026quot;github.com/maxatome/go-testdeep\u0026quot; by\nimport \u0026quot;github.com/maxatome/go-testdeep/td\u0026quot; then rename all occurrences of testdeep package to td.\n    go-testdeep dumps only 10 errors, how to have more (or less)? Using the environment variable TESTDEEP_MAX_ERRORS.\nTESTDEEP_MAX_ERRORS contains the maximum number of errors to report before stopping during one comparison (one Cmp execution for example). It defaults to 10.\nExample:\nTESTDEEP_MAX_ERRORS=30 go test Setting it to -1 means no limit:\nTESTDEEP_MAX_ERRORS=-1 go test How do I change these crappy colors? Using some environment variables:\n TESTDEEP_COLOR enable (on) or disable (off) the color output. It defaults to on; TESTDEEP_COLOR_TEST_NAME color of the test name. See below for color format, it defaults to yellow; TESTDEEP_COLOR_TITLE color of the test failure title. See below for color format, it defaults to cyan; TESTDEEP_COLOR_OK color of the test expected value. See below for color format, it defaults to green; TESTDEEP_COLOR_BAD color of the test got value. See below for color format, it defaults to red;  Color format A color in TESTDEEP_COLOR_* environment variables has the following format:\nforeground_color # set foreground color, background one untouched foreground_color:background_color # set foreground AND background color :background_color # set background color, foreground one untouched foreground_color and background_color can be:\n black red green yellow blue magenta cyan white gray  For example:\nTESTDEEP_COLOR_OK=black:green \\  TESTDEEP_COLOR_BAD=white:red \\  TESTDEEP_COLOR_TITLE=yellow \\  go test play.golang.org does not handle colors, error output is nasty Just add this single line in playground:\nfunc init() { os.Setenv(\u0026#34;TESTDEEP_COLOR\u0026#34;, \u0026#34;off\u0026#34;) } Until playground supports ANSI color escape sequences.\nThe X testing framework allows to test/do Y while go-testdeep not The Code and Smuggle operators should allow to cover all cases not handled by other operators.\nIf you think this missing feature deserves a specific operator, because it is frequently or widely used, file an issue and let\u0026rsquo;s discuss about it.\nWe plan to add a new github.com/maxatome/go-testdeep/helpers/tdcombo helper package, bringing together all what we can call combo-operators. Combo-operators are operators using any number of already existing operators.\nAs an example of such combo-operators, the following one. It allows to check that a string contains a RFC3339 formatted time, in UTC time zone (\u0026ldquo;Z\u0026rdquo; suffix) and then to compare it as a time.Time against expectedValue (which can be another operator or, of course, a time.Time value).\nfunc RFC3339ZToTime(expectedValue interface{}) td.TestDeep { return td.All( td.HasSuffix(\u0026#34;Z\u0026#34;), td.Smuggle(func(s string) (time.Time, error) { return time.Parse(time.RFC3339Nano, s) }, expectedValue), ) } It could be used as:\nbefore := time.Now() record := NewRecord() td.Cmp(t, record, td.SuperJSONOf(`{\u0026#34;created_at\u0026#34;: $1}`, tdcombo.RFC3339ZToTime(td.Between(before, time.Now()), )), \u0026#34;The JSONified record.created_at is UTC-RFC3339\u0026#34;, ) How to add a new operator? You want to add a new FooBar operator.\n check that another operator does not exist with the same meaning; add the operator definition in td_foo_bar.go file and fully document its usage:  add a // summary(FooBar): small description line, before operator comment, add a // input(FooBar): … line, just after summary(FooBar) line. This one lists all inputs accepted by the operator;   add operator tests in td_foo_bar_test.go file; in example_test.go file, add examples function(s) ExampleFooBar* in alphabetical order; automatically generate CmpFooBar \u0026amp; T.FooBar (+ examples) code: ./tools/gen_funcs.pl do not forget to run tests: go test ./... run golangci-lint as in .travis.yml;  Each time you change example_test.go, re-run ./tools/gen_funcs.pl to update corresponding CmpFooBar \u0026amp; T.FooBar examples.\nTest coverage must be 100%.\n"},{"uri":"https://go-testdeep.zetta.rocks/example/advanced-testdeep/","title":"Advanced go-testdeep technique","tags":[],"description":"","content":"Of course we can test struct fields one by one, but with go-testdeep and the [td package], the whole struct can be compared with one Cmp call.\nWe can choose to ignore the non-guessable fields set by CreateRecord():\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, nil), \u0026#34;Newly created record\u0026#34;) } } The Struct operator, used here, ignores zero fields in its model parameter.\nBut it is better to check all fields:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.Cmp(t, record, td.Struct( \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }), \u0026#34;Newly created record\u0026#34;) } } See the use of the Struct operator. It is needed here to overcome the go static typing system and so use other go-testdeep operators for some fields, here NotZero for Id and Between for CreatedAt.\nNot only structs can be compared. A lot of operators can be found to cover most (all?) needed tests. See the operators list.\nSay CreateRecord() does not set correctly CreatedAt field, then:\ngo test -run=TestCreateRecord outputs for last td.Cmp call:\nIf CreateRecord() had not set correctly Id field, output would have been:\nIf CreateRecord() had set Name field to \u0026ldquo;Alice\u0026rdquo; value instead of expected \u0026ldquo;Bob\u0026rdquo;, output would have been:\n"},{"uri":"https://go-testdeep.zetta.rocks/example/td-cmp-shortcuts/","title":"go-testdeep Cmp shortcuts","tags":[],"description":"","content":"The Cmp function is the keystone of this package, but to make the writing of tests even easier, the family of Cmp* functions are provided and act as shortcuts. Using CmpStruct function, the previous example can be written as:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(t *testing.T) { before := time.Now().Truncate(time.Second) record, err := CreateRecord() if td.CmpNoError(t, err) { td.CmpStruct(t, record, \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }, \u0026#34;Newly created record\u0026#34;) } } "},{"uri":"https://go-testdeep.zetta.rocks/example/td-t/","title":"td.T type","tags":[],"description":"","content":"testing.T can also be encapsulated in td.T type, simplifying again the test:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord() if t.CmpNoError(err) { t := t.RootName(\u0026#34;RECORD\u0026#34;) // Use RECORD instead of DATA in failure reports  // Using Struct shortcut method  t.Struct(record, \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }, \u0026#34;Newly created record\u0026#34;) // Or using Cmp method, it\u0026#39;s a matter of taste  t.Cmp(record, td.Struct( Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, }, td.StructFields{ \u0026#34;Id\u0026#34;: td.NotZero(), \u0026#34;CreatedAt\u0026#34;: td.Between(before, time.Now()), }), \u0026#34;Newly created record\u0026#34;) } } Note the use of RootName method, it allows to name what we are going to test, instead of the default \u0026ldquo;DATA\u0026rdquo;.\nIf CreateRecord() had set Name field to \u0026ldquo;Alice\u0026rdquo; value instead of expected \u0026ldquo;Bob\u0026rdquo;, output would have been (note \u0026ldquo;RECORD\u0026rdquo; replaced default \u0026ldquo;DATA\u0026rdquo;):\n"},{"uri":"https://go-testdeep.zetta.rocks/example/anchoring/","title":"Using anchoring","tags":[],"description":"","content":"Last, operators can directly be anchored in litterals, still using the td.T type, avoiding the use of the Struct operator:\nimport ( \u0026#34;testing\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestCreateRecord(tt *testing.T) { t := td.NewT(tt) before := time.Now().Truncate(time.Second) record, err := CreateRecord() if t.CmpNoError(err) { t.RootName(\u0026#34;RECORD\u0026#34;). // Use RECORD instead of DATA in failure reports  Cmp(record, \u0026amp;Record{ Name: \u0026#34;Bob\u0026#34;, Age: 23, Id: t.Anchor(td.NotZero(), uint64(0)).(uint64), CreatedAt: t.Anchor(td.Between(before, time.Now())).(time.Time), }, \u0026#34;Newly created record\u0026#34;) } } See the Anchor method documentation for details. Note that A method is also a synonym for Anchor.\nId: t.A(td.NotZero(), uint64(0)).(uint64), CreatedAt: t.A(td.Between(before, time.Now())).(time.Time), "},{"uri":"https://go-testdeep.zetta.rocks/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://go-testdeep.zetta.rocks/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://go-testdeep.zetta.rocks/functions/td-t/","title":"td.T","tags":[],"description":"","content":"Constructing *td.T import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), 12) }  func NewT(t TestingFT, config ...ContextConfig) *T func Assert(t TestingFT, config ...ContextConfig) *T func Require(t TestingFT, config ...ContextConfig) *T func AssertRequire(t TestingFT, config ...ContextConfig) (*T, *T)  Configuring *td.T func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual().RootName(\u0026#34;RECORD\u0026#34;) ... }  func (t *T) BeLax(enable ...bool) *T func (t *T) FailureIsFatal(enable ...bool) *T func (t *T) RootName(rootName string) *T func (t *T) UseEqual(enable ...bool) *T  Main methods of *td.T import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual() // Compares MyFunc() result against a fixed value  t.Cmp(MyFunc(), 128, \u0026#34;MyFunc() result is 128\u0026#34;) // Compares MyFunc() result using the Between Testdeep operator  t.Cmp(MyFunc(), td.Between(100, 199), \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) }  func (t *T) Cmp(got, expected interface{}, args ...interface{}) bool func (t *T) CmpError(got error, args ...interface{}) bool func (t *T) CmpLax(got interface{}, expected interface{}, args ...interface{}) bool (in fact the shortcut of Lax operator) func (t *T) CmpNoError(got error, args ...interface{}) bool func (t *T) CmpNotPanic(fn func(), args ...interface{}) bool func (t *T) CmpPanic(fn func(), expected interface{}, args ...interface{}) bool func (t *T) False(got interface{}, args ...interface{}) bool func (t *T) Not(got interface{}, notExpected interface{}, args ...interface{}) bool (in fact the shortcut of Not operator) func (t *T) RunT(name string, f func(t *T)) bool func (t *T) True(got interface{}, args ...interface{}) bool  CmpDeeply() method is now replaced by Cmp(), but it is still available for backward compatibility purpose.\nAnchoring methods of *td.T  func (t *T) A(operator TestDeep, model ...interface{}) interface{} func (t *T) Anchor(operator TestDeep, model ...interface{}) interface{} func (t *T) AnchorsPersistTemporarily() func() func (t *T) DoAnchorsPersist() bool func (t *T) ResetAnchors() func (t *T) SetAnchorsPersist(persist bool)  Shortcut methods of *td.T import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/maxatome/go-testdeep/td\u0026#34; ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt).UseEqual() t.Between(MyFunc(), 100, 199, td.BoundsInIn, \u0026#34;MyFunc() result is between 100 and 199\u0026#34;) } For each of these methods, it is always a shortcut on T.Cmp() and the correponding Testdeep operator:\nT.HasPrefix(got, expected, …) ⇒ T.Cmp(t, got, HasPrefix(expected), …) ^-------^ ^-------^ +-------------------------------------------+ Excluding Lax operator for which the shortcut method stays CmpLax.\nEach shortcut method is described in the corresponding operator page. See operators list.\n"}]