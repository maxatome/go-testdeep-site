<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go-testdeep</title><link>https://go-testdeep.zetta.rocks/index.html</link><description>go-testdeep, via the td package and its helpers, allows golang extremely flexible deep comparison. It is built for testing.
← use the left menu to navigate. A good starting point is the introduction or the presentation</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://go-testdeep.zetta.rocks/index.xml" rel="self" type="application/rss+xml"/><item><title>Introduction</title><link>https://go-testdeep.zetta.rocks/introduction/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/introduction/index.html</guid><description>Synopsis Make golang tests easy, from simplest usage:
import ( "testing" "github.com/maxatome/go-testdeep/td" ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), &amp;Info{Name: "Alice", Age: 42}) } To a bit more complex one, allowing flexible comparisons using TestDeep operators:
import ( "testing" "github.com/maxatome/go-testdeep/td" ) func TestMyFunc(t *testing.T) { td.Cmp(t, MyFunc(), td.Struct( &amp;Info{Name: "Alice"}, td.StructFields{ "Age": td.Between(40, 45), }, )) } Or anchoring operators directly in literals, as in:
import ( "testing" "github.com/maxatome/go-testdeep/td" ) func TestMyFunc(tt *testing.T) { t := td.NewT(tt) t.Cmp(MyFunc(), &amp;Info{ Name: "Alice", Age: t.Anchor(td.Between(40, 45)).(int), }) } To most complex one, allowing to easily test HTTP API routes, using flexible operators and the tdhttp helper:</description></item><item><title>Tutorial</title><link>https://go-testdeep.zetta.rocks/example/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/example/index.html</guid><description>Imagine a function returning a struct containing a newly created database record. The Id and the CreatedAt fields are set by the database layer:
type Record struct { Id uint64 Name string Age int CreatedAt time.Time } func CreateRecord(name string, age int) (*Record, error) { // Do INSERT INTO … and return newly created record or error if it failed }</description></item><item><title>Functions</title><link>https://go-testdeep.zetta.rocks/functions/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/functions/index.html</guid><description>import ( "testing" "github.com/maxatome/go-testdeep/td" ) func TestMyFunc(t *testing.T) { // Compares MyFunc() result against a fixed value td.Cmp(t, MyFunc(), 128, "MyFunc() result is 128") // Compares MyFunc() result using the Between Testdeep operator td.Cmp(t, MyFunc(), td.Between(100, 199), "MyFunc() result is between 100 and 199") } func Cmp(t TestingT, got, expected any, args ...any) bool func CmpError(t TestingT, got error, args ...any) bool func CmpFalse(t TestingT, got any, args ...any) bool func CmpLax(t TestingT, got, expected any, args ...any) bool (in fact the shortcut of Lax operator) func CmpNoError(t TestingT, got error, args ...any) bool func CmpNot(t TestingT, got, notExpected any, args ...any) bool (in fact the shortcut of Not operator) func CmpNotPanic(t TestingT, fn func(), args ...any) bool func CmpPanic(t TestingT, fn func(), expectedPanic any, args ...any) bool func CmpTrue(t TestingT, got any, args ...any) bool func EqDeeply(got, expected any) bool func EqDeeplyError(got, expected any) error CmpDeeply() is now replaced by Cmp(), but it is still available for backward compatibility purpose.</description></item><item><title>Operators</title><link>https://go-testdeep.zetta.rocks/operators/index.html</link><pubDate>Thu, 03 Oct 2019 22:20:09 +0200</pubDate><guid>https://go-testdeep.zetta.rocks/operators/index.html</guid><description>All operators All all expected values have to match Any at least one expected value have to match Array compares the contents of an array or a pointer on an array ArrayEach compares each array or slice item Bag compares the contents of an array or a slice without taking care of the order of items Between checks that a number, string or time.Time is between two bounds Cap checks an array, slice or channel capacity Catch catches data on the fly before comparing it Code checks using a custom function Contains checks that a string, []byte, error or fmt.Stringer interfaces contain a rune, byte or a sub-string; or a slice contains a single value or a sub-slice; or an array or map contain a single value ContainsKey checks that a map contains a key Delay delays the operator construction till first use Empty checks that an array, a channel, a map, a slice or a string is empty ErrorIs checks the data is an error and matches a wrapped error First find the first matching item of a slice or an array then compare its content Grep reduces a slice or an array before comparing its content Gt checks that a number, string or time.Time is greater than a value Gte checks that a number, string or time.Time is greater or equal than a value HasPrefix checks the prefix of a string, []byte, error or fmt.Stringer interfaces HasSuffix checks the suffix of a string, []byte, error or fmt.Stringer interfaces Ignore allows to ignore a comparison Isa checks the data type or whether data implements an interface or not JSON compares against JSON representation JSONPointer compares against JSON representation using a JSON pointer Keys checks keys of a map Last find the last matching item of a slice or an array then compare its content Lax temporarily enables BeLax config flag Len checks an array, slice, map, string or channel length List compares the contents of an array or a slice with taking care of the order of items Lt checks that a number, string or time.Time is lesser than a value Lte checks that a number, string or time.Time is lesser or equal than a value Map compares the contents of a map MapEach compares each map entry N compares a number with a tolerance value NaN checks a floating number is math.NaN Nil compares to nil None no values have to match Not value must not match NotAny compares the contents of an array or a slice, no values have to match NotEmpty checks that an array, a channel, a map, a slice or a string is not empty NotNaN checks a floating number is not math.NaN NotNil checks that data is not nil NotZero checks that data is not zero regarding its type PPtr allows to easily test a pointer of pointer value Ptr allows to easily test a pointer value Re allows to apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups ReAll allows to successively apply a regexp on a string (or convertible), []byte, error or fmt.Stringer interfaces, and even test the captured groups Recv checks the value read from a channel Set compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items Shallow compares pointers only, not their contents Slice compares the contents of a slice or a pointer on a slice Smuggle changes data contents or mutates it into another type via a custom function or a struct fields-path before stepping down in favor of generic comparison process Sort sorts a slice or an array before comparing its content Sorted checks a slice or an array is sorted SStruct strictly compares the contents of a struct or a pointer on a struct String checks a string, []byte, error or fmt.Stringer interfaces string contents Struct compares the contents of a struct or a pointer on a struct SubBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some exclusions SubJSONOf compares struct or map against JSON representation but with potentially some exclusions SubMapOf compares the contents of a map but with potentially some exclusions SubSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some exclusions SuperBagOf compares the contents of an array or a slice without taking care of the order of items but with potentially some extra items SuperJSONOf compares struct or map against JSON representation but with potentially extra entries SuperMapOf compares the contents of a map but with potentially some extra entries SuperSetOf compares the contents of an array or a slice ignoring duplicates and without taking care of the order of items but with potentially some extra items SuperSliceOf compares the contents of a slice, a pointer on a slice, an array or a pointer on an array but with potentially some extra entries Tag names an operator or a value. Only useful as a parameter of JSON operator, to name placeholders TruncTime compares time.Time (or assignable) values after truncating them Values checks values of a map Zero checks data against its zero’ed conterpart Smuggler operators A smuggler operator is an operator able to transform the value (by changing its value or even its type) before comparing it.</description></item><item><title>Helpers</title><link>https://go-testdeep.zetta.rocks/helpers/index.html</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://go-testdeep.zetta.rocks/helpers/index.html</guid><description>HTTP API test helper aka tdhttp The tdhttp package helper allows to easily test HTTP APIs.
It handles any kind of API, with some specific features for the routes accepting and/or returning JSON or XML.
All known web frameworks are handled:
net/http standard, see Main example below Beego echo Gin gorilla/mux go-swagger HttpRouter pat and any other ones as long as they provide a net/http.Handler instance. See examples of use in tdhttp package example section, in FAQ or expand the one below:</description></item><item><title>FAQ</title><link>https://go-testdeep.zetta.rocks/faq/index.html</link><pubDate>Tue, 08 Oct 2019 21:28:21 +0200</pubDate><guid>https://go-testdeep.zetta.rocks/faq/index.html</guid><description>How to mix strict requirements and simple assertions? import ( "testing" "github.com/maxatome/go-testdeep/td" ) func TestAssertionsAndRequirements(t *testing.T) { assert, require := td.AssertRequire(t) got := SomeFunction() require.Cmp(got, expected) // if it fails: report error + abort assert.Cmp(got, expected) // if it fails: report error + continue } Why nil is handled so specifically? var pn *int td.Cmp(t, pn, nil) fails with the error And, yes, it is normal. (TL;DR use CmpNil instead, safer, or use CmpLax, but be careful of edge cases.)</description></item></channel></rss>